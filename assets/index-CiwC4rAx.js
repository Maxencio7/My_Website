var QF=Object.defineProperty;var XF=(e,t,n)=>t in e?QF(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var ie=(e,t,n)=>XF(e,typeof t!="symbol"?t+"":t,n);function YF(e,t){for(var n=0;n<t.length;n++){const r=t[n];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in e)){const i=Object.getOwnPropertyDescriptor(r,s);i&&Object.defineProperty(e,s,i.get?i:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function n(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function r(s){if(s.ep)return;s.ep=!0;const i=n(s);fetch(s.href,i)}})();function ZS(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var eC={exports:{}},cf={},tC={exports:{}},Ot={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var pc=Symbol.for("react.element"),JF=Symbol.for("react.portal"),ZF=Symbol.for("react.fragment"),e3=Symbol.for("react.strict_mode"),t3=Symbol.for("react.profiler"),n3=Symbol.for("react.provider"),r3=Symbol.for("react.context"),s3=Symbol.for("react.forward_ref"),i3=Symbol.for("react.suspense"),o3=Symbol.for("react.memo"),a3=Symbol.for("react.lazy"),Wx=Symbol.iterator;function l3(e){return e===null||typeof e!="object"?null:(e=Wx&&e[Wx]||e["@@iterator"],typeof e=="function"?e:null)}var nC={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},rC=Object.assign,sC={};function wl(e,t,n){this.props=e,this.context=t,this.refs=sC,this.updater=n||nC}wl.prototype.isReactComponent={};wl.prototype.setState=function(e,t){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")};wl.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function iC(){}iC.prototype=wl.prototype;function t0(e,t,n){this.props=e,this.context=t,this.refs=sC,this.updater=n||nC}var n0=t0.prototype=new iC;n0.constructor=t0;rC(n0,wl.prototype);n0.isPureReactComponent=!0;var Gx=Array.isArray,oC=Object.prototype.hasOwnProperty,r0={current:null},aC={key:!0,ref:!0,__self:!0,__source:!0};function lC(e,t,n){var r,s={},i=null,o=null;if(t!=null)for(r in t.ref!==void 0&&(o=t.ref),t.key!==void 0&&(i=""+t.key),t)oC.call(t,r)&&!aC.hasOwnProperty(r)&&(s[r]=t[r]);var a=arguments.length-2;if(a===1)s.children=n;else if(1<a){for(var l=Array(a),u=0;u<a;u++)l[u]=arguments[u+2];s.children=l}if(e&&e.defaultProps)for(r in a=e.defaultProps,a)s[r]===void 0&&(s[r]=a[r]);return{$$typeof:pc,type:e,key:i,ref:o,props:s,_owner:r0.current}}function u3(e,t){return{$$typeof:pc,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}function s0(e){return typeof e=="object"&&e!==null&&e.$$typeof===pc}function c3(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(n){return t[n]})}var Hx=/\/+/g;function Wh(e,t){return typeof e=="object"&&e!==null&&e.key!=null?c3(""+e.key):t.toString(36)}function tp(e,t,n,r,s){var i=typeof e;(i==="undefined"||i==="boolean")&&(e=null);var o=!1;if(e===null)o=!0;else switch(i){case"string":case"number":o=!0;break;case"object":switch(e.$$typeof){case pc:case JF:o=!0}}if(o)return o=e,s=s(o),e=r===""?"."+Wh(o,0):r,Gx(s)?(n="",e!=null&&(n=e.replace(Hx,"$&/")+"/"),tp(s,t,n,"",function(u){return u})):s!=null&&(s0(s)&&(s=u3(s,n+(!s.key||o&&o.key===s.key?"":(""+s.key).replace(Hx,"$&/")+"/")+e)),t.push(s)),1;if(o=0,r=r===""?".":r+":",Gx(e))for(var a=0;a<e.length;a++){i=e[a];var l=r+Wh(i,a);o+=tp(i,t,n,l,s)}else if(l=l3(e),typeof l=="function")for(e=l.call(e),a=0;!(i=e.next()).done;)i=i.value,l=r+Wh(i,a++),o+=tp(i,t,n,l,s);else if(i==="object")throw t=String(e),Error("Objects are not valid as a React child (found: "+(t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return o}function yd(e,t,n){if(e==null)return e;var r=[],s=0;return tp(e,r,"","",function(i){return t.call(n,i,s++)}),r}function d3(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(n){(e._status===0||e._status===-1)&&(e._status=1,e._result=n)},function(n){(e._status===0||e._status===-1)&&(e._status=2,e._result=n)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var Mr={current:null},np={transition:null},p3={ReactCurrentDispatcher:Mr,ReactCurrentBatchConfig:np,ReactCurrentOwner:r0};function uC(){throw Error("act(...) is not supported in production builds of React.")}Ot.Children={map:yd,forEach:function(e,t,n){yd(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return yd(e,function(){t++}),t},toArray:function(e){return yd(e,function(t){return t})||[]},only:function(e){if(!s0(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};Ot.Component=wl;Ot.Fragment=ZF;Ot.Profiler=t3;Ot.PureComponent=t0;Ot.StrictMode=e3;Ot.Suspense=i3;Ot.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=p3;Ot.act=uC;Ot.cloneElement=function(e,t,n){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var r=rC({},e.props),s=e.key,i=e.ref,o=e._owner;if(t!=null){if(t.ref!==void 0&&(i=t.ref,o=r0.current),t.key!==void 0&&(s=""+t.key),e.type&&e.type.defaultProps)var a=e.type.defaultProps;for(l in t)oC.call(t,l)&&!aC.hasOwnProperty(l)&&(r[l]=t[l]===void 0&&a!==void 0?a[l]:t[l])}var l=arguments.length-2;if(l===1)r.children=n;else if(1<l){a=Array(l);for(var u=0;u<l;u++)a[u]=arguments[u+2];r.children=a}return{$$typeof:pc,type:e.type,key:s,ref:i,props:r,_owner:o}};Ot.createContext=function(e){return e={$$typeof:r3,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:n3,_context:e},e.Consumer=e};Ot.createElement=lC;Ot.createFactory=function(e){var t=lC.bind(null,e);return t.type=e,t};Ot.createRef=function(){return{current:null}};Ot.forwardRef=function(e){return{$$typeof:s3,render:e}};Ot.isValidElement=s0;Ot.lazy=function(e){return{$$typeof:a3,_payload:{_status:-1,_result:e},_init:d3}};Ot.memo=function(e,t){return{$$typeof:o3,type:e,compare:t===void 0?null:t}};Ot.startTransition=function(e){var t=np.transition;np.transition={};try{e()}finally{np.transition=t}};Ot.unstable_act=uC;Ot.useCallback=function(e,t){return Mr.current.useCallback(e,t)};Ot.useContext=function(e){return Mr.current.useContext(e)};Ot.useDebugValue=function(){};Ot.useDeferredValue=function(e){return Mr.current.useDeferredValue(e)};Ot.useEffect=function(e,t){return Mr.current.useEffect(e,t)};Ot.useId=function(){return Mr.current.useId()};Ot.useImperativeHandle=function(e,t,n){return Mr.current.useImperativeHandle(e,t,n)};Ot.useInsertionEffect=function(e,t){return Mr.current.useInsertionEffect(e,t)};Ot.useLayoutEffect=function(e,t){return Mr.current.useLayoutEffect(e,t)};Ot.useMemo=function(e,t){return Mr.current.useMemo(e,t)};Ot.useReducer=function(e,t,n){return Mr.current.useReducer(e,t,n)};Ot.useRef=function(e){return Mr.current.useRef(e)};Ot.useState=function(e){return Mr.current.useState(e)};Ot.useSyncExternalStore=function(e,t,n){return Mr.current.useSyncExternalStore(e,t,n)};Ot.useTransition=function(){return Mr.current.useTransition()};Ot.version="18.3.1";tC.exports=Ot;var Fe=tC.exports;const Ze=ZS(Fe),f3=YF({__proto__:null,default:Ze},[Fe]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var h3=Fe,m3=Symbol.for("react.element"),_3=Symbol.for("react.fragment"),g3=Object.prototype.hasOwnProperty,y3=h3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,v3={key:!0,ref:!0,__self:!0,__source:!0};function cC(e,t,n){var r,s={},i=null,o=null;n!==void 0&&(i=""+n),t.key!==void 0&&(i=""+t.key),t.ref!==void 0&&(o=t.ref);for(r in t)g3.call(t,r)&&!v3.hasOwnProperty(r)&&(s[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps,t)s[r]===void 0&&(s[r]=t[r]);return{$$typeof:m3,type:e,key:i,ref:o,props:s,_owner:y3.current}}cf.Fragment=_3;cf.jsx=cC;cf.jsxs=cC;eC.exports=cf;var xe=eC.exports,dC={exports:{}},Qr={},pC={exports:{}},fC={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(e){function t(K,oe){var se=K.length;K.push(oe);e:for(;0<se;){var F=se-1>>>1,I=K[F];if(0<s(I,oe))K[F]=oe,K[se]=I,se=F;else break e}}function n(K){return K.length===0?null:K[0]}function r(K){if(K.length===0)return null;var oe=K[0],se=K.pop();if(se!==oe){K[0]=se;e:for(var F=0,I=K.length,V=I>>>1;F<V;){var ee=2*(F+1)-1,pe=K[ee],Z=ee+1,de=K[Z];if(0>s(pe,se))Z<I&&0>s(de,pe)?(K[F]=de,K[Z]=se,F=Z):(K[F]=pe,K[ee]=se,F=ee);else if(Z<I&&0>s(de,se))K[F]=de,K[Z]=se,F=Z;else break e}}return oe}function s(K,oe){var se=K.sortIndex-oe.sortIndex;return se!==0?se:K.id-oe.id}if(typeof performance=="object"&&typeof performance.now=="function"){var i=performance;e.unstable_now=function(){return i.now()}}else{var o=Date,a=o.now();e.unstable_now=function(){return o.now()-a}}var l=[],u=[],p=1,c=null,d=3,f=!1,m=!1,y=!1,C=typeof setTimeout=="function"?setTimeout:null,_=typeof clearTimeout=="function"?clearTimeout:null,h=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function w(K){for(var oe=n(u);oe!==null;){if(oe.callback===null)r(u);else if(oe.startTime<=K)r(u),oe.sortIndex=oe.expirationTime,t(l,oe);else break;oe=n(u)}}function M(K){if(y=!1,w(K),!m)if(n(l)!==null)m=!0,X(x);else{var oe=n(u);oe!==null&&Y(M,oe.startTime-K)}}function x(K,oe){m=!1,y&&(y=!1,_(S),S=-1),f=!0;var se=d;try{for(w(oe),c=n(l);c!==null&&(!(c.expirationTime>oe)||K&&!G());){var F=c.callback;if(typeof F=="function"){c.callback=null,d=c.priorityLevel;var I=F(c.expirationTime<=oe);oe=e.unstable_now(),typeof I=="function"?c.callback=I:c===n(l)&&r(l),w(oe)}else r(l);c=n(l)}if(c!==null)var V=!0;else{var ee=n(u);ee!==null&&Y(M,ee.startTime-oe),V=!1}return V}finally{c=null,d=se,f=!1}}var b=!1,T=null,S=-1,$=5,O=-1;function G(){return!(e.unstable_now()-O<$)}function H(){if(T!==null){var K=e.unstable_now();O=K;var oe=!0;try{oe=T(!0,K)}finally{oe?N():(b=!1,T=null)}}else b=!1}var N;if(typeof h=="function")N=function(){h(H)};else if(typeof MessageChannel<"u"){var J=new MessageChannel,q=J.port2;J.port1.onmessage=H,N=function(){q.postMessage(null)}}else N=function(){C(H,0)};function X(K){T=K,b||(b=!0,N())}function Y(K,oe){S=C(function(){K(e.unstable_now())},oe)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(K){K.callback=null},e.unstable_continueExecution=function(){m||f||(m=!0,X(x))},e.unstable_forceFrameRate=function(K){0>K||125<K?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):$=0<K?Math.floor(1e3/K):5},e.unstable_getCurrentPriorityLevel=function(){return d},e.unstable_getFirstCallbackNode=function(){return n(l)},e.unstable_next=function(K){switch(d){case 1:case 2:case 3:var oe=3;break;default:oe=d}var se=d;d=oe;try{return K()}finally{d=se}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(K,oe){switch(K){case 1:case 2:case 3:case 4:case 5:break;default:K=3}var se=d;d=K;try{return oe()}finally{d=se}},e.unstable_scheduleCallback=function(K,oe,se){var F=e.unstable_now();switch(typeof se=="object"&&se!==null?(se=se.delay,se=typeof se=="number"&&0<se?F+se:F):se=F,K){case 1:var I=-1;break;case 2:I=250;break;case 5:I=1073741823;break;case 4:I=1e4;break;default:I=5e3}return I=se+I,K={id:p++,callback:oe,priorityLevel:K,startTime:se,expirationTime:I,sortIndex:-1},se>F?(K.sortIndex=se,t(u,K),n(l)===null&&K===n(u)&&(y?(_(S),S=-1):y=!0,Y(M,se-F))):(K.sortIndex=I,t(l,K),m||f||(m=!0,X(x))),K},e.unstable_shouldYield=G,e.unstable_wrapCallback=function(K){var oe=d;return function(){var se=d;d=oe;try{return K.apply(this,arguments)}finally{d=se}}}})(fC);pC.exports=fC;var w3=pC.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var M3=Fe,Kr=w3;function He(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var hC=new Set,ju={};function da(e,t){ul(e,t),ul(e+"Capture",t)}function ul(e,t){for(ju[e]=t,e=0;e<t.length;e++)hC.add(t[e])}var hi=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),C_=Object.prototype.hasOwnProperty,x3=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Kx={},qx={};function b3(e){return C_.call(qx,e)?!0:C_.call(Kx,e)?!1:x3.test(e)?qx[e]=!0:(Kx[e]=!0,!1)}function T3(e,t,n,r){if(n!==null&&n.type===0)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return r?!1:n!==null?!n.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function E3(e,t,n,r){if(t===null||typeof t>"u"||T3(e,t,n,r))return!0;if(r)return!1;if(n!==null)switch(n.type){case 3:return!t;case 4:return t===!1;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}function xr(e,t,n,r,s,i,o){this.acceptsBooleans=t===2||t===3||t===4,this.attributeName=r,this.attributeNamespace=s,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=i,this.removeEmptyString=o}var ir={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){ir[e]=new xr(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];ir[t]=new xr(t,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){ir[e]=new xr(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){ir[e]=new xr(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){ir[e]=new xr(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){ir[e]=new xr(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){ir[e]=new xr(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){ir[e]=new xr(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){ir[e]=new xr(e,5,!1,e.toLowerCase(),null,!1,!1)});var i0=/[\-:]([a-z])/g;function o0(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace(i0,o0);ir[t]=new xr(t,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace(i0,o0);ir[t]=new xr(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace(i0,o0);ir[t]=new xr(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){ir[e]=new xr(e,1,!1,e.toLowerCase(),null,!1,!1)});ir.xlinkHref=new xr("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){ir[e]=new xr(e,1,!1,e.toLowerCase(),null,!0,!0)});function a0(e,t,n,r){var s=ir.hasOwnProperty(t)?ir[t]:null;(s!==null?s.type!==0:r||!(2<t.length)||t[0]!=="o"&&t[0]!=="O"||t[1]!=="n"&&t[1]!=="N")&&(E3(t,n,s,r)&&(n=null),r||s===null?b3(t)&&(n===null?e.removeAttribute(t):e.setAttribute(t,""+n)):s.mustUseProperty?e[s.propertyName]=n===null?s.type===3?!1:"":n:(t=s.attributeName,r=s.attributeNamespace,n===null?e.removeAttribute(t):(s=s.type,n=s===3||s===4&&n===!0?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}var vi=M3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,vd=Symbol.for("react.element"),Ba=Symbol.for("react.portal"),Na=Symbol.for("react.fragment"),l0=Symbol.for("react.strict_mode"),k_=Symbol.for("react.profiler"),mC=Symbol.for("react.provider"),_C=Symbol.for("react.context"),u0=Symbol.for("react.forward_ref"),$_=Symbol.for("react.suspense"),I_=Symbol.for("react.suspense_list"),c0=Symbol.for("react.memo"),Li=Symbol.for("react.lazy"),gC=Symbol.for("react.offscreen"),Qx=Symbol.iterator;function Jl(e){return e===null||typeof e!="object"?null:(e=Qx&&e[Qx]||e["@@iterator"],typeof e=="function"?e:null)}var vn=Object.assign,Gh;function yu(e){if(Gh===void 0)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);Gh=t&&t[1]||""}return`
`+Gh+e}var Hh=!1;function Kh(e,t){if(!e||Hh)return"";Hh=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(t,[])}catch(u){var r=u}Reflect.construct(e,[],t)}else{try{t.call()}catch(u){r=u}e.call(t.prototype)}else{try{throw Error()}catch(u){r=u}e()}}catch(u){if(u&&r&&typeof u.stack=="string"){for(var s=u.stack.split(`
`),i=r.stack.split(`
`),o=s.length-1,a=i.length-1;1<=o&&0<=a&&s[o]!==i[a];)a--;for(;1<=o&&0<=a;o--,a--)if(s[o]!==i[a]){if(o!==1||a!==1)do if(o--,a--,0>a||s[o]!==i[a]){var l=`
`+s[o].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}while(1<=o&&0<=a);break}}}finally{Hh=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?yu(e):""}function P3(e){switch(e.tag){case 5:return yu(e.type);case 16:return yu("Lazy");case 13:return yu("Suspense");case 19:return yu("SuspenseList");case 0:case 2:case 15:return e=Kh(e.type,!1),e;case 11:return e=Kh(e.type.render,!1),e;case 1:return e=Kh(e.type,!0),e;default:return""}}function A_(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case Na:return"Fragment";case Ba:return"Portal";case k_:return"Profiler";case l0:return"StrictMode";case $_:return"Suspense";case I_:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case _C:return(e.displayName||"Context")+".Consumer";case mC:return(e._context.displayName||"Context")+".Provider";case u0:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case c0:return t=e.displayName||null,t!==null?t:A_(e.type)||"Memo";case Li:t=e._payload,e=e._init;try{return A_(e(t))}catch{}}return null}function S3(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=t.render,e=e.displayName||e.name||"",t.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return A_(t);case 8:return t===l0?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t}return null}function Zi(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function yC(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function C3(e){var t=yC(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var s=n.get,i=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return s.call(this)},set:function(o){r=""+o,i.call(this,o)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(o){r=""+o},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function wd(e){e._valueTracker||(e._valueTracker=C3(e))}function vC(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=yC(e)?e.checked?"true":"false":e.value),e=r,e!==n?(t.setValue(e),!0):!1}function wp(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function D_(e,t){var n=t.checked;return vn({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??e._wrapperState.initialChecked})}function Xx(e,t){var n=t.defaultValue==null?"":t.defaultValue,r=t.checked!=null?t.checked:t.defaultChecked;n=Zi(t.value!=null?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:t.type==="checkbox"||t.type==="radio"?t.checked!=null:t.value!=null}}function wC(e,t){t=t.checked,t!=null&&a0(e,"checked",t,!1)}function O_(e,t){wC(e,t);var n=Zi(t.value),r=t.type;if(n!=null)r==="number"?(n===0&&e.value===""||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if(r==="submit"||r==="reset"){e.removeAttribute("value");return}t.hasOwnProperty("value")?F_(e,t.type,n):t.hasOwnProperty("defaultValue")&&F_(e,t.type,Zi(t.defaultValue)),t.checked==null&&t.defaultChecked!=null&&(e.defaultChecked=!!t.defaultChecked)}function Yx(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!(r!=="submit"&&r!=="reset"||t.value!==void 0&&t.value!==null))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}n=e.name,n!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,n!==""&&(e.name=n)}function F_(e,t,n){(t!=="number"||wp(e.ownerDocument)!==e)&&(n==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var vu=Array.isArray;function rl(e,t,n,r){if(e=e.options,t){t={};for(var s=0;s<n.length;s++)t["$"+n[s]]=!0;for(n=0;n<e.length;n++)s=t.hasOwnProperty("$"+e[n].value),e[n].selected!==s&&(e[n].selected=s),s&&r&&(e[n].defaultSelected=!0)}else{for(n=""+Zi(n),t=null,s=0;s<e.length;s++){if(e[s].value===n){e[s].selected=!0,r&&(e[s].defaultSelected=!0);return}t!==null||e[s].disabled||(t=e[s])}t!==null&&(t.selected=!0)}}function L_(e,t){if(t.dangerouslySetInnerHTML!=null)throw Error(He(91));return vn({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function Jx(e,t){var n=t.value;if(n==null){if(n=t.children,t=t.defaultValue,n!=null){if(t!=null)throw Error(He(92));if(vu(n)){if(1<n.length)throw Error(He(93));n=n[0]}t=n}t==null&&(t=""),n=t}e._wrapperState={initialValue:Zi(n)}}function MC(e,t){var n=Zi(t.value),r=Zi(t.defaultValue);n!=null&&(n=""+n,n!==e.value&&(e.value=n),t.defaultValue==null&&e.defaultValue!==n&&(e.defaultValue=n)),r!=null&&(e.defaultValue=""+r)}function Zx(e){var t=e.textContent;t===e._wrapperState.initialValue&&t!==""&&t!==null&&(e.value=t)}function xC(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function z_(e,t){return e==null||e==="http://www.w3.org/1999/xhtml"?xC(t):e==="http://www.w3.org/2000/svg"&&t==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var Md,bC=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(t,n,r,s){MSApp.execUnsafeLocalFunction(function(){return e(t,n,r,s)})}:e}(function(e,t){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=t;else{for(Md=Md||document.createElement("div"),Md.innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=Md.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}});function Vu(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=t;return}}e.textContent=t}var Su={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},k3=["Webkit","ms","Moz","O"];Object.keys(Su).forEach(function(e){k3.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),Su[t]=Su[e]})});function TC(e,t,n){return t==null||typeof t=="boolean"||t===""?"":n||typeof t!="number"||t===0||Su.hasOwnProperty(e)&&Su[e]?(""+t).trim():t+"px"}function EC(e,t){e=e.style;for(var n in t)if(t.hasOwnProperty(n)){var r=n.indexOf("--")===0,s=TC(n,t[n],r);n==="float"&&(n="cssFloat"),r?e.setProperty(n,s):e[n]=s}}var $3=vn({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function R_(e,t){if(t){if($3[e]&&(t.children!=null||t.dangerouslySetInnerHTML!=null))throw Error(He(137,e));if(t.dangerouslySetInnerHTML!=null){if(t.children!=null)throw Error(He(60));if(typeof t.dangerouslySetInnerHTML!="object"||!("__html"in t.dangerouslySetInnerHTML))throw Error(He(61))}if(t.style!=null&&typeof t.style!="object")throw Error(He(62))}}function B_(e,t){if(e.indexOf("-")===-1)return typeof t.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var N_=null;function d0(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var j_=null,sl=null,il=null;function eb(e){if(e=mc(e)){if(typeof j_!="function")throw Error(He(280));var t=e.stateNode;t&&(t=mf(t),j_(e.stateNode,e.type,t))}}function PC(e){sl?il?il.push(e):il=[e]:sl=e}function SC(){if(sl){var e=sl,t=il;if(il=sl=null,eb(e),t)for(e=0;e<t.length;e++)eb(t[e])}}function CC(e,t){return e(t)}function kC(){}var qh=!1;function $C(e,t,n){if(qh)return e(t,n);qh=!0;try{return CC(e,t,n)}finally{qh=!1,(sl!==null||il!==null)&&(kC(),SC())}}function Uu(e,t){var n=e.stateNode;if(n===null)return null;var r=mf(n);if(r===null)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(e=e.type,r=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!r;break e;default:e=!1}if(e)return null;if(n&&typeof n!="function")throw Error(He(231,t,typeof n));return n}var V_=!1;if(hi)try{var Zl={};Object.defineProperty(Zl,"passive",{get:function(){V_=!0}}),window.addEventListener("test",Zl,Zl),window.removeEventListener("test",Zl,Zl)}catch{V_=!1}function I3(e,t,n,r,s,i,o,a,l){var u=Array.prototype.slice.call(arguments,3);try{t.apply(n,u)}catch(p){this.onError(p)}}var Cu=!1,Mp=null,xp=!1,U_=null,A3={onError:function(e){Cu=!0,Mp=e}};function D3(e,t,n,r,s,i,o,a,l){Cu=!1,Mp=null,I3.apply(A3,arguments)}function O3(e,t,n,r,s,i,o,a,l){if(D3.apply(this,arguments),Cu){if(Cu){var u=Mp;Cu=!1,Mp=null}else throw Error(He(198));xp||(xp=!0,U_=u)}}function pa(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,t.flags&4098&&(n=t.return),e=t.return;while(e)}return t.tag===3?n:null}function IC(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function tb(e){if(pa(e)!==e)throw Error(He(188))}function F3(e){var t=e.alternate;if(!t){if(t=pa(e),t===null)throw Error(He(188));return t!==e?null:e}for(var n=e,r=t;;){var s=n.return;if(s===null)break;var i=s.alternate;if(i===null){if(r=s.return,r!==null){n=r;continue}break}if(s.child===i.child){for(i=s.child;i;){if(i===n)return tb(s),e;if(i===r)return tb(s),t;i=i.sibling}throw Error(He(188))}if(n.return!==r.return)n=s,r=i;else{for(var o=!1,a=s.child;a;){if(a===n){o=!0,n=s,r=i;break}if(a===r){o=!0,r=s,n=i;break}a=a.sibling}if(!o){for(a=i.child;a;){if(a===n){o=!0,n=i,r=s;break}if(a===r){o=!0,r=i,n=s;break}a=a.sibling}if(!o)throw Error(He(189))}}if(n.alternate!==r)throw Error(He(190))}if(n.tag!==3)throw Error(He(188));return n.stateNode.current===n?e:t}function AC(e){return e=F3(e),e!==null?DC(e):null}function DC(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var t=DC(e);if(t!==null)return t;e=e.sibling}return null}var OC=Kr.unstable_scheduleCallback,nb=Kr.unstable_cancelCallback,L3=Kr.unstable_shouldYield,z3=Kr.unstable_requestPaint,In=Kr.unstable_now,R3=Kr.unstable_getCurrentPriorityLevel,p0=Kr.unstable_ImmediatePriority,FC=Kr.unstable_UserBlockingPriority,bp=Kr.unstable_NormalPriority,B3=Kr.unstable_LowPriority,LC=Kr.unstable_IdlePriority,df=null,Ks=null;function N3(e){if(Ks&&typeof Ks.onCommitFiberRoot=="function")try{Ks.onCommitFiberRoot(df,e,void 0,(e.current.flags&128)===128)}catch{}}var Ds=Math.clz32?Math.clz32:U3,j3=Math.log,V3=Math.LN2;function U3(e){return e>>>=0,e===0?32:31-(j3(e)/V3|0)|0}var xd=64,bd=4194304;function wu(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function Tp(e,t){var n=e.pendingLanes;if(n===0)return 0;var r=0,s=e.suspendedLanes,i=e.pingedLanes,o=n&268435455;if(o!==0){var a=o&~s;a!==0?r=wu(a):(i&=o,i!==0&&(r=wu(i)))}else o=n&~s,o!==0?r=wu(o):i!==0&&(r=wu(i));if(r===0)return 0;if(t!==0&&t!==r&&!(t&s)&&(s=r&-r,i=t&-t,s>=i||s===16&&(i&4194240)!==0))return t;if(r&4&&(r|=n&16),t=e.entangledLanes,t!==0)for(e=e.entanglements,t&=r;0<t;)n=31-Ds(t),s=1<<n,r|=e[n],t&=~s;return r}function W3(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function G3(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,s=e.expirationTimes,i=e.pendingLanes;0<i;){var o=31-Ds(i),a=1<<o,l=s[o];l===-1?(!(a&n)||a&r)&&(s[o]=W3(a,t)):l<=t&&(e.expiredLanes|=a),i&=~a}}function W_(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function zC(){var e=xd;return xd<<=1,!(xd&4194240)&&(xd=64),e}function Qh(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function fc(e,t,n){e.pendingLanes|=t,t!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,t=31-Ds(t),e[t]=n}function H3(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var s=31-Ds(n),i=1<<s;t[s]=0,r[s]=-1,e[s]=-1,n&=~i}}function f0(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-Ds(n),s=1<<r;s&t|e[r]&t&&(e[r]|=t),n&=~s}}var Qt=0;function RC(e){return e&=-e,1<e?4<e?e&268435455?16:536870912:4:1}var BC,h0,NC,jC,VC,G_=!1,Td=[],Wi=null,Gi=null,Hi=null,Wu=new Map,Gu=new Map,Bi=[],K3="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function rb(e,t){switch(e){case"focusin":case"focusout":Wi=null;break;case"dragenter":case"dragleave":Gi=null;break;case"mouseover":case"mouseout":Hi=null;break;case"pointerover":case"pointerout":Wu.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Gu.delete(t.pointerId)}}function eu(e,t,n,r,s,i){return e===null||e.nativeEvent!==i?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:i,targetContainers:[s]},t!==null&&(t=mc(t),t!==null&&h0(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,s!==null&&t.indexOf(s)===-1&&t.push(s),e)}function q3(e,t,n,r,s){switch(t){case"focusin":return Wi=eu(Wi,e,t,n,r,s),!0;case"dragenter":return Gi=eu(Gi,e,t,n,r,s),!0;case"mouseover":return Hi=eu(Hi,e,t,n,r,s),!0;case"pointerover":var i=s.pointerId;return Wu.set(i,eu(Wu.get(i)||null,e,t,n,r,s)),!0;case"gotpointercapture":return i=s.pointerId,Gu.set(i,eu(Gu.get(i)||null,e,t,n,r,s)),!0}return!1}function UC(e){var t=qo(e.target);if(t!==null){var n=pa(t);if(n!==null){if(t=n.tag,t===13){if(t=IC(n),t!==null){e.blockedOn=t,VC(e.priority,function(){NC(n)});return}}else if(t===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function rp(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var n=H_(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(n===null){n=e.nativeEvent;var r=new n.constructor(n.type,n);N_=r,n.target.dispatchEvent(r),N_=null}else return t=mc(n),t!==null&&h0(t),e.blockedOn=n,!1;t.shift()}return!0}function sb(e,t,n){rp(e)&&n.delete(t)}function Q3(){G_=!1,Wi!==null&&rp(Wi)&&(Wi=null),Gi!==null&&rp(Gi)&&(Gi=null),Hi!==null&&rp(Hi)&&(Hi=null),Wu.forEach(sb),Gu.forEach(sb)}function tu(e,t){e.blockedOn===t&&(e.blockedOn=null,G_||(G_=!0,Kr.unstable_scheduleCallback(Kr.unstable_NormalPriority,Q3)))}function Hu(e){function t(s){return tu(s,e)}if(0<Td.length){tu(Td[0],e);for(var n=1;n<Td.length;n++){var r=Td[n];r.blockedOn===e&&(r.blockedOn=null)}}for(Wi!==null&&tu(Wi,e),Gi!==null&&tu(Gi,e),Hi!==null&&tu(Hi,e),Wu.forEach(t),Gu.forEach(t),n=0;n<Bi.length;n++)r=Bi[n],r.blockedOn===e&&(r.blockedOn=null);for(;0<Bi.length&&(n=Bi[0],n.blockedOn===null);)UC(n),n.blockedOn===null&&Bi.shift()}var ol=vi.ReactCurrentBatchConfig,Ep=!0;function X3(e,t,n,r){var s=Qt,i=ol.transition;ol.transition=null;try{Qt=1,m0(e,t,n,r)}finally{Qt=s,ol.transition=i}}function Y3(e,t,n,r){var s=Qt,i=ol.transition;ol.transition=null;try{Qt=4,m0(e,t,n,r)}finally{Qt=s,ol.transition=i}}function m0(e,t,n,r){if(Ep){var s=H_(e,t,n,r);if(s===null)im(e,t,r,Pp,n),rb(e,r);else if(q3(s,e,t,n,r))r.stopPropagation();else if(rb(e,r),t&4&&-1<K3.indexOf(e)){for(;s!==null;){var i=mc(s);if(i!==null&&BC(i),i=H_(e,t,n,r),i===null&&im(e,t,r,Pp,n),i===s)break;s=i}s!==null&&r.stopPropagation()}else im(e,t,r,null,n)}}var Pp=null;function H_(e,t,n,r){if(Pp=null,e=d0(r),e=qo(e),e!==null)if(t=pa(e),t===null)e=null;else if(n=t.tag,n===13){if(e=IC(t),e!==null)return e;e=null}else if(n===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Pp=e,null}function WC(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(R3()){case p0:return 1;case FC:return 4;case bp:case B3:return 16;case LC:return 536870912;default:return 16}default:return 16}}var ji=null,_0=null,sp=null;function GC(){if(sp)return sp;var e,t=_0,n=t.length,r,s="value"in ji?ji.value:ji.textContent,i=s.length;for(e=0;e<n&&t[e]===s[e];e++);var o=n-e;for(r=1;r<=o&&t[n-r]===s[i-r];r++);return sp=s.slice(e,1<r?1-r:void 0)}function ip(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function Ed(){return!0}function ib(){return!1}function Xr(e){function t(n,r,s,i,o){this._reactName=n,this._targetInst=s,this.type=r,this.nativeEvent=i,this.target=o,this.currentTarget=null;for(var a in e)e.hasOwnProperty(a)&&(n=e[a],this[a]=n?n(i):i[a]);return this.isDefaultPrevented=(i.defaultPrevented!=null?i.defaultPrevented:i.returnValue===!1)?Ed:ib,this.isPropagationStopped=ib,this}return vn(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=Ed)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=Ed)},persist:function(){},isPersistent:Ed}),t}var Ml={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},g0=Xr(Ml),hc=vn({},Ml,{view:0,detail:0}),J3=Xr(hc),Xh,Yh,nu,pf=vn({},hc,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:y0,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==nu&&(nu&&e.type==="mousemove"?(Xh=e.screenX-nu.screenX,Yh=e.screenY-nu.screenY):Yh=Xh=0,nu=e),Xh)},movementY:function(e){return"movementY"in e?e.movementY:Yh}}),ob=Xr(pf),Z3=vn({},pf,{dataTransfer:0}),eL=Xr(Z3),tL=vn({},hc,{relatedTarget:0}),Jh=Xr(tL),nL=vn({},Ml,{animationName:0,elapsedTime:0,pseudoElement:0}),rL=Xr(nL),sL=vn({},Ml,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),iL=Xr(sL),oL=vn({},Ml,{data:0}),ab=Xr(oL),aL={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},lL={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},uL={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function cL(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=uL[e])?!!t[e]:!1}function y0(){return cL}var dL=vn({},hc,{key:function(e){if(e.key){var t=aL[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=ip(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?lL[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:y0,charCode:function(e){return e.type==="keypress"?ip(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?ip(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),pL=Xr(dL),fL=vn({},pf,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),lb=Xr(fL),hL=vn({},hc,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:y0}),mL=Xr(hL),_L=vn({},Ml,{propertyName:0,elapsedTime:0,pseudoElement:0}),gL=Xr(_L),yL=vn({},pf,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),vL=Xr(yL),wL=[9,13,27,32],v0=hi&&"CompositionEvent"in window,ku=null;hi&&"documentMode"in document&&(ku=document.documentMode);var ML=hi&&"TextEvent"in window&&!ku,HC=hi&&(!v0||ku&&8<ku&&11>=ku),ub=" ",cb=!1;function KC(e,t){switch(e){case"keyup":return wL.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function qC(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var ja=!1;function xL(e,t){switch(e){case"compositionend":return qC(t);case"keypress":return t.which!==32?null:(cb=!0,ub);case"textInput":return e=t.data,e===ub&&cb?null:e;default:return null}}function bL(e,t){if(ja)return e==="compositionend"||!v0&&KC(e,t)?(e=GC(),sp=_0=ji=null,ja=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return HC&&t.locale!=="ko"?null:t.data;default:return null}}var TL={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function db(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!TL[e.type]:t==="textarea"}function QC(e,t,n,r){PC(r),t=Sp(t,"onChange"),0<t.length&&(n=new g0("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var $u=null,Ku=null;function EL(e){ok(e,0)}function ff(e){var t=Wa(e);if(vC(t))return e}function PL(e,t){if(e==="change")return t}var XC=!1;if(hi){var Zh;if(hi){var em="oninput"in document;if(!em){var pb=document.createElement("div");pb.setAttribute("oninput","return;"),em=typeof pb.oninput=="function"}Zh=em}else Zh=!1;XC=Zh&&(!document.documentMode||9<document.documentMode)}function fb(){$u&&($u.detachEvent("onpropertychange",YC),Ku=$u=null)}function YC(e){if(e.propertyName==="value"&&ff(Ku)){var t=[];QC(t,Ku,e,d0(e)),$C(EL,t)}}function SL(e,t,n){e==="focusin"?(fb(),$u=t,Ku=n,$u.attachEvent("onpropertychange",YC)):e==="focusout"&&fb()}function CL(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return ff(Ku)}function kL(e,t){if(e==="click")return ff(t)}function $L(e,t){if(e==="input"||e==="change")return ff(t)}function IL(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var Ls=typeof Object.is=="function"?Object.is:IL;function qu(e,t){if(Ls(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var s=n[r];if(!C_.call(t,s)||!Ls(e[s],t[s]))return!1}return!0}function hb(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function mb(e,t){var n=hb(e);e=0;for(var r;n;){if(n.nodeType===3){if(r=e+n.textContent.length,e<=t&&r>=t)return{node:n,offset:t-e};e=r}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=hb(n)}}function JC(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?JC(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function ZC(){for(var e=window,t=wp();t instanceof e.HTMLIFrameElement;){try{var n=typeof t.contentWindow.location.href=="string"}catch{n=!1}if(n)e=t.contentWindow;else break;t=wp(e.document)}return t}function w0(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}function AL(e){var t=ZC(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&JC(n.ownerDocument.documentElement,n)){if(r!==null&&w0(n)){if(t=r.start,e=r.end,e===void 0&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if(e=(t=n.ownerDocument||document)&&t.defaultView||window,e.getSelection){e=e.getSelection();var s=n.textContent.length,i=Math.min(r.start,s);r=r.end===void 0?i:Math.min(r.end,s),!e.extend&&i>r&&(s=r,r=i,i=s),s=mb(n,i);var o=mb(n,r);s&&o&&(e.rangeCount!==1||e.anchorNode!==s.node||e.anchorOffset!==s.offset||e.focusNode!==o.node||e.focusOffset!==o.offset)&&(t=t.createRange(),t.setStart(s.node,s.offset),e.removeAllRanges(),i>r?(e.addRange(t),e.extend(o.node,o.offset)):(t.setEnd(o.node,o.offset),e.addRange(t)))}}for(t=[],e=n;e=e.parentNode;)e.nodeType===1&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<t.length;n++)e=t[n],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var DL=hi&&"documentMode"in document&&11>=document.documentMode,Va=null,K_=null,Iu=null,q_=!1;function _b(e,t,n){var r=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;q_||Va==null||Va!==wp(r)||(r=Va,"selectionStart"in r&&w0(r)?r={start:r.selectionStart,end:r.selectionEnd}:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection(),r={anchorNode:r.anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset}),Iu&&qu(Iu,r)||(Iu=r,r=Sp(K_,"onSelect"),0<r.length&&(t=new g0("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=Va)))}function Pd(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var Ua={animationend:Pd("Animation","AnimationEnd"),animationiteration:Pd("Animation","AnimationIteration"),animationstart:Pd("Animation","AnimationStart"),transitionend:Pd("Transition","TransitionEnd")},tm={},ek={};hi&&(ek=document.createElement("div").style,"AnimationEvent"in window||(delete Ua.animationend.animation,delete Ua.animationiteration.animation,delete Ua.animationstart.animation),"TransitionEvent"in window||delete Ua.transitionend.transition);function hf(e){if(tm[e])return tm[e];if(!Ua[e])return e;var t=Ua[e],n;for(n in t)if(t.hasOwnProperty(n)&&n in ek)return tm[e]=t[n];return e}var tk=hf("animationend"),nk=hf("animationiteration"),rk=hf("animationstart"),sk=hf("transitionend"),ik=new Map,gb="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function so(e,t){ik.set(e,t),da(t,[e])}for(var nm=0;nm<gb.length;nm++){var rm=gb[nm],OL=rm.toLowerCase(),FL=rm[0].toUpperCase()+rm.slice(1);so(OL,"on"+FL)}so(tk,"onAnimationEnd");so(nk,"onAnimationIteration");so(rk,"onAnimationStart");so("dblclick","onDoubleClick");so("focusin","onFocus");so("focusout","onBlur");so(sk,"onTransitionEnd");ul("onMouseEnter",["mouseout","mouseover"]);ul("onMouseLeave",["mouseout","mouseover"]);ul("onPointerEnter",["pointerout","pointerover"]);ul("onPointerLeave",["pointerout","pointerover"]);da("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));da("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));da("onBeforeInput",["compositionend","keypress","textInput","paste"]);da("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));da("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));da("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Mu="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),LL=new Set("cancel close invalid load scroll toggle".split(" ").concat(Mu));function yb(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,O3(r,t,void 0,e),e.currentTarget=null}function ok(e,t){t=(t&4)!==0;for(var n=0;n<e.length;n++){var r=e[n],s=r.event;r=r.listeners;e:{var i=void 0;if(t)for(var o=r.length-1;0<=o;o--){var a=r[o],l=a.instance,u=a.currentTarget;if(a=a.listener,l!==i&&s.isPropagationStopped())break e;yb(s,a,u),i=l}else for(o=0;o<r.length;o++){if(a=r[o],l=a.instance,u=a.currentTarget,a=a.listener,l!==i&&s.isPropagationStopped())break e;yb(s,a,u),i=l}}}if(xp)throw e=U_,xp=!1,U_=null,e}function on(e,t){var n=t[Z_];n===void 0&&(n=t[Z_]=new Set);var r=e+"__bubble";n.has(r)||(ak(t,e,2,!1),n.add(r))}function sm(e,t,n){var r=0;t&&(r|=4),ak(n,e,r,t)}var Sd="_reactListening"+Math.random().toString(36).slice(2);function Qu(e){if(!e[Sd]){e[Sd]=!0,hC.forEach(function(n){n!=="selectionchange"&&(LL.has(n)||sm(n,!1,e),sm(n,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[Sd]||(t[Sd]=!0,sm("selectionchange",!1,t))}}function ak(e,t,n,r){switch(WC(t)){case 1:var s=X3;break;case 4:s=Y3;break;default:s=m0}n=s.bind(null,t,n,e),s=void 0,!V_||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(s=!0),r?s!==void 0?e.addEventListener(t,n,{capture:!0,passive:s}):e.addEventListener(t,n,!0):s!==void 0?e.addEventListener(t,n,{passive:s}):e.addEventListener(t,n,!1)}function im(e,t,n,r,s){var i=r;if(!(t&1)&&!(t&2)&&r!==null)e:for(;;){if(r===null)return;var o=r.tag;if(o===3||o===4){var a=r.stateNode.containerInfo;if(a===s||a.nodeType===8&&a.parentNode===s)break;if(o===4)for(o=r.return;o!==null;){var l=o.tag;if((l===3||l===4)&&(l=o.stateNode.containerInfo,l===s||l.nodeType===8&&l.parentNode===s))return;o=o.return}for(;a!==null;){if(o=qo(a),o===null)return;if(l=o.tag,l===5||l===6){r=i=o;continue e}a=a.parentNode}}r=r.return}$C(function(){var u=i,p=d0(n),c=[];e:{var d=ik.get(e);if(d!==void 0){var f=g0,m=e;switch(e){case"keypress":if(ip(n)===0)break e;case"keydown":case"keyup":f=pL;break;case"focusin":m="focus",f=Jh;break;case"focusout":m="blur",f=Jh;break;case"beforeblur":case"afterblur":f=Jh;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":f=ob;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":f=eL;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":f=mL;break;case tk:case nk:case rk:f=rL;break;case sk:f=gL;break;case"scroll":f=J3;break;case"wheel":f=vL;break;case"copy":case"cut":case"paste":f=iL;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":f=lb}var y=(t&4)!==0,C=!y&&e==="scroll",_=y?d!==null?d+"Capture":null:d;y=[];for(var h=u,w;h!==null;){w=h;var M=w.stateNode;if(w.tag===5&&M!==null&&(w=M,_!==null&&(M=Uu(h,_),M!=null&&y.push(Xu(h,M,w)))),C)break;h=h.return}0<y.length&&(d=new f(d,m,null,n,p),c.push({event:d,listeners:y}))}}if(!(t&7)){e:{if(d=e==="mouseover"||e==="pointerover",f=e==="mouseout"||e==="pointerout",d&&n!==N_&&(m=n.relatedTarget||n.fromElement)&&(qo(m)||m[mi]))break e;if((f||d)&&(d=p.window===p?p:(d=p.ownerDocument)?d.defaultView||d.parentWindow:window,f?(m=n.relatedTarget||n.toElement,f=u,m=m?qo(m):null,m!==null&&(C=pa(m),m!==C||m.tag!==5&&m.tag!==6)&&(m=null)):(f=null,m=u),f!==m)){if(y=ob,M="onMouseLeave",_="onMouseEnter",h="mouse",(e==="pointerout"||e==="pointerover")&&(y=lb,M="onPointerLeave",_="onPointerEnter",h="pointer"),C=f==null?d:Wa(f),w=m==null?d:Wa(m),d=new y(M,h+"leave",f,n,p),d.target=C,d.relatedTarget=w,M=null,qo(p)===u&&(y=new y(_,h+"enter",m,n,p),y.target=w,y.relatedTarget=C,M=y),C=M,f&&m)t:{for(y=f,_=m,h=0,w=y;w;w=Oa(w))h++;for(w=0,M=_;M;M=Oa(M))w++;for(;0<h-w;)y=Oa(y),h--;for(;0<w-h;)_=Oa(_),w--;for(;h--;){if(y===_||_!==null&&y===_.alternate)break t;y=Oa(y),_=Oa(_)}y=null}else y=null;f!==null&&vb(c,d,f,y,!1),m!==null&&C!==null&&vb(c,C,m,y,!0)}}e:{if(d=u?Wa(u):window,f=d.nodeName&&d.nodeName.toLowerCase(),f==="select"||f==="input"&&d.type==="file")var x=PL;else if(db(d))if(XC)x=$L;else{x=CL;var b=SL}else(f=d.nodeName)&&f.toLowerCase()==="input"&&(d.type==="checkbox"||d.type==="radio")&&(x=kL);if(x&&(x=x(e,u))){QC(c,x,n,p);break e}b&&b(e,d,u),e==="focusout"&&(b=d._wrapperState)&&b.controlled&&d.type==="number"&&F_(d,"number",d.value)}switch(b=u?Wa(u):window,e){case"focusin":(db(b)||b.contentEditable==="true")&&(Va=b,K_=u,Iu=null);break;case"focusout":Iu=K_=Va=null;break;case"mousedown":q_=!0;break;case"contextmenu":case"mouseup":case"dragend":q_=!1,_b(c,n,p);break;case"selectionchange":if(DL)break;case"keydown":case"keyup":_b(c,n,p)}var T;if(v0)e:{switch(e){case"compositionstart":var S="onCompositionStart";break e;case"compositionend":S="onCompositionEnd";break e;case"compositionupdate":S="onCompositionUpdate";break e}S=void 0}else ja?KC(e,n)&&(S="onCompositionEnd"):e==="keydown"&&n.keyCode===229&&(S="onCompositionStart");S&&(HC&&n.locale!=="ko"&&(ja||S!=="onCompositionStart"?S==="onCompositionEnd"&&ja&&(T=GC()):(ji=p,_0="value"in ji?ji.value:ji.textContent,ja=!0)),b=Sp(u,S),0<b.length&&(S=new ab(S,e,null,n,p),c.push({event:S,listeners:b}),T?S.data=T:(T=qC(n),T!==null&&(S.data=T)))),(T=ML?xL(e,n):bL(e,n))&&(u=Sp(u,"onBeforeInput"),0<u.length&&(p=new ab("onBeforeInput","beforeinput",null,n,p),c.push({event:p,listeners:u}),p.data=T))}ok(c,t)})}function Xu(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Sp(e,t){for(var n=t+"Capture",r=[];e!==null;){var s=e,i=s.stateNode;s.tag===5&&i!==null&&(s=i,i=Uu(e,n),i!=null&&r.unshift(Xu(e,i,s)),i=Uu(e,t),i!=null&&r.push(Xu(e,i,s))),e=e.return}return r}function Oa(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function vb(e,t,n,r,s){for(var i=t._reactName,o=[];n!==null&&n!==r;){var a=n,l=a.alternate,u=a.stateNode;if(l!==null&&l===r)break;a.tag===5&&u!==null&&(a=u,s?(l=Uu(n,i),l!=null&&o.unshift(Xu(n,l,a))):s||(l=Uu(n,i),l!=null&&o.push(Xu(n,l,a)))),n=n.return}o.length!==0&&e.push({event:t,listeners:o})}var zL=/\r\n?/g,RL=/\u0000|\uFFFD/g;function wb(e){return(typeof e=="string"?e:""+e).replace(zL,`
`).replace(RL,"")}function Cd(e,t,n){if(t=wb(t),wb(e)!==t&&n)throw Error(He(425))}function Cp(){}var Q_=null,X_=null;function Y_(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var J_=typeof setTimeout=="function"?setTimeout:void 0,BL=typeof clearTimeout=="function"?clearTimeout:void 0,Mb=typeof Promise=="function"?Promise:void 0,NL=typeof queueMicrotask=="function"?queueMicrotask:typeof Mb<"u"?function(e){return Mb.resolve(null).then(e).catch(jL)}:J_;function jL(e){setTimeout(function(){throw e})}function om(e,t){var n=t,r=0;do{var s=n.nextSibling;if(e.removeChild(n),s&&s.nodeType===8)if(n=s.data,n==="/$"){if(r===0){e.removeChild(s),Hu(t);return}r--}else n!=="$"&&n!=="$?"&&n!=="$!"||r++;n=s}while(n);Hu(t)}function Ki(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?")break;if(t==="/$")return null}}return e}function xb(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="$"||n==="$!"||n==="$?"){if(t===0)return e;t--}else n==="/$"&&t++}e=e.previousSibling}return null}var xl=Math.random().toString(36).slice(2),Hs="__reactFiber$"+xl,Yu="__reactProps$"+xl,mi="__reactContainer$"+xl,Z_="__reactEvents$"+xl,VL="__reactListeners$"+xl,UL="__reactHandles$"+xl;function qo(e){var t=e[Hs];if(t)return t;for(var n=e.parentNode;n;){if(t=n[mi]||n[Hs]){if(n=t.alternate,t.child!==null||n!==null&&n.child!==null)for(e=xb(e);e!==null;){if(n=e[Hs])return n;e=xb(e)}return t}e=n,n=e.parentNode}return null}function mc(e){return e=e[Hs]||e[mi],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function Wa(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(He(33))}function mf(e){return e[Yu]||null}var eg=[],Ga=-1;function io(e){return{current:e}}function ln(e){0>Ga||(e.current=eg[Ga],eg[Ga]=null,Ga--)}function sn(e,t){Ga++,eg[Ga]=e.current,e.current=t}var eo={},mr=io(eo),Cr=io(!1),ra=eo;function cl(e,t){var n=e.type.contextTypes;if(!n)return eo;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var s={},i;for(i in n)s[i]=t[i];return r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=s),s}function kr(e){return e=e.childContextTypes,e!=null}function kp(){ln(Cr),ln(mr)}function bb(e,t,n){if(mr.current!==eo)throw Error(He(168));sn(mr,t),sn(Cr,n)}function lk(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,typeof r.getChildContext!="function")return n;r=r.getChildContext();for(var s in r)if(!(s in t))throw Error(He(108,S3(e)||"Unknown",s));return vn({},n,r)}function $p(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||eo,ra=mr.current,sn(mr,e),sn(Cr,Cr.current),!0}function Tb(e,t,n){var r=e.stateNode;if(!r)throw Error(He(169));n?(e=lk(e,t,ra),r.__reactInternalMemoizedMergedChildContext=e,ln(Cr),ln(mr),sn(mr,e)):ln(Cr),sn(Cr,n)}var ii=null,_f=!1,am=!1;function uk(e){ii===null?ii=[e]:ii.push(e)}function WL(e){_f=!0,uk(e)}function oo(){if(!am&&ii!==null){am=!0;var e=0,t=Qt;try{var n=ii;for(Qt=1;e<n.length;e++){var r=n[e];do r=r(!0);while(r!==null)}ii=null,_f=!1}catch(s){throw ii!==null&&(ii=ii.slice(e+1)),OC(p0,oo),s}finally{Qt=t,am=!1}}return null}var Ha=[],Ka=0,Ip=null,Ap=0,os=[],as=0,sa=null,ai=1,li="";function No(e,t){Ha[Ka++]=Ap,Ha[Ka++]=Ip,Ip=e,Ap=t}function ck(e,t,n){os[as++]=ai,os[as++]=li,os[as++]=sa,sa=e;var r=ai;e=li;var s=32-Ds(r)-1;r&=~(1<<s),n+=1;var i=32-Ds(t)+s;if(30<i){var o=s-s%5;i=(r&(1<<o)-1).toString(32),r>>=o,s-=o,ai=1<<32-Ds(t)+s|n<<s|r,li=i+e}else ai=1<<i|n<<s|r,li=e}function M0(e){e.return!==null&&(No(e,1),ck(e,1,0))}function x0(e){for(;e===Ip;)Ip=Ha[--Ka],Ha[Ka]=null,Ap=Ha[--Ka],Ha[Ka]=null;for(;e===sa;)sa=os[--as],os[as]=null,li=os[--as],os[as]=null,ai=os[--as],os[as]=null}var Gr=null,Wr=null,dn=!1,$s=null;function dk(e,t){var n=us(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,t=e.deletions,t===null?(e.deletions=[n],e.flags|=16):t.push(n)}function Eb(e,t){switch(e.tag){case 5:var n=e.type;return t=t.nodeType!==1||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t,t!==null?(e.stateNode=t,Gr=e,Wr=Ki(t.firstChild),!0):!1;case 6:return t=e.pendingProps===""||t.nodeType!==3?null:t,t!==null?(e.stateNode=t,Gr=e,Wr=null,!0):!1;case 13:return t=t.nodeType!==8?null:t,t!==null?(n=sa!==null?{id:ai,overflow:li}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},n=us(18,null,null,0),n.stateNode=t,n.return=e,e.child=n,Gr=e,Wr=null,!0):!1;default:return!1}}function tg(e){return(e.mode&1)!==0&&(e.flags&128)===0}function ng(e){if(dn){var t=Wr;if(t){var n=t;if(!Eb(e,t)){if(tg(e))throw Error(He(418));t=Ki(n.nextSibling);var r=Gr;t&&Eb(e,t)?dk(r,n):(e.flags=e.flags&-4097|2,dn=!1,Gr=e)}}else{if(tg(e))throw Error(He(418));e.flags=e.flags&-4097|2,dn=!1,Gr=e}}}function Pb(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;Gr=e}function kd(e){if(e!==Gr)return!1;if(!dn)return Pb(e),dn=!0,!1;var t;if((t=e.tag!==3)&&!(t=e.tag!==5)&&(t=e.type,t=t!=="head"&&t!=="body"&&!Y_(e.type,e.memoizedProps)),t&&(t=Wr)){if(tg(e))throw pk(),Error(He(418));for(;t;)dk(e,t),t=Ki(t.nextSibling)}if(Pb(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(He(317));e:{for(e=e.nextSibling,t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="/$"){if(t===0){Wr=Ki(e.nextSibling);break e}t--}else n!=="$"&&n!=="$!"&&n!=="$?"||t++}e=e.nextSibling}Wr=null}}else Wr=Gr?Ki(e.stateNode.nextSibling):null;return!0}function pk(){for(var e=Wr;e;)e=Ki(e.nextSibling)}function dl(){Wr=Gr=null,dn=!1}function b0(e){$s===null?$s=[e]:$s.push(e)}var GL=vi.ReactCurrentBatchConfig;function ru(e,t,n){if(e=n.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(He(309));var r=n.stateNode}if(!r)throw Error(He(147,e));var s=r,i=""+e;return t!==null&&t.ref!==null&&typeof t.ref=="function"&&t.ref._stringRef===i?t.ref:(t=function(o){var a=s.refs;o===null?delete a[i]:a[i]=o},t._stringRef=i,t)}if(typeof e!="string")throw Error(He(284));if(!n._owner)throw Error(He(290,e))}return e}function $d(e,t){throw e=Object.prototype.toString.call(t),Error(He(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function Sb(e){var t=e._init;return t(e._payload)}function fk(e){function t(_,h){if(e){var w=_.deletions;w===null?(_.deletions=[h],_.flags|=16):w.push(h)}}function n(_,h){if(!e)return null;for(;h!==null;)t(_,h),h=h.sibling;return null}function r(_,h){for(_=new Map;h!==null;)h.key!==null?_.set(h.key,h):_.set(h.index,h),h=h.sibling;return _}function s(_,h){return _=Yi(_,h),_.index=0,_.sibling=null,_}function i(_,h,w){return _.index=w,e?(w=_.alternate,w!==null?(w=w.index,w<h?(_.flags|=2,h):w):(_.flags|=2,h)):(_.flags|=1048576,h)}function o(_){return e&&_.alternate===null&&(_.flags|=2),_}function a(_,h,w,M){return h===null||h.tag!==6?(h=hm(w,_.mode,M),h.return=_,h):(h=s(h,w),h.return=_,h)}function l(_,h,w,M){var x=w.type;return x===Na?p(_,h,w.props.children,M,w.key):h!==null&&(h.elementType===x||typeof x=="object"&&x!==null&&x.$$typeof===Li&&Sb(x)===h.type)?(M=s(h,w.props),M.ref=ru(_,h,w),M.return=_,M):(M=pp(w.type,w.key,w.props,null,_.mode,M),M.ref=ru(_,h,w),M.return=_,M)}function u(_,h,w,M){return h===null||h.tag!==4||h.stateNode.containerInfo!==w.containerInfo||h.stateNode.implementation!==w.implementation?(h=mm(w,_.mode,M),h.return=_,h):(h=s(h,w.children||[]),h.return=_,h)}function p(_,h,w,M,x){return h===null||h.tag!==7?(h=ea(w,_.mode,M,x),h.return=_,h):(h=s(h,w),h.return=_,h)}function c(_,h,w){if(typeof h=="string"&&h!==""||typeof h=="number")return h=hm(""+h,_.mode,w),h.return=_,h;if(typeof h=="object"&&h!==null){switch(h.$$typeof){case vd:return w=pp(h.type,h.key,h.props,null,_.mode,w),w.ref=ru(_,null,h),w.return=_,w;case Ba:return h=mm(h,_.mode,w),h.return=_,h;case Li:var M=h._init;return c(_,M(h._payload),w)}if(vu(h)||Jl(h))return h=ea(h,_.mode,w,null),h.return=_,h;$d(_,h)}return null}function d(_,h,w,M){var x=h!==null?h.key:null;if(typeof w=="string"&&w!==""||typeof w=="number")return x!==null?null:a(_,h,""+w,M);if(typeof w=="object"&&w!==null){switch(w.$$typeof){case vd:return w.key===x?l(_,h,w,M):null;case Ba:return w.key===x?u(_,h,w,M):null;case Li:return x=w._init,d(_,h,x(w._payload),M)}if(vu(w)||Jl(w))return x!==null?null:p(_,h,w,M,null);$d(_,w)}return null}function f(_,h,w,M,x){if(typeof M=="string"&&M!==""||typeof M=="number")return _=_.get(w)||null,a(h,_,""+M,x);if(typeof M=="object"&&M!==null){switch(M.$$typeof){case vd:return _=_.get(M.key===null?w:M.key)||null,l(h,_,M,x);case Ba:return _=_.get(M.key===null?w:M.key)||null,u(h,_,M,x);case Li:var b=M._init;return f(_,h,w,b(M._payload),x)}if(vu(M)||Jl(M))return _=_.get(w)||null,p(h,_,M,x,null);$d(h,M)}return null}function m(_,h,w,M){for(var x=null,b=null,T=h,S=h=0,$=null;T!==null&&S<w.length;S++){T.index>S?($=T,T=null):$=T.sibling;var O=d(_,T,w[S],M);if(O===null){T===null&&(T=$);break}e&&T&&O.alternate===null&&t(_,T),h=i(O,h,S),b===null?x=O:b.sibling=O,b=O,T=$}if(S===w.length)return n(_,T),dn&&No(_,S),x;if(T===null){for(;S<w.length;S++)T=c(_,w[S],M),T!==null&&(h=i(T,h,S),b===null?x=T:b.sibling=T,b=T);return dn&&No(_,S),x}for(T=r(_,T);S<w.length;S++)$=f(T,_,S,w[S],M),$!==null&&(e&&$.alternate!==null&&T.delete($.key===null?S:$.key),h=i($,h,S),b===null?x=$:b.sibling=$,b=$);return e&&T.forEach(function(G){return t(_,G)}),dn&&No(_,S),x}function y(_,h,w,M){var x=Jl(w);if(typeof x!="function")throw Error(He(150));if(w=x.call(w),w==null)throw Error(He(151));for(var b=x=null,T=h,S=h=0,$=null,O=w.next();T!==null&&!O.done;S++,O=w.next()){T.index>S?($=T,T=null):$=T.sibling;var G=d(_,T,O.value,M);if(G===null){T===null&&(T=$);break}e&&T&&G.alternate===null&&t(_,T),h=i(G,h,S),b===null?x=G:b.sibling=G,b=G,T=$}if(O.done)return n(_,T),dn&&No(_,S),x;if(T===null){for(;!O.done;S++,O=w.next())O=c(_,O.value,M),O!==null&&(h=i(O,h,S),b===null?x=O:b.sibling=O,b=O);return dn&&No(_,S),x}for(T=r(_,T);!O.done;S++,O=w.next())O=f(T,_,S,O.value,M),O!==null&&(e&&O.alternate!==null&&T.delete(O.key===null?S:O.key),h=i(O,h,S),b===null?x=O:b.sibling=O,b=O);return e&&T.forEach(function(H){return t(_,H)}),dn&&No(_,S),x}function C(_,h,w,M){if(typeof w=="object"&&w!==null&&w.type===Na&&w.key===null&&(w=w.props.children),typeof w=="object"&&w!==null){switch(w.$$typeof){case vd:e:{for(var x=w.key,b=h;b!==null;){if(b.key===x){if(x=w.type,x===Na){if(b.tag===7){n(_,b.sibling),h=s(b,w.props.children),h.return=_,_=h;break e}}else if(b.elementType===x||typeof x=="object"&&x!==null&&x.$$typeof===Li&&Sb(x)===b.type){n(_,b.sibling),h=s(b,w.props),h.ref=ru(_,b,w),h.return=_,_=h;break e}n(_,b);break}else t(_,b);b=b.sibling}w.type===Na?(h=ea(w.props.children,_.mode,M,w.key),h.return=_,_=h):(M=pp(w.type,w.key,w.props,null,_.mode,M),M.ref=ru(_,h,w),M.return=_,_=M)}return o(_);case Ba:e:{for(b=w.key;h!==null;){if(h.key===b)if(h.tag===4&&h.stateNode.containerInfo===w.containerInfo&&h.stateNode.implementation===w.implementation){n(_,h.sibling),h=s(h,w.children||[]),h.return=_,_=h;break e}else{n(_,h);break}else t(_,h);h=h.sibling}h=mm(w,_.mode,M),h.return=_,_=h}return o(_);case Li:return b=w._init,C(_,h,b(w._payload),M)}if(vu(w))return m(_,h,w,M);if(Jl(w))return y(_,h,w,M);$d(_,w)}return typeof w=="string"&&w!==""||typeof w=="number"?(w=""+w,h!==null&&h.tag===6?(n(_,h.sibling),h=s(h,w),h.return=_,_=h):(n(_,h),h=hm(w,_.mode,M),h.return=_,_=h),o(_)):n(_,h)}return C}var pl=fk(!0),hk=fk(!1),Dp=io(null),Op=null,qa=null,T0=null;function E0(){T0=qa=Op=null}function P0(e){var t=Dp.current;ln(Dp),e._currentValue=t}function rg(e,t,n){for(;e!==null;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,r!==null&&(r.childLanes|=t)):r!==null&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function al(e,t){Op=e,T0=qa=null,e=e.dependencies,e!==null&&e.firstContext!==null&&(e.lanes&t&&(Sr=!0),e.firstContext=null)}function ps(e){var t=e._currentValue;if(T0!==e)if(e={context:e,memoizedValue:t,next:null},qa===null){if(Op===null)throw Error(He(308));qa=e,Op.dependencies={lanes:0,firstContext:e}}else qa=qa.next=e;return t}var Qo=null;function S0(e){Qo===null?Qo=[e]:Qo.push(e)}function mk(e,t,n,r){var s=t.interleaved;return s===null?(n.next=n,S0(t)):(n.next=s.next,s.next=n),t.interleaved=n,_i(e,r)}function _i(e,t){e.lanes|=t;var n=e.alternate;for(n!==null&&(n.lanes|=t),n=e,e=e.return;e!==null;)e.childLanes|=t,n=e.alternate,n!==null&&(n.childLanes|=t),n=e,e=e.return;return n.tag===3?n.stateNode:null}var zi=!1;function C0(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function _k(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function ci(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function qi(e,t,n){var r=e.updateQueue;if(r===null)return null;if(r=r.shared,Nt&2){var s=r.pending;return s===null?t.next=t:(t.next=s.next,s.next=t),r.pending=t,_i(e,n)}return s=r.interleaved,s===null?(t.next=t,S0(r)):(t.next=s.next,s.next=t),r.interleaved=t,_i(e,n)}function op(e,t,n){if(t=t.updateQueue,t!==null&&(t=t.shared,(n&4194240)!==0)){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,f0(e,n)}}function Cb(e,t){var n=e.updateQueue,r=e.alternate;if(r!==null&&(r=r.updateQueue,n===r)){var s=null,i=null;if(n=n.firstBaseUpdate,n!==null){do{var o={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};i===null?s=i=o:i=i.next=o,n=n.next}while(n!==null);i===null?s=i=t:i=i.next=t}else s=i=t;n={baseState:r.baseState,firstBaseUpdate:s,lastBaseUpdate:i,shared:r.shared,effects:r.effects},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Fp(e,t,n,r){var s=e.updateQueue;zi=!1;var i=s.firstBaseUpdate,o=s.lastBaseUpdate,a=s.shared.pending;if(a!==null){s.shared.pending=null;var l=a,u=l.next;l.next=null,o===null?i=u:o.next=u,o=l;var p=e.alternate;p!==null&&(p=p.updateQueue,a=p.lastBaseUpdate,a!==o&&(a===null?p.firstBaseUpdate=u:a.next=u,p.lastBaseUpdate=l))}if(i!==null){var c=s.baseState;o=0,p=u=l=null,a=i;do{var d=a.lane,f=a.eventTime;if((r&d)===d){p!==null&&(p=p.next={eventTime:f,lane:0,tag:a.tag,payload:a.payload,callback:a.callback,next:null});e:{var m=e,y=a;switch(d=t,f=n,y.tag){case 1:if(m=y.payload,typeof m=="function"){c=m.call(f,c,d);break e}c=m;break e;case 3:m.flags=m.flags&-65537|128;case 0:if(m=y.payload,d=typeof m=="function"?m.call(f,c,d):m,d==null)break e;c=vn({},c,d);break e;case 2:zi=!0}}a.callback!==null&&a.lane!==0&&(e.flags|=64,d=s.effects,d===null?s.effects=[a]:d.push(a))}else f={eventTime:f,lane:d,tag:a.tag,payload:a.payload,callback:a.callback,next:null},p===null?(u=p=f,l=c):p=p.next=f,o|=d;if(a=a.next,a===null){if(a=s.shared.pending,a===null)break;d=a,a=d.next,d.next=null,s.lastBaseUpdate=d,s.shared.pending=null}}while(!0);if(p===null&&(l=c),s.baseState=l,s.firstBaseUpdate=u,s.lastBaseUpdate=p,t=s.shared.interleaved,t!==null){s=t;do o|=s.lane,s=s.next;while(s!==t)}else i===null&&(s.shared.lanes=0);oa|=o,e.lanes=o,e.memoizedState=c}}function kb(e,t,n){if(e=t.effects,t.effects=null,e!==null)for(t=0;t<e.length;t++){var r=e[t],s=r.callback;if(s!==null){if(r.callback=null,r=n,typeof s!="function")throw Error(He(191,s));s.call(r)}}}var _c={},qs=io(_c),Ju=io(_c),Zu=io(_c);function Xo(e){if(e===_c)throw Error(He(174));return e}function k0(e,t){switch(sn(Zu,t),sn(Ju,e),sn(qs,_c),e=t.nodeType,e){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:z_(null,"");break;default:e=e===8?t.parentNode:t,t=e.namespaceURI||null,e=e.tagName,t=z_(t,e)}ln(qs),sn(qs,t)}function fl(){ln(qs),ln(Ju),ln(Zu)}function gk(e){Xo(Zu.current);var t=Xo(qs.current),n=z_(t,e.type);t!==n&&(sn(Ju,e),sn(qs,n))}function $0(e){Ju.current===e&&(ln(qs),ln(Ju))}var mn=io(0);function Lp(e){for(var t=e;t!==null;){if(t.tag===13){var n=t.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return t}else if(t.tag===19&&t.memoizedProps.revealOrder!==void 0){if(t.flags&128)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var lm=[];function I0(){for(var e=0;e<lm.length;e++)lm[e]._workInProgressVersionPrimary=null;lm.length=0}var ap=vi.ReactCurrentDispatcher,um=vi.ReactCurrentBatchConfig,ia=0,yn=null,Gn=null,Zn=null,zp=!1,Au=!1,ec=0,HL=0;function cr(){throw Error(He(321))}function A0(e,t){if(t===null)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Ls(e[n],t[n]))return!1;return!0}function D0(e,t,n,r,s,i){if(ia=i,yn=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,ap.current=e===null||e.memoizedState===null?XL:YL,e=n(r,s),Au){i=0;do{if(Au=!1,ec=0,25<=i)throw Error(He(301));i+=1,Zn=Gn=null,t.updateQueue=null,ap.current=JL,e=n(r,s)}while(Au)}if(ap.current=Rp,t=Gn!==null&&Gn.next!==null,ia=0,Zn=Gn=yn=null,zp=!1,t)throw Error(He(300));return e}function O0(){var e=ec!==0;return ec=0,e}function Gs(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Zn===null?yn.memoizedState=Zn=e:Zn=Zn.next=e,Zn}function fs(){if(Gn===null){var e=yn.alternate;e=e!==null?e.memoizedState:null}else e=Gn.next;var t=Zn===null?yn.memoizedState:Zn.next;if(t!==null)Zn=t,Gn=e;else{if(e===null)throw Error(He(310));Gn=e,e={memoizedState:Gn.memoizedState,baseState:Gn.baseState,baseQueue:Gn.baseQueue,queue:Gn.queue,next:null},Zn===null?yn.memoizedState=Zn=e:Zn=Zn.next=e}return Zn}function tc(e,t){return typeof t=="function"?t(e):t}function cm(e){var t=fs(),n=t.queue;if(n===null)throw Error(He(311));n.lastRenderedReducer=e;var r=Gn,s=r.baseQueue,i=n.pending;if(i!==null){if(s!==null){var o=s.next;s.next=i.next,i.next=o}r.baseQueue=s=i,n.pending=null}if(s!==null){i=s.next,r=r.baseState;var a=o=null,l=null,u=i;do{var p=u.lane;if((ia&p)===p)l!==null&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),r=u.hasEagerState?u.eagerState:e(r,u.action);else{var c={lane:p,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};l===null?(a=l=c,o=r):l=l.next=c,yn.lanes|=p,oa|=p}u=u.next}while(u!==null&&u!==i);l===null?o=r:l.next=a,Ls(r,t.memoizedState)||(Sr=!0),t.memoizedState=r,t.baseState=o,t.baseQueue=l,n.lastRenderedState=r}if(e=n.interleaved,e!==null){s=e;do i=s.lane,yn.lanes|=i,oa|=i,s=s.next;while(s!==e)}else s===null&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function dm(e){var t=fs(),n=t.queue;if(n===null)throw Error(He(311));n.lastRenderedReducer=e;var r=n.dispatch,s=n.pending,i=t.memoizedState;if(s!==null){n.pending=null;var o=s=s.next;do i=e(i,o.action),o=o.next;while(o!==s);Ls(i,t.memoizedState)||(Sr=!0),t.memoizedState=i,t.baseQueue===null&&(t.baseState=i),n.lastRenderedState=i}return[i,r]}function yk(){}function vk(e,t){var n=yn,r=fs(),s=t(),i=!Ls(r.memoizedState,s);if(i&&(r.memoizedState=s,Sr=!0),r=r.queue,F0(xk.bind(null,n,r,e),[e]),r.getSnapshot!==t||i||Zn!==null&&Zn.memoizedState.tag&1){if(n.flags|=2048,nc(9,Mk.bind(null,n,r,s,t),void 0,null),er===null)throw Error(He(349));ia&30||wk(n,t,s)}return s}function wk(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},t=yn.updateQueue,t===null?(t={lastEffect:null,stores:null},yn.updateQueue=t,t.stores=[e]):(n=t.stores,n===null?t.stores=[e]:n.push(e))}function Mk(e,t,n,r){t.value=n,t.getSnapshot=r,bk(t)&&Tk(e)}function xk(e,t,n){return n(function(){bk(t)&&Tk(e)})}function bk(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Ls(e,n)}catch{return!0}}function Tk(e){var t=_i(e,1);t!==null&&Os(t,e,1,-1)}function $b(e){var t=Gs();return typeof e=="function"&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:tc,lastRenderedState:e},t.queue=e,e=e.dispatch=QL.bind(null,yn,e),[t.memoizedState,e]}function nc(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},t=yn.updateQueue,t===null?(t={lastEffect:null,stores:null},yn.updateQueue=t,t.lastEffect=e.next=e):(n=t.lastEffect,n===null?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e)),e}function Ek(){return fs().memoizedState}function lp(e,t,n,r){var s=Gs();yn.flags|=e,s.memoizedState=nc(1|t,n,void 0,r===void 0?null:r)}function gf(e,t,n,r){var s=fs();r=r===void 0?null:r;var i=void 0;if(Gn!==null){var o=Gn.memoizedState;if(i=o.destroy,r!==null&&A0(r,o.deps)){s.memoizedState=nc(t,n,i,r);return}}yn.flags|=e,s.memoizedState=nc(1|t,n,i,r)}function Ib(e,t){return lp(8390656,8,e,t)}function F0(e,t){return gf(2048,8,e,t)}function Pk(e,t){return gf(4,2,e,t)}function Sk(e,t){return gf(4,4,e,t)}function Ck(e,t){if(typeof t=="function")return e=e(),t(e),function(){t(null)};if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function kk(e,t,n){return n=n!=null?n.concat([e]):null,gf(4,4,Ck.bind(null,t,e),n)}function L0(){}function $k(e,t){var n=fs();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&A0(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Ik(e,t){var n=fs();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&A0(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function Ak(e,t,n){return ia&21?(Ls(n,t)||(n=zC(),yn.lanes|=n,oa|=n,e.baseState=!0),t):(e.baseState&&(e.baseState=!1,Sr=!0),e.memoizedState=n)}function KL(e,t){var n=Qt;Qt=n!==0&&4>n?n:4,e(!0);var r=um.transition;um.transition={};try{e(!1),t()}finally{Qt=n,um.transition=r}}function Dk(){return fs().memoizedState}function qL(e,t,n){var r=Xi(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},Ok(e))Fk(t,n);else if(n=mk(e,t,n,r),n!==null){var s=wr();Os(n,e,r,s),Lk(n,t,r)}}function QL(e,t,n){var r=Xi(e),s={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(Ok(e))Fk(t,s);else{var i=e.alternate;if(e.lanes===0&&(i===null||i.lanes===0)&&(i=t.lastRenderedReducer,i!==null))try{var o=t.lastRenderedState,a=i(o,n);if(s.hasEagerState=!0,s.eagerState=a,Ls(a,o)){var l=t.interleaved;l===null?(s.next=s,S0(t)):(s.next=l.next,l.next=s),t.interleaved=s;return}}catch{}finally{}n=mk(e,t,s,r),n!==null&&(s=wr(),Os(n,e,r,s),Lk(n,t,r))}}function Ok(e){var t=e.alternate;return e===yn||t!==null&&t===yn}function Fk(e,t){Au=zp=!0;var n=e.pending;n===null?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Lk(e,t,n){if(n&4194240){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,f0(e,n)}}var Rp={readContext:ps,useCallback:cr,useContext:cr,useEffect:cr,useImperativeHandle:cr,useInsertionEffect:cr,useLayoutEffect:cr,useMemo:cr,useReducer:cr,useRef:cr,useState:cr,useDebugValue:cr,useDeferredValue:cr,useTransition:cr,useMutableSource:cr,useSyncExternalStore:cr,useId:cr,unstable_isNewReconciler:!1},XL={readContext:ps,useCallback:function(e,t){return Gs().memoizedState=[e,t===void 0?null:t],e},useContext:ps,useEffect:Ib,useImperativeHandle:function(e,t,n){return n=n!=null?n.concat([e]):null,lp(4194308,4,Ck.bind(null,t,e),n)},useLayoutEffect:function(e,t){return lp(4194308,4,e,t)},useInsertionEffect:function(e,t){return lp(4,2,e,t)},useMemo:function(e,t){var n=Gs();return t=t===void 0?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=Gs();return t=n!==void 0?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=qL.bind(null,yn,e),[r.memoizedState,e]},useRef:function(e){var t=Gs();return e={current:e},t.memoizedState=e},useState:$b,useDebugValue:L0,useDeferredValue:function(e){return Gs().memoizedState=e},useTransition:function(){var e=$b(!1),t=e[0];return e=KL.bind(null,e[1]),Gs().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=yn,s=Gs();if(dn){if(n===void 0)throw Error(He(407));n=n()}else{if(n=t(),er===null)throw Error(He(349));ia&30||wk(r,t,n)}s.memoizedState=n;var i={value:n,getSnapshot:t};return s.queue=i,Ib(xk.bind(null,r,i,e),[e]),r.flags|=2048,nc(9,Mk.bind(null,r,i,n,t),void 0,null),n},useId:function(){var e=Gs(),t=er.identifierPrefix;if(dn){var n=li,r=ai;n=(r&~(1<<32-Ds(r)-1)).toString(32)+n,t=":"+t+"R"+n,n=ec++,0<n&&(t+="H"+n.toString(32)),t+=":"}else n=HL++,t=":"+t+"r"+n.toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},YL={readContext:ps,useCallback:$k,useContext:ps,useEffect:F0,useImperativeHandle:kk,useInsertionEffect:Pk,useLayoutEffect:Sk,useMemo:Ik,useReducer:cm,useRef:Ek,useState:function(){return cm(tc)},useDebugValue:L0,useDeferredValue:function(e){var t=fs();return Ak(t,Gn.memoizedState,e)},useTransition:function(){var e=cm(tc)[0],t=fs().memoizedState;return[e,t]},useMutableSource:yk,useSyncExternalStore:vk,useId:Dk,unstable_isNewReconciler:!1},JL={readContext:ps,useCallback:$k,useContext:ps,useEffect:F0,useImperativeHandle:kk,useInsertionEffect:Pk,useLayoutEffect:Sk,useMemo:Ik,useReducer:dm,useRef:Ek,useState:function(){return dm(tc)},useDebugValue:L0,useDeferredValue:function(e){var t=fs();return Gn===null?t.memoizedState=e:Ak(t,Gn.memoizedState,e)},useTransition:function(){var e=dm(tc)[0],t=fs().memoizedState;return[e,t]},useMutableSource:yk,useSyncExternalStore:vk,useId:Dk,unstable_isNewReconciler:!1};function Cs(e,t){if(e&&e.defaultProps){t=vn({},t),e=e.defaultProps;for(var n in e)t[n]===void 0&&(t[n]=e[n]);return t}return t}function sg(e,t,n,r){t=e.memoizedState,n=n(r,t),n=n==null?t:vn({},t,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var yf={isMounted:function(e){return(e=e._reactInternals)?pa(e)===e:!1},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=wr(),s=Xi(e),i=ci(r,s);i.payload=t,n!=null&&(i.callback=n),t=qi(e,i,s),t!==null&&(Os(t,e,s,r),op(t,e,s))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=wr(),s=Xi(e),i=ci(r,s);i.tag=1,i.payload=t,n!=null&&(i.callback=n),t=qi(e,i,s),t!==null&&(Os(t,e,s,r),op(t,e,s))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=wr(),r=Xi(e),s=ci(n,r);s.tag=2,t!=null&&(s.callback=t),t=qi(e,s,r),t!==null&&(Os(t,e,r,n),op(t,e,r))}};function Ab(e,t,n,r,s,i,o){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(r,i,o):t.prototype&&t.prototype.isPureReactComponent?!qu(n,r)||!qu(s,i):!0}function zk(e,t,n){var r=!1,s=eo,i=t.contextType;return typeof i=="object"&&i!==null?i=ps(i):(s=kr(t)?ra:mr.current,r=t.contextTypes,i=(r=r!=null)?cl(e,s):eo),t=new t(n,i),e.memoizedState=t.state!==null&&t.state!==void 0?t.state:null,t.updater=yf,e.stateNode=t,t._reactInternals=e,r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=s,e.__reactInternalMemoizedMaskedChildContext=i),t}function Db(e,t,n,r){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(n,r),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&yf.enqueueReplaceState(t,t.state,null)}function ig(e,t,n,r){var s=e.stateNode;s.props=n,s.state=e.memoizedState,s.refs={},C0(e);var i=t.contextType;typeof i=="object"&&i!==null?s.context=ps(i):(i=kr(t)?ra:mr.current,s.context=cl(e,i)),s.state=e.memoizedState,i=t.getDerivedStateFromProps,typeof i=="function"&&(sg(e,t,i,n),s.state=e.memoizedState),typeof t.getDerivedStateFromProps=="function"||typeof s.getSnapshotBeforeUpdate=="function"||typeof s.UNSAFE_componentWillMount!="function"&&typeof s.componentWillMount!="function"||(t=s.state,typeof s.componentWillMount=="function"&&s.componentWillMount(),typeof s.UNSAFE_componentWillMount=="function"&&s.UNSAFE_componentWillMount(),t!==s.state&&yf.enqueueReplaceState(s,s.state,null),Fp(e,n,s,r),s.state=e.memoizedState),typeof s.componentDidMount=="function"&&(e.flags|=4194308)}function hl(e,t){try{var n="",r=t;do n+=P3(r),r=r.return;while(r);var s=n}catch(i){s=`
Error generating stack: `+i.message+`
`+i.stack}return{value:e,source:t,stack:s,digest:null}}function pm(e,t,n){return{value:e,source:null,stack:n??null,digest:t??null}}function og(e,t){try{console.error(t.value)}catch(n){setTimeout(function(){throw n})}}var ZL=typeof WeakMap=="function"?WeakMap:Map;function Rk(e,t,n){n=ci(-1,n),n.tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){Np||(Np=!0,_g=r),og(e,t)},n}function Bk(e,t,n){n=ci(-1,n),n.tag=3;var r=e.type.getDerivedStateFromError;if(typeof r=="function"){var s=t.value;n.payload=function(){return r(s)},n.callback=function(){og(e,t)}}var i=e.stateNode;return i!==null&&typeof i.componentDidCatch=="function"&&(n.callback=function(){og(e,t),typeof r!="function"&&(Qi===null?Qi=new Set([this]):Qi.add(this));var o=t.stack;this.componentDidCatch(t.value,{componentStack:o!==null?o:""})}),n}function Ob(e,t,n){var r=e.pingCache;if(r===null){r=e.pingCache=new ZL;var s=new Set;r.set(t,s)}else s=r.get(t),s===void 0&&(s=new Set,r.set(t,s));s.has(n)||(s.add(n),e=fz.bind(null,e,t,n),t.then(e,e))}function Fb(e){do{var t;if((t=e.tag===13)&&(t=e.memoizedState,t=t!==null?t.dehydrated!==null:!0),t)return e;e=e.return}while(e!==null);return null}function Lb(e,t,n,r,s){return e.mode&1?(e.flags|=65536,e.lanes=s,e):(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(t=ci(-1,1),t.tag=2,qi(n,t,1))),n.lanes|=1),e)}var ez=vi.ReactCurrentOwner,Sr=!1;function vr(e,t,n,r){t.child=e===null?hk(t,null,n,r):pl(t,e.child,n,r)}function zb(e,t,n,r,s){n=n.render;var i=t.ref;return al(t,s),r=D0(e,t,n,r,i,s),n=O0(),e!==null&&!Sr?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,gi(e,t,s)):(dn&&n&&M0(t),t.flags|=1,vr(e,t,r,s),t.child)}function Rb(e,t,n,r,s){if(e===null){var i=n.type;return typeof i=="function"&&!W0(i)&&i.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(t.tag=15,t.type=i,Nk(e,t,i,r,s)):(e=pp(n.type,null,r,t,t.mode,s),e.ref=t.ref,e.return=t,t.child=e)}if(i=e.child,!(e.lanes&s)){var o=i.memoizedProps;if(n=n.compare,n=n!==null?n:qu,n(o,r)&&e.ref===t.ref)return gi(e,t,s)}return t.flags|=1,e=Yi(i,r),e.ref=t.ref,e.return=t,t.child=e}function Nk(e,t,n,r,s){if(e!==null){var i=e.memoizedProps;if(qu(i,r)&&e.ref===t.ref)if(Sr=!1,t.pendingProps=r=i,(e.lanes&s)!==0)e.flags&131072&&(Sr=!0);else return t.lanes=e.lanes,gi(e,t,s)}return ag(e,t,n,r,s)}function jk(e,t,n){var r=t.pendingProps,s=r.children,i=e!==null?e.memoizedState:null;if(r.mode==="hidden")if(!(t.mode&1))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},sn(Xa,Vr),Vr|=n;else{if(!(n&1073741824))return e=i!==null?i.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,sn(Xa,Vr),Vr|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=i!==null?i.baseLanes:n,sn(Xa,Vr),Vr|=r}else i!==null?(r=i.baseLanes|n,t.memoizedState=null):r=n,sn(Xa,Vr),Vr|=r;return vr(e,t,s,n),t.child}function Vk(e,t){var n=t.ref;(e===null&&n!==null||e!==null&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function ag(e,t,n,r,s){var i=kr(n)?ra:mr.current;return i=cl(t,i),al(t,s),n=D0(e,t,n,r,i,s),r=O0(),e!==null&&!Sr?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,gi(e,t,s)):(dn&&r&&M0(t),t.flags|=1,vr(e,t,n,s),t.child)}function Bb(e,t,n,r,s){if(kr(n)){var i=!0;$p(t)}else i=!1;if(al(t,s),t.stateNode===null)up(e,t),zk(t,n,r),ig(t,n,r,s),r=!0;else if(e===null){var o=t.stateNode,a=t.memoizedProps;o.props=a;var l=o.context,u=n.contextType;typeof u=="object"&&u!==null?u=ps(u):(u=kr(n)?ra:mr.current,u=cl(t,u));var p=n.getDerivedStateFromProps,c=typeof p=="function"||typeof o.getSnapshotBeforeUpdate=="function";c||typeof o.UNSAFE_componentWillReceiveProps!="function"&&typeof o.componentWillReceiveProps!="function"||(a!==r||l!==u)&&Db(t,o,r,u),zi=!1;var d=t.memoizedState;o.state=d,Fp(t,r,o,s),l=t.memoizedState,a!==r||d!==l||Cr.current||zi?(typeof p=="function"&&(sg(t,n,p,r),l=t.memoizedState),(a=zi||Ab(t,n,a,r,d,l,u))?(c||typeof o.UNSAFE_componentWillMount!="function"&&typeof o.componentWillMount!="function"||(typeof o.componentWillMount=="function"&&o.componentWillMount(),typeof o.UNSAFE_componentWillMount=="function"&&o.UNSAFE_componentWillMount()),typeof o.componentDidMount=="function"&&(t.flags|=4194308)):(typeof o.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=l),o.props=r,o.state=l,o.context=u,r=a):(typeof o.componentDidMount=="function"&&(t.flags|=4194308),r=!1)}else{o=t.stateNode,_k(e,t),a=t.memoizedProps,u=t.type===t.elementType?a:Cs(t.type,a),o.props=u,c=t.pendingProps,d=o.context,l=n.contextType,typeof l=="object"&&l!==null?l=ps(l):(l=kr(n)?ra:mr.current,l=cl(t,l));var f=n.getDerivedStateFromProps;(p=typeof f=="function"||typeof o.getSnapshotBeforeUpdate=="function")||typeof o.UNSAFE_componentWillReceiveProps!="function"&&typeof o.componentWillReceiveProps!="function"||(a!==c||d!==l)&&Db(t,o,r,l),zi=!1,d=t.memoizedState,o.state=d,Fp(t,r,o,s);var m=t.memoizedState;a!==c||d!==m||Cr.current||zi?(typeof f=="function"&&(sg(t,n,f,r),m=t.memoizedState),(u=zi||Ab(t,n,u,r,d,m,l)||!1)?(p||typeof o.UNSAFE_componentWillUpdate!="function"&&typeof o.componentWillUpdate!="function"||(typeof o.componentWillUpdate=="function"&&o.componentWillUpdate(r,m,l),typeof o.UNSAFE_componentWillUpdate=="function"&&o.UNSAFE_componentWillUpdate(r,m,l)),typeof o.componentDidUpdate=="function"&&(t.flags|=4),typeof o.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof o.componentDidUpdate!="function"||a===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),typeof o.getSnapshotBeforeUpdate!="function"||a===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=m),o.props=r,o.state=m,o.context=l,r=u):(typeof o.componentDidUpdate!="function"||a===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),typeof o.getSnapshotBeforeUpdate!="function"||a===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),r=!1)}return lg(e,t,n,r,i,s)}function lg(e,t,n,r,s,i){Vk(e,t);var o=(t.flags&128)!==0;if(!r&&!o)return s&&Tb(t,n,!1),gi(e,t,i);r=t.stateNode,ez.current=t;var a=o&&typeof n.getDerivedStateFromError!="function"?null:r.render();return t.flags|=1,e!==null&&o?(t.child=pl(t,e.child,null,i),t.child=pl(t,null,a,i)):vr(e,t,a,i),t.memoizedState=r.state,s&&Tb(t,n,!0),t.child}function Uk(e){var t=e.stateNode;t.pendingContext?bb(e,t.pendingContext,t.pendingContext!==t.context):t.context&&bb(e,t.context,!1),k0(e,t.containerInfo)}function Nb(e,t,n,r,s){return dl(),b0(s),t.flags|=256,vr(e,t,n,r),t.child}var ug={dehydrated:null,treeContext:null,retryLane:0};function cg(e){return{baseLanes:e,cachePool:null,transitions:null}}function Wk(e,t,n){var r=t.pendingProps,s=mn.current,i=!1,o=(t.flags&128)!==0,a;if((a=o)||(a=e!==null&&e.memoizedState===null?!1:(s&2)!==0),a?(i=!0,t.flags&=-129):(e===null||e.memoizedState!==null)&&(s|=1),sn(mn,s&1),e===null)return ng(t),e=t.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?(t.mode&1?e.data==="$!"?t.lanes=8:t.lanes=1073741824:t.lanes=1,null):(o=r.children,e=r.fallback,i?(r=t.mode,i=t.child,o={mode:"hidden",children:o},!(r&1)&&i!==null?(i.childLanes=0,i.pendingProps=o):i=Mf(o,r,0,null),e=ea(e,r,n,null),i.return=t,e.return=t,i.sibling=e,t.child=i,t.child.memoizedState=cg(n),t.memoizedState=ug,e):z0(t,o));if(s=e.memoizedState,s!==null&&(a=s.dehydrated,a!==null))return tz(e,t,o,r,a,s,n);if(i){i=r.fallback,o=t.mode,s=e.child,a=s.sibling;var l={mode:"hidden",children:r.children};return!(o&1)&&t.child!==s?(r=t.child,r.childLanes=0,r.pendingProps=l,t.deletions=null):(r=Yi(s,l),r.subtreeFlags=s.subtreeFlags&14680064),a!==null?i=Yi(a,i):(i=ea(i,o,n,null),i.flags|=2),i.return=t,r.return=t,r.sibling=i,t.child=r,r=i,i=t.child,o=e.child.memoizedState,o=o===null?cg(n):{baseLanes:o.baseLanes|n,cachePool:null,transitions:o.transitions},i.memoizedState=o,i.childLanes=e.childLanes&~n,t.memoizedState=ug,r}return i=e.child,e=i.sibling,r=Yi(i,{mode:"visible",children:r.children}),!(t.mode&1)&&(r.lanes=n),r.return=t,r.sibling=null,e!==null&&(n=t.deletions,n===null?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=r,t.memoizedState=null,r}function z0(e,t){return t=Mf({mode:"visible",children:t},e.mode,0,null),t.return=e,e.child=t}function Id(e,t,n,r){return r!==null&&b0(r),pl(t,e.child,null,n),e=z0(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function tz(e,t,n,r,s,i,o){if(n)return t.flags&256?(t.flags&=-257,r=pm(Error(He(422))),Id(e,t,o,r)):t.memoizedState!==null?(t.child=e.child,t.flags|=128,null):(i=r.fallback,s=t.mode,r=Mf({mode:"visible",children:r.children},s,0,null),i=ea(i,s,o,null),i.flags|=2,r.return=t,i.return=t,r.sibling=i,t.child=r,t.mode&1&&pl(t,e.child,null,o),t.child.memoizedState=cg(o),t.memoizedState=ug,i);if(!(t.mode&1))return Id(e,t,o,null);if(s.data==="$!"){if(r=s.nextSibling&&s.nextSibling.dataset,r)var a=r.dgst;return r=a,i=Error(He(419)),r=pm(i,r,void 0),Id(e,t,o,r)}if(a=(o&e.childLanes)!==0,Sr||a){if(r=er,r!==null){switch(o&-o){case 4:s=2;break;case 16:s=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:s=32;break;case 536870912:s=268435456;break;default:s=0}s=s&(r.suspendedLanes|o)?0:s,s!==0&&s!==i.retryLane&&(i.retryLane=s,_i(e,s),Os(r,e,s,-1))}return U0(),r=pm(Error(He(421))),Id(e,t,o,r)}return s.data==="$?"?(t.flags|=128,t.child=e.child,t=hz.bind(null,e),s._reactRetry=t,null):(e=i.treeContext,Wr=Ki(s.nextSibling),Gr=t,dn=!0,$s=null,e!==null&&(os[as++]=ai,os[as++]=li,os[as++]=sa,ai=e.id,li=e.overflow,sa=t),t=z0(t,r.children),t.flags|=4096,t)}function jb(e,t,n){e.lanes|=t;var r=e.alternate;r!==null&&(r.lanes|=t),rg(e.return,t,n)}function fm(e,t,n,r,s){var i=e.memoizedState;i===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:s}:(i.isBackwards=t,i.rendering=null,i.renderingStartTime=0,i.last=r,i.tail=n,i.tailMode=s)}function Gk(e,t,n){var r=t.pendingProps,s=r.revealOrder,i=r.tail;if(vr(e,t,r.children,n),r=mn.current,r&2)r=r&1|2,t.flags|=128;else{if(e!==null&&e.flags&128)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&jb(e,n,t);else if(e.tag===19)jb(e,n,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(sn(mn,r),!(t.mode&1))t.memoizedState=null;else switch(s){case"forwards":for(n=t.child,s=null;n!==null;)e=n.alternate,e!==null&&Lp(e)===null&&(s=n),n=n.sibling;n=s,n===null?(s=t.child,t.child=null):(s=n.sibling,n.sibling=null),fm(t,!1,s,n,i);break;case"backwards":for(n=null,s=t.child,t.child=null;s!==null;){if(e=s.alternate,e!==null&&Lp(e)===null){t.child=s;break}e=s.sibling,s.sibling=n,n=s,s=e}fm(t,!0,n,null,i);break;case"together":fm(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function up(e,t){!(t.mode&1)&&e!==null&&(e.alternate=null,t.alternate=null,t.flags|=2)}function gi(e,t,n){if(e!==null&&(t.dependencies=e.dependencies),oa|=t.lanes,!(n&t.childLanes))return null;if(e!==null&&t.child!==e.child)throw Error(He(153));if(t.child!==null){for(e=t.child,n=Yi(e,e.pendingProps),t.child=n,n.return=t;e.sibling!==null;)e=e.sibling,n=n.sibling=Yi(e,e.pendingProps),n.return=t;n.sibling=null}return t.child}function nz(e,t,n){switch(t.tag){case 3:Uk(t),dl();break;case 5:gk(t);break;case 1:kr(t.type)&&$p(t);break;case 4:k0(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,s=t.memoizedProps.value;sn(Dp,r._currentValue),r._currentValue=s;break;case 13:if(r=t.memoizedState,r!==null)return r.dehydrated!==null?(sn(mn,mn.current&1),t.flags|=128,null):n&t.child.childLanes?Wk(e,t,n):(sn(mn,mn.current&1),e=gi(e,t,n),e!==null?e.sibling:null);sn(mn,mn.current&1);break;case 19:if(r=(n&t.childLanes)!==0,e.flags&128){if(r)return Gk(e,t,n);t.flags|=128}if(s=t.memoizedState,s!==null&&(s.rendering=null,s.tail=null,s.lastEffect=null),sn(mn,mn.current),r)break;return null;case 22:case 23:return t.lanes=0,jk(e,t,n)}return gi(e,t,n)}var Hk,dg,Kk,qk;Hk=function(e,t){for(var n=t.child;n!==null;){if(n.tag===5||n.tag===6)e.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===t)break;for(;n.sibling===null;){if(n.return===null||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};dg=function(){};Kk=function(e,t,n,r){var s=e.memoizedProps;if(s!==r){e=t.stateNode,Xo(qs.current);var i=null;switch(n){case"input":s=D_(e,s),r=D_(e,r),i=[];break;case"select":s=vn({},s,{value:void 0}),r=vn({},r,{value:void 0}),i=[];break;case"textarea":s=L_(e,s),r=L_(e,r),i=[];break;default:typeof s.onClick!="function"&&typeof r.onClick=="function"&&(e.onclick=Cp)}R_(n,r);var o;n=null;for(u in s)if(!r.hasOwnProperty(u)&&s.hasOwnProperty(u)&&s[u]!=null)if(u==="style"){var a=s[u];for(o in a)a.hasOwnProperty(o)&&(n||(n={}),n[o]="")}else u!=="dangerouslySetInnerHTML"&&u!=="children"&&u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&u!=="autoFocus"&&(ju.hasOwnProperty(u)?i||(i=[]):(i=i||[]).push(u,null));for(u in r){var l=r[u];if(a=s!=null?s[u]:void 0,r.hasOwnProperty(u)&&l!==a&&(l!=null||a!=null))if(u==="style")if(a){for(o in a)!a.hasOwnProperty(o)||l&&l.hasOwnProperty(o)||(n||(n={}),n[o]="");for(o in l)l.hasOwnProperty(o)&&a[o]!==l[o]&&(n||(n={}),n[o]=l[o])}else n||(i||(i=[]),i.push(u,n)),n=l;else u==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,a=a?a.__html:void 0,l!=null&&a!==l&&(i=i||[]).push(u,l)):u==="children"?typeof l!="string"&&typeof l!="number"||(i=i||[]).push(u,""+l):u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&(ju.hasOwnProperty(u)?(l!=null&&u==="onScroll"&&on("scroll",e),i||a===l||(i=[])):(i=i||[]).push(u,l))}n&&(i=i||[]).push("style",n);var u=i;(t.updateQueue=u)&&(t.flags|=4)}};qk=function(e,t,n,r){n!==r&&(t.flags|=4)};function su(e,t){if(!dn)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;t!==null;)t.alternate!==null&&(n=t),t=t.sibling;n===null?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;n!==null;)n.alternate!==null&&(r=n),n=n.sibling;r===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:r.sibling=null}}function dr(e){var t=e.alternate!==null&&e.alternate.child===e.child,n=0,r=0;if(t)for(var s=e.child;s!==null;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags&14680064,r|=s.flags&14680064,s.return=e,s=s.sibling;else for(s=e.child;s!==null;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags,r|=s.flags,s.return=e,s=s.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function rz(e,t,n){var r=t.pendingProps;switch(x0(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return dr(t),null;case 1:return kr(t.type)&&kp(),dr(t),null;case 3:return r=t.stateNode,fl(),ln(Cr),ln(mr),I0(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),(e===null||e.child===null)&&(kd(t)?t.flags|=4:e===null||e.memoizedState.isDehydrated&&!(t.flags&256)||(t.flags|=1024,$s!==null&&(vg($s),$s=null))),dg(e,t),dr(t),null;case 5:$0(t);var s=Xo(Zu.current);if(n=t.type,e!==null&&t.stateNode!=null)Kk(e,t,n,r,s),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(t.stateNode===null)throw Error(He(166));return dr(t),null}if(e=Xo(qs.current),kd(t)){r=t.stateNode,n=t.type;var i=t.memoizedProps;switch(r[Hs]=t,r[Yu]=i,e=(t.mode&1)!==0,n){case"dialog":on("cancel",r),on("close",r);break;case"iframe":case"object":case"embed":on("load",r);break;case"video":case"audio":for(s=0;s<Mu.length;s++)on(Mu[s],r);break;case"source":on("error",r);break;case"img":case"image":case"link":on("error",r),on("load",r);break;case"details":on("toggle",r);break;case"input":Xx(r,i),on("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!i.multiple},on("invalid",r);break;case"textarea":Jx(r,i),on("invalid",r)}R_(n,i),s=null;for(var o in i)if(i.hasOwnProperty(o)){var a=i[o];o==="children"?typeof a=="string"?r.textContent!==a&&(i.suppressHydrationWarning!==!0&&Cd(r.textContent,a,e),s=["children",a]):typeof a=="number"&&r.textContent!==""+a&&(i.suppressHydrationWarning!==!0&&Cd(r.textContent,a,e),s=["children",""+a]):ju.hasOwnProperty(o)&&a!=null&&o==="onScroll"&&on("scroll",r)}switch(n){case"input":wd(r),Yx(r,i,!0);break;case"textarea":wd(r),Zx(r);break;case"select":case"option":break;default:typeof i.onClick=="function"&&(r.onclick=Cp)}r=s,t.updateQueue=r,r!==null&&(t.flags|=4)}else{o=s.nodeType===9?s:s.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=xC(n)),e==="http://www.w3.org/1999/xhtml"?n==="script"?(e=o.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof r.is=="string"?e=o.createElement(n,{is:r.is}):(e=o.createElement(n),n==="select"&&(o=e,r.multiple?o.multiple=!0:r.size&&(o.size=r.size))):e=o.createElementNS(e,n),e[Hs]=t,e[Yu]=r,Hk(e,t,!1,!1),t.stateNode=e;e:{switch(o=B_(n,r),n){case"dialog":on("cancel",e),on("close",e),s=r;break;case"iframe":case"object":case"embed":on("load",e),s=r;break;case"video":case"audio":for(s=0;s<Mu.length;s++)on(Mu[s],e);s=r;break;case"source":on("error",e),s=r;break;case"img":case"image":case"link":on("error",e),on("load",e),s=r;break;case"details":on("toggle",e),s=r;break;case"input":Xx(e,r),s=D_(e,r),on("invalid",e);break;case"option":s=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},s=vn({},r,{value:void 0}),on("invalid",e);break;case"textarea":Jx(e,r),s=L_(e,r),on("invalid",e);break;default:s=r}R_(n,s),a=s;for(i in a)if(a.hasOwnProperty(i)){var l=a[i];i==="style"?EC(e,l):i==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,l!=null&&bC(e,l)):i==="children"?typeof l=="string"?(n!=="textarea"||l!=="")&&Vu(e,l):typeof l=="number"&&Vu(e,""+l):i!=="suppressContentEditableWarning"&&i!=="suppressHydrationWarning"&&i!=="autoFocus"&&(ju.hasOwnProperty(i)?l!=null&&i==="onScroll"&&on("scroll",e):l!=null&&a0(e,i,l,o))}switch(n){case"input":wd(e),Yx(e,r,!1);break;case"textarea":wd(e),Zx(e);break;case"option":r.value!=null&&e.setAttribute("value",""+Zi(r.value));break;case"select":e.multiple=!!r.multiple,i=r.value,i!=null?rl(e,!!r.multiple,i,!1):r.defaultValue!=null&&rl(e,!!r.multiple,r.defaultValue,!0);break;default:typeof s.onClick=="function"&&(e.onclick=Cp)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}t.ref!==null&&(t.flags|=512,t.flags|=2097152)}return dr(t),null;case 6:if(e&&t.stateNode!=null)qk(e,t,e.memoizedProps,r);else{if(typeof r!="string"&&t.stateNode===null)throw Error(He(166));if(n=Xo(Zu.current),Xo(qs.current),kd(t)){if(r=t.stateNode,n=t.memoizedProps,r[Hs]=t,(i=r.nodeValue!==n)&&(e=Gr,e!==null))switch(e.tag){case 3:Cd(r.nodeValue,n,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&Cd(r.nodeValue,n,(e.mode&1)!==0)}i&&(t.flags|=4)}else r=(n.nodeType===9?n:n.ownerDocument).createTextNode(r),r[Hs]=t,t.stateNode=r}return dr(t),null;case 13:if(ln(mn),r=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(dn&&Wr!==null&&t.mode&1&&!(t.flags&128))pk(),dl(),t.flags|=98560,i=!1;else if(i=kd(t),r!==null&&r.dehydrated!==null){if(e===null){if(!i)throw Error(He(318));if(i=t.memoizedState,i=i!==null?i.dehydrated:null,!i)throw Error(He(317));i[Hs]=t}else dl(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;dr(t),i=!1}else $s!==null&&(vg($s),$s=null),i=!0;if(!i)return t.flags&65536?t:null}return t.flags&128?(t.lanes=n,t):(r=r!==null,r!==(e!==null&&e.memoizedState!==null)&&r&&(t.child.flags|=8192,t.mode&1&&(e===null||mn.current&1?Hn===0&&(Hn=3):U0())),t.updateQueue!==null&&(t.flags|=4),dr(t),null);case 4:return fl(),dg(e,t),e===null&&Qu(t.stateNode.containerInfo),dr(t),null;case 10:return P0(t.type._context),dr(t),null;case 17:return kr(t.type)&&kp(),dr(t),null;case 19:if(ln(mn),i=t.memoizedState,i===null)return dr(t),null;if(r=(t.flags&128)!==0,o=i.rendering,o===null)if(r)su(i,!1);else{if(Hn!==0||e!==null&&e.flags&128)for(e=t.child;e!==null;){if(o=Lp(e),o!==null){for(t.flags|=128,su(i,!1),r=o.updateQueue,r!==null&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;n!==null;)i=n,e=r,i.flags&=14680066,o=i.alternate,o===null?(i.childLanes=0,i.lanes=e,i.child=null,i.subtreeFlags=0,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=o.childLanes,i.lanes=o.lanes,i.child=o.child,i.subtreeFlags=0,i.deletions=null,i.memoizedProps=o.memoizedProps,i.memoizedState=o.memoizedState,i.updateQueue=o.updateQueue,i.type=o.type,e=o.dependencies,i.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return sn(mn,mn.current&1|2),t.child}e=e.sibling}i.tail!==null&&In()>ml&&(t.flags|=128,r=!0,su(i,!1),t.lanes=4194304)}else{if(!r)if(e=Lp(o),e!==null){if(t.flags|=128,r=!0,n=e.updateQueue,n!==null&&(t.updateQueue=n,t.flags|=4),su(i,!0),i.tail===null&&i.tailMode==="hidden"&&!o.alternate&&!dn)return dr(t),null}else 2*In()-i.renderingStartTime>ml&&n!==1073741824&&(t.flags|=128,r=!0,su(i,!1),t.lanes=4194304);i.isBackwards?(o.sibling=t.child,t.child=o):(n=i.last,n!==null?n.sibling=o:t.child=o,i.last=o)}return i.tail!==null?(t=i.tail,i.rendering=t,i.tail=t.sibling,i.renderingStartTime=In(),t.sibling=null,n=mn.current,sn(mn,r?n&1|2:n&1),t):(dr(t),null);case 22:case 23:return V0(),r=t.memoizedState!==null,e!==null&&e.memoizedState!==null!==r&&(t.flags|=8192),r&&t.mode&1?Vr&1073741824&&(dr(t),t.subtreeFlags&6&&(t.flags|=8192)):dr(t),null;case 24:return null;case 25:return null}throw Error(He(156,t.tag))}function sz(e,t){switch(x0(t),t.tag){case 1:return kr(t.type)&&kp(),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return fl(),ln(Cr),ln(mr),I0(),e=t.flags,e&65536&&!(e&128)?(t.flags=e&-65537|128,t):null;case 5:return $0(t),null;case 13:if(ln(mn),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(He(340));dl()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return ln(mn),null;case 4:return fl(),null;case 10:return P0(t.type._context),null;case 22:case 23:return V0(),null;case 24:return null;default:return null}}var Ad=!1,hr=!1,iz=typeof WeakSet=="function"?WeakSet:Set,st=null;function Qa(e,t){var n=e.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(r){En(e,t,r)}else n.current=null}function pg(e,t,n){try{n()}catch(r){En(e,t,r)}}var Vb=!1;function oz(e,t){if(Q_=Ep,e=ZC(),w0(e)){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{n=(n=e.ownerDocument)&&n.defaultView||window;var r=n.getSelection&&n.getSelection();if(r&&r.rangeCount!==0){n=r.anchorNode;var s=r.anchorOffset,i=r.focusNode;r=r.focusOffset;try{n.nodeType,i.nodeType}catch{n=null;break e}var o=0,a=-1,l=-1,u=0,p=0,c=e,d=null;t:for(;;){for(var f;c!==n||s!==0&&c.nodeType!==3||(a=o+s),c!==i||r!==0&&c.nodeType!==3||(l=o+r),c.nodeType===3&&(o+=c.nodeValue.length),(f=c.firstChild)!==null;)d=c,c=f;for(;;){if(c===e)break t;if(d===n&&++u===s&&(a=o),d===i&&++p===r&&(l=o),(f=c.nextSibling)!==null)break;c=d,d=c.parentNode}c=f}n=a===-1||l===-1?null:{start:a,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(X_={focusedElem:e,selectionRange:n},Ep=!1,st=t;st!==null;)if(t=st,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,st=e;else for(;st!==null;){t=st;try{var m=t.alternate;if(t.flags&1024)switch(t.tag){case 0:case 11:case 15:break;case 1:if(m!==null){var y=m.memoizedProps,C=m.memoizedState,_=t.stateNode,h=_.getSnapshotBeforeUpdate(t.elementType===t.type?y:Cs(t.type,y),C);_.__reactInternalSnapshotBeforeUpdate=h}break;case 3:var w=t.stateNode.containerInfo;w.nodeType===1?w.textContent="":w.nodeType===9&&w.documentElement&&w.removeChild(w.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(He(163))}}catch(M){En(t,t.return,M)}if(e=t.sibling,e!==null){e.return=t.return,st=e;break}st=t.return}return m=Vb,Vb=!1,m}function Du(e,t,n){var r=t.updateQueue;if(r=r!==null?r.lastEffect:null,r!==null){var s=r=r.next;do{if((s.tag&e)===e){var i=s.destroy;s.destroy=void 0,i!==void 0&&pg(t,n,i)}s=s.next}while(s!==r)}}function vf(e,t){if(t=t.updateQueue,t=t!==null?t.lastEffect:null,t!==null){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function fg(e){var t=e.ref;if(t!==null){var n=e.stateNode;switch(e.tag){case 5:e=n;break;default:e=n}typeof t=="function"?t(e):t.current=e}}function Qk(e){var t=e.alternate;t!==null&&(e.alternate=null,Qk(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&(delete t[Hs],delete t[Yu],delete t[Z_],delete t[VL],delete t[UL])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function Xk(e){return e.tag===5||e.tag===3||e.tag===4}function Ub(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||Xk(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function hg(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.nodeType===8?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(n.nodeType===8?(t=n.parentNode,t.insertBefore(e,n)):(t=n,t.appendChild(e)),n=n._reactRootContainer,n!=null||t.onclick!==null||(t.onclick=Cp));else if(r!==4&&(e=e.child,e!==null))for(hg(e,t,n),e=e.sibling;e!==null;)hg(e,t,n),e=e.sibling}function mg(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(r!==4&&(e=e.child,e!==null))for(mg(e,t,n),e=e.sibling;e!==null;)mg(e,t,n),e=e.sibling}var nr=null,ks=!1;function Ii(e,t,n){for(n=n.child;n!==null;)Yk(e,t,n),n=n.sibling}function Yk(e,t,n){if(Ks&&typeof Ks.onCommitFiberUnmount=="function")try{Ks.onCommitFiberUnmount(df,n)}catch{}switch(n.tag){case 5:hr||Qa(n,t);case 6:var r=nr,s=ks;nr=null,Ii(e,t,n),nr=r,ks=s,nr!==null&&(ks?(e=nr,n=n.stateNode,e.nodeType===8?e.parentNode.removeChild(n):e.removeChild(n)):nr.removeChild(n.stateNode));break;case 18:nr!==null&&(ks?(e=nr,n=n.stateNode,e.nodeType===8?om(e.parentNode,n):e.nodeType===1&&om(e,n),Hu(e)):om(nr,n.stateNode));break;case 4:r=nr,s=ks,nr=n.stateNode.containerInfo,ks=!0,Ii(e,t,n),nr=r,ks=s;break;case 0:case 11:case 14:case 15:if(!hr&&(r=n.updateQueue,r!==null&&(r=r.lastEffect,r!==null))){s=r=r.next;do{var i=s,o=i.destroy;i=i.tag,o!==void 0&&(i&2||i&4)&&pg(n,t,o),s=s.next}while(s!==r)}Ii(e,t,n);break;case 1:if(!hr&&(Qa(n,t),r=n.stateNode,typeof r.componentWillUnmount=="function"))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(a){En(n,t,a)}Ii(e,t,n);break;case 21:Ii(e,t,n);break;case 22:n.mode&1?(hr=(r=hr)||n.memoizedState!==null,Ii(e,t,n),hr=r):Ii(e,t,n);break;default:Ii(e,t,n)}}function Wb(e){var t=e.updateQueue;if(t!==null){e.updateQueue=null;var n=e.stateNode;n===null&&(n=e.stateNode=new iz),t.forEach(function(r){var s=mz.bind(null,e,r);n.has(r)||(n.add(r),r.then(s,s))})}}function xs(e,t){var n=t.deletions;if(n!==null)for(var r=0;r<n.length;r++){var s=n[r];try{var i=e,o=t,a=o;e:for(;a!==null;){switch(a.tag){case 5:nr=a.stateNode,ks=!1;break e;case 3:nr=a.stateNode.containerInfo,ks=!0;break e;case 4:nr=a.stateNode.containerInfo,ks=!0;break e}a=a.return}if(nr===null)throw Error(He(160));Yk(i,o,s),nr=null,ks=!1;var l=s.alternate;l!==null&&(l.return=null),s.return=null}catch(u){En(s,t,u)}}if(t.subtreeFlags&12854)for(t=t.child;t!==null;)Jk(t,e),t=t.sibling}function Jk(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(xs(t,e),Us(e),r&4){try{Du(3,e,e.return),vf(3,e)}catch(y){En(e,e.return,y)}try{Du(5,e,e.return)}catch(y){En(e,e.return,y)}}break;case 1:xs(t,e),Us(e),r&512&&n!==null&&Qa(n,n.return);break;case 5:if(xs(t,e),Us(e),r&512&&n!==null&&Qa(n,n.return),e.flags&32){var s=e.stateNode;try{Vu(s,"")}catch(y){En(e,e.return,y)}}if(r&4&&(s=e.stateNode,s!=null)){var i=e.memoizedProps,o=n!==null?n.memoizedProps:i,a=e.type,l=e.updateQueue;if(e.updateQueue=null,l!==null)try{a==="input"&&i.type==="radio"&&i.name!=null&&wC(s,i),B_(a,o);var u=B_(a,i);for(o=0;o<l.length;o+=2){var p=l[o],c=l[o+1];p==="style"?EC(s,c):p==="dangerouslySetInnerHTML"?bC(s,c):p==="children"?Vu(s,c):a0(s,p,c,u)}switch(a){case"input":O_(s,i);break;case"textarea":MC(s,i);break;case"select":var d=s._wrapperState.wasMultiple;s._wrapperState.wasMultiple=!!i.multiple;var f=i.value;f!=null?rl(s,!!i.multiple,f,!1):d!==!!i.multiple&&(i.defaultValue!=null?rl(s,!!i.multiple,i.defaultValue,!0):rl(s,!!i.multiple,i.multiple?[]:"",!1))}s[Yu]=i}catch(y){En(e,e.return,y)}}break;case 6:if(xs(t,e),Us(e),r&4){if(e.stateNode===null)throw Error(He(162));s=e.stateNode,i=e.memoizedProps;try{s.nodeValue=i}catch(y){En(e,e.return,y)}}break;case 3:if(xs(t,e),Us(e),r&4&&n!==null&&n.memoizedState.isDehydrated)try{Hu(t.containerInfo)}catch(y){En(e,e.return,y)}break;case 4:xs(t,e),Us(e);break;case 13:xs(t,e),Us(e),s=e.child,s.flags&8192&&(i=s.memoizedState!==null,s.stateNode.isHidden=i,!i||s.alternate!==null&&s.alternate.memoizedState!==null||(N0=In())),r&4&&Wb(e);break;case 22:if(p=n!==null&&n.memoizedState!==null,e.mode&1?(hr=(u=hr)||p,xs(t,e),hr=u):xs(t,e),Us(e),r&8192){if(u=e.memoizedState!==null,(e.stateNode.isHidden=u)&&!p&&e.mode&1)for(st=e,p=e.child;p!==null;){for(c=st=p;st!==null;){switch(d=st,f=d.child,d.tag){case 0:case 11:case 14:case 15:Du(4,d,d.return);break;case 1:Qa(d,d.return);var m=d.stateNode;if(typeof m.componentWillUnmount=="function"){r=d,n=d.return;try{t=r,m.props=t.memoizedProps,m.state=t.memoizedState,m.componentWillUnmount()}catch(y){En(r,n,y)}}break;case 5:Qa(d,d.return);break;case 22:if(d.memoizedState!==null){Hb(c);continue}}f!==null?(f.return=d,st=f):Hb(c)}p=p.sibling}e:for(p=null,c=e;;){if(c.tag===5){if(p===null){p=c;try{s=c.stateNode,u?(i=s.style,typeof i.setProperty=="function"?i.setProperty("display","none","important"):i.display="none"):(a=c.stateNode,l=c.memoizedProps.style,o=l!=null&&l.hasOwnProperty("display")?l.display:null,a.style.display=TC("display",o))}catch(y){En(e,e.return,y)}}}else if(c.tag===6){if(p===null)try{c.stateNode.nodeValue=u?"":c.memoizedProps}catch(y){En(e,e.return,y)}}else if((c.tag!==22&&c.tag!==23||c.memoizedState===null||c===e)&&c.child!==null){c.child.return=c,c=c.child;continue}if(c===e)break e;for(;c.sibling===null;){if(c.return===null||c.return===e)break e;p===c&&(p=null),c=c.return}p===c&&(p=null),c.sibling.return=c.return,c=c.sibling}}break;case 19:xs(t,e),Us(e),r&4&&Wb(e);break;case 21:break;default:xs(t,e),Us(e)}}function Us(e){var t=e.flags;if(t&2){try{e:{for(var n=e.return;n!==null;){if(Xk(n)){var r=n;break e}n=n.return}throw Error(He(160))}switch(r.tag){case 5:var s=r.stateNode;r.flags&32&&(Vu(s,""),r.flags&=-33);var i=Ub(e);mg(e,i,s);break;case 3:case 4:var o=r.stateNode.containerInfo,a=Ub(e);hg(e,a,o);break;default:throw Error(He(161))}}catch(l){En(e,e.return,l)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function az(e,t,n){st=e,Zk(e)}function Zk(e,t,n){for(var r=(e.mode&1)!==0;st!==null;){var s=st,i=s.child;if(s.tag===22&&r){var o=s.memoizedState!==null||Ad;if(!o){var a=s.alternate,l=a!==null&&a.memoizedState!==null||hr;a=Ad;var u=hr;if(Ad=o,(hr=l)&&!u)for(st=s;st!==null;)o=st,l=o.child,o.tag===22&&o.memoizedState!==null?Kb(s):l!==null?(l.return=o,st=l):Kb(s);for(;i!==null;)st=i,Zk(i),i=i.sibling;st=s,Ad=a,hr=u}Gb(e)}else s.subtreeFlags&8772&&i!==null?(i.return=s,st=i):Gb(e)}}function Gb(e){for(;st!==null;){var t=st;if(t.flags&8772){var n=t.alternate;try{if(t.flags&8772)switch(t.tag){case 0:case 11:case 15:hr||vf(5,t);break;case 1:var r=t.stateNode;if(t.flags&4&&!hr)if(n===null)r.componentDidMount();else{var s=t.elementType===t.type?n.memoizedProps:Cs(t.type,n.memoizedProps);r.componentDidUpdate(s,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var i=t.updateQueue;i!==null&&kb(t,i,r);break;case 3:var o=t.updateQueue;if(o!==null){if(n=null,t.child!==null)switch(t.child.tag){case 5:n=t.child.stateNode;break;case 1:n=t.child.stateNode}kb(t,o,n)}break;case 5:var a=t.stateNode;if(n===null&&t.flags&4){n=a;var l=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(t.memoizedState===null){var u=t.alternate;if(u!==null){var p=u.memoizedState;if(p!==null){var c=p.dehydrated;c!==null&&Hu(c)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(He(163))}hr||t.flags&512&&fg(t)}catch(d){En(t,t.return,d)}}if(t===e){st=null;break}if(n=t.sibling,n!==null){n.return=t.return,st=n;break}st=t.return}}function Hb(e){for(;st!==null;){var t=st;if(t===e){st=null;break}var n=t.sibling;if(n!==null){n.return=t.return,st=n;break}st=t.return}}function Kb(e){for(;st!==null;){var t=st;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{vf(4,t)}catch(l){En(t,n,l)}break;case 1:var r=t.stateNode;if(typeof r.componentDidMount=="function"){var s=t.return;try{r.componentDidMount()}catch(l){En(t,s,l)}}var i=t.return;try{fg(t)}catch(l){En(t,i,l)}break;case 5:var o=t.return;try{fg(t)}catch(l){En(t,o,l)}}}catch(l){En(t,t.return,l)}if(t===e){st=null;break}var a=t.sibling;if(a!==null){a.return=t.return,st=a;break}st=t.return}}var lz=Math.ceil,Bp=vi.ReactCurrentDispatcher,R0=vi.ReactCurrentOwner,cs=vi.ReactCurrentBatchConfig,Nt=0,er=null,Ln=null,sr=0,Vr=0,Xa=io(0),Hn=0,rc=null,oa=0,wf=0,B0=0,Ou=null,Pr=null,N0=0,ml=1/0,si=null,Np=!1,_g=null,Qi=null,Dd=!1,Vi=null,jp=0,Fu=0,gg=null,cp=-1,dp=0;function wr(){return Nt&6?In():cp!==-1?cp:cp=In()}function Xi(e){return e.mode&1?Nt&2&&sr!==0?sr&-sr:GL.transition!==null?(dp===0&&(dp=zC()),dp):(e=Qt,e!==0||(e=window.event,e=e===void 0?16:WC(e.type)),e):1}function Os(e,t,n,r){if(50<Fu)throw Fu=0,gg=null,Error(He(185));fc(e,n,r),(!(Nt&2)||e!==er)&&(e===er&&(!(Nt&2)&&(wf|=n),Hn===4&&Ni(e,sr)),$r(e,r),n===1&&Nt===0&&!(t.mode&1)&&(ml=In()+500,_f&&oo()))}function $r(e,t){var n=e.callbackNode;G3(e,t);var r=Tp(e,e===er?sr:0);if(r===0)n!==null&&nb(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(n!=null&&nb(n),t===1)e.tag===0?WL(qb.bind(null,e)):uk(qb.bind(null,e)),NL(function(){!(Nt&6)&&oo()}),n=null;else{switch(RC(r)){case 1:n=p0;break;case 4:n=FC;break;case 16:n=bp;break;case 536870912:n=LC;break;default:n=bp}n=a$(n,e$.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function e$(e,t){if(cp=-1,dp=0,Nt&6)throw Error(He(327));var n=e.callbackNode;if(ll()&&e.callbackNode!==n)return null;var r=Tp(e,e===er?sr:0);if(r===0)return null;if(r&30||r&e.expiredLanes||t)t=Vp(e,r);else{t=r;var s=Nt;Nt|=2;var i=n$();(er!==e||sr!==t)&&(si=null,ml=In()+500,Zo(e,t));do try{dz();break}catch(a){t$(e,a)}while(!0);E0(),Bp.current=i,Nt=s,Ln!==null?t=0:(er=null,sr=0,t=Hn)}if(t!==0){if(t===2&&(s=W_(e),s!==0&&(r=s,t=yg(e,s))),t===1)throw n=rc,Zo(e,0),Ni(e,r),$r(e,In()),n;if(t===6)Ni(e,r);else{if(s=e.current.alternate,!(r&30)&&!uz(s)&&(t=Vp(e,r),t===2&&(i=W_(e),i!==0&&(r=i,t=yg(e,i))),t===1))throw n=rc,Zo(e,0),Ni(e,r),$r(e,In()),n;switch(e.finishedWork=s,e.finishedLanes=r,t){case 0:case 1:throw Error(He(345));case 2:jo(e,Pr,si);break;case 3:if(Ni(e,r),(r&130023424)===r&&(t=N0+500-In(),10<t)){if(Tp(e,0)!==0)break;if(s=e.suspendedLanes,(s&r)!==r){wr(),e.pingedLanes|=e.suspendedLanes&s;break}e.timeoutHandle=J_(jo.bind(null,e,Pr,si),t);break}jo(e,Pr,si);break;case 4:if(Ni(e,r),(r&4194240)===r)break;for(t=e.eventTimes,s=-1;0<r;){var o=31-Ds(r);i=1<<o,o=t[o],o>s&&(s=o),r&=~i}if(r=s,r=In()-r,r=(120>r?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*lz(r/1960))-r,10<r){e.timeoutHandle=J_(jo.bind(null,e,Pr,si),r);break}jo(e,Pr,si);break;case 5:jo(e,Pr,si);break;default:throw Error(He(329))}}}return $r(e,In()),e.callbackNode===n?e$.bind(null,e):null}function yg(e,t){var n=Ou;return e.current.memoizedState.isDehydrated&&(Zo(e,t).flags|=256),e=Vp(e,t),e!==2&&(t=Pr,Pr=n,t!==null&&vg(t)),e}function vg(e){Pr===null?Pr=e:Pr.push.apply(Pr,e)}function uz(e){for(var t=e;;){if(t.flags&16384){var n=t.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var r=0;r<n.length;r++){var s=n[r],i=s.getSnapshot;s=s.value;try{if(!Ls(i(),s))return!1}catch{return!1}}}if(n=t.child,t.subtreeFlags&16384&&n!==null)n.return=t,t=n;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Ni(e,t){for(t&=~B0,t&=~wf,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-Ds(t),r=1<<n;e[n]=-1,t&=~r}}function qb(e){if(Nt&6)throw Error(He(327));ll();var t=Tp(e,0);if(!(t&1))return $r(e,In()),null;var n=Vp(e,t);if(e.tag!==0&&n===2){var r=W_(e);r!==0&&(t=r,n=yg(e,r))}if(n===1)throw n=rc,Zo(e,0),Ni(e,t),$r(e,In()),n;if(n===6)throw Error(He(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,jo(e,Pr,si),$r(e,In()),null}function j0(e,t){var n=Nt;Nt|=1;try{return e(t)}finally{Nt=n,Nt===0&&(ml=In()+500,_f&&oo())}}function aa(e){Vi!==null&&Vi.tag===0&&!(Nt&6)&&ll();var t=Nt;Nt|=1;var n=cs.transition,r=Qt;try{if(cs.transition=null,Qt=1,e)return e()}finally{Qt=r,cs.transition=n,Nt=t,!(Nt&6)&&oo()}}function V0(){Vr=Xa.current,ln(Xa)}function Zo(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(n!==-1&&(e.timeoutHandle=-1,BL(n)),Ln!==null)for(n=Ln.return;n!==null;){var r=n;switch(x0(r),r.tag){case 1:r=r.type.childContextTypes,r!=null&&kp();break;case 3:fl(),ln(Cr),ln(mr),I0();break;case 5:$0(r);break;case 4:fl();break;case 13:ln(mn);break;case 19:ln(mn);break;case 10:P0(r.type._context);break;case 22:case 23:V0()}n=n.return}if(er=e,Ln=e=Yi(e.current,null),sr=Vr=t,Hn=0,rc=null,B0=wf=oa=0,Pr=Ou=null,Qo!==null){for(t=0;t<Qo.length;t++)if(n=Qo[t],r=n.interleaved,r!==null){n.interleaved=null;var s=r.next,i=n.pending;if(i!==null){var o=i.next;i.next=s,r.next=o}n.pending=r}Qo=null}return e}function t$(e,t){do{var n=Ln;try{if(E0(),ap.current=Rp,zp){for(var r=yn.memoizedState;r!==null;){var s=r.queue;s!==null&&(s.pending=null),r=r.next}zp=!1}if(ia=0,Zn=Gn=yn=null,Au=!1,ec=0,R0.current=null,n===null||n.return===null){Hn=1,rc=t,Ln=null;break}e:{var i=e,o=n.return,a=n,l=t;if(t=sr,a.flags|=32768,l!==null&&typeof l=="object"&&typeof l.then=="function"){var u=l,p=a,c=p.tag;if(!(p.mode&1)&&(c===0||c===11||c===15)){var d=p.alternate;d?(p.updateQueue=d.updateQueue,p.memoizedState=d.memoizedState,p.lanes=d.lanes):(p.updateQueue=null,p.memoizedState=null)}var f=Fb(o);if(f!==null){f.flags&=-257,Lb(f,o,a,i,t),f.mode&1&&Ob(i,u,t),t=f,l=u;var m=t.updateQueue;if(m===null){var y=new Set;y.add(l),t.updateQueue=y}else m.add(l);break e}else{if(!(t&1)){Ob(i,u,t),U0();break e}l=Error(He(426))}}else if(dn&&a.mode&1){var C=Fb(o);if(C!==null){!(C.flags&65536)&&(C.flags|=256),Lb(C,o,a,i,t),b0(hl(l,a));break e}}i=l=hl(l,a),Hn!==4&&(Hn=2),Ou===null?Ou=[i]:Ou.push(i),i=o;do{switch(i.tag){case 3:i.flags|=65536,t&=-t,i.lanes|=t;var _=Rk(i,l,t);Cb(i,_);break e;case 1:a=l;var h=i.type,w=i.stateNode;if(!(i.flags&128)&&(typeof h.getDerivedStateFromError=="function"||w!==null&&typeof w.componentDidCatch=="function"&&(Qi===null||!Qi.has(w)))){i.flags|=65536,t&=-t,i.lanes|=t;var M=Bk(i,a,t);Cb(i,M);break e}}i=i.return}while(i!==null)}s$(n)}catch(x){t=x,Ln===n&&n!==null&&(Ln=n=n.return);continue}break}while(!0)}function n$(){var e=Bp.current;return Bp.current=Rp,e===null?Rp:e}function U0(){(Hn===0||Hn===3||Hn===2)&&(Hn=4),er===null||!(oa&268435455)&&!(wf&268435455)||Ni(er,sr)}function Vp(e,t){var n=Nt;Nt|=2;var r=n$();(er!==e||sr!==t)&&(si=null,Zo(e,t));do try{cz();break}catch(s){t$(e,s)}while(!0);if(E0(),Nt=n,Bp.current=r,Ln!==null)throw Error(He(261));return er=null,sr=0,Hn}function cz(){for(;Ln!==null;)r$(Ln)}function dz(){for(;Ln!==null&&!L3();)r$(Ln)}function r$(e){var t=o$(e.alternate,e,Vr);e.memoizedProps=e.pendingProps,t===null?s$(e):Ln=t,R0.current=null}function s$(e){var t=e;do{var n=t.alternate;if(e=t.return,t.flags&32768){if(n=sz(n,t),n!==null){n.flags&=32767,Ln=n;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{Hn=6,Ln=null;return}}else if(n=rz(n,t,Vr),n!==null){Ln=n;return}if(t=t.sibling,t!==null){Ln=t;return}Ln=t=e}while(t!==null);Hn===0&&(Hn=5)}function jo(e,t,n){var r=Qt,s=cs.transition;try{cs.transition=null,Qt=1,pz(e,t,n,r)}finally{cs.transition=s,Qt=r}return null}function pz(e,t,n,r){do ll();while(Vi!==null);if(Nt&6)throw Error(He(327));n=e.finishedWork;var s=e.finishedLanes;if(n===null)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(He(177));e.callbackNode=null,e.callbackPriority=0;var i=n.lanes|n.childLanes;if(H3(e,i),e===er&&(Ln=er=null,sr=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||Dd||(Dd=!0,a$(bp,function(){return ll(),null})),i=(n.flags&15990)!==0,n.subtreeFlags&15990||i){i=cs.transition,cs.transition=null;var o=Qt;Qt=1;var a=Nt;Nt|=4,R0.current=null,oz(e,n),Jk(n,e),AL(X_),Ep=!!Q_,X_=Q_=null,e.current=n,az(n),z3(),Nt=a,Qt=o,cs.transition=i}else e.current=n;if(Dd&&(Dd=!1,Vi=e,jp=s),i=e.pendingLanes,i===0&&(Qi=null),N3(n.stateNode),$r(e,In()),t!==null)for(r=e.onRecoverableError,n=0;n<t.length;n++)s=t[n],r(s.value,{componentStack:s.stack,digest:s.digest});if(Np)throw Np=!1,e=_g,_g=null,e;return jp&1&&e.tag!==0&&ll(),i=e.pendingLanes,i&1?e===gg?Fu++:(Fu=0,gg=e):Fu=0,oo(),null}function ll(){if(Vi!==null){var e=RC(jp),t=cs.transition,n=Qt;try{if(cs.transition=null,Qt=16>e?16:e,Vi===null)var r=!1;else{if(e=Vi,Vi=null,jp=0,Nt&6)throw Error(He(331));var s=Nt;for(Nt|=4,st=e.current;st!==null;){var i=st,o=i.child;if(st.flags&16){var a=i.deletions;if(a!==null){for(var l=0;l<a.length;l++){var u=a[l];for(st=u;st!==null;){var p=st;switch(p.tag){case 0:case 11:case 15:Du(8,p,i)}var c=p.child;if(c!==null)c.return=p,st=c;else for(;st!==null;){p=st;var d=p.sibling,f=p.return;if(Qk(p),p===u){st=null;break}if(d!==null){d.return=f,st=d;break}st=f}}}var m=i.alternate;if(m!==null){var y=m.child;if(y!==null){m.child=null;do{var C=y.sibling;y.sibling=null,y=C}while(y!==null)}}st=i}}if(i.subtreeFlags&2064&&o!==null)o.return=i,st=o;else e:for(;st!==null;){if(i=st,i.flags&2048)switch(i.tag){case 0:case 11:case 15:Du(9,i,i.return)}var _=i.sibling;if(_!==null){_.return=i.return,st=_;break e}st=i.return}}var h=e.current;for(st=h;st!==null;){o=st;var w=o.child;if(o.subtreeFlags&2064&&w!==null)w.return=o,st=w;else e:for(o=h;st!==null;){if(a=st,a.flags&2048)try{switch(a.tag){case 0:case 11:case 15:vf(9,a)}}catch(x){En(a,a.return,x)}if(a===o){st=null;break e}var M=a.sibling;if(M!==null){M.return=a.return,st=M;break e}st=a.return}}if(Nt=s,oo(),Ks&&typeof Ks.onPostCommitFiberRoot=="function")try{Ks.onPostCommitFiberRoot(df,e)}catch{}r=!0}return r}finally{Qt=n,cs.transition=t}}return!1}function Qb(e,t,n){t=hl(n,t),t=Rk(e,t,1),e=qi(e,t,1),t=wr(),e!==null&&(fc(e,1,t),$r(e,t))}function En(e,t,n){if(e.tag===3)Qb(e,e,n);else for(;t!==null;){if(t.tag===3){Qb(t,e,n);break}else if(t.tag===1){var r=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof r.componentDidCatch=="function"&&(Qi===null||!Qi.has(r))){e=hl(n,e),e=Bk(t,e,1),t=qi(t,e,1),e=wr(),t!==null&&(fc(t,1,e),$r(t,e));break}}t=t.return}}function fz(e,t,n){var r=e.pingCache;r!==null&&r.delete(t),t=wr(),e.pingedLanes|=e.suspendedLanes&n,er===e&&(sr&n)===n&&(Hn===4||Hn===3&&(sr&130023424)===sr&&500>In()-N0?Zo(e,0):B0|=n),$r(e,t)}function i$(e,t){t===0&&(e.mode&1?(t=bd,bd<<=1,!(bd&130023424)&&(bd=4194304)):t=1);var n=wr();e=_i(e,t),e!==null&&(fc(e,t,n),$r(e,n))}function hz(e){var t=e.memoizedState,n=0;t!==null&&(n=t.retryLane),i$(e,n)}function mz(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,s=e.memoizedState;s!==null&&(n=s.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(He(314))}r!==null&&r.delete(t),i$(e,n)}var o$;o$=function(e,t,n){if(e!==null)if(e.memoizedProps!==t.pendingProps||Cr.current)Sr=!0;else{if(!(e.lanes&n)&&!(t.flags&128))return Sr=!1,nz(e,t,n);Sr=!!(e.flags&131072)}else Sr=!1,dn&&t.flags&1048576&&ck(t,Ap,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;up(e,t),e=t.pendingProps;var s=cl(t,mr.current);al(t,n),s=D0(null,t,r,e,s,n);var i=O0();return t.flags|=1,typeof s=="object"&&s!==null&&typeof s.render=="function"&&s.$$typeof===void 0?(t.tag=1,t.memoizedState=null,t.updateQueue=null,kr(r)?(i=!0,$p(t)):i=!1,t.memoizedState=s.state!==null&&s.state!==void 0?s.state:null,C0(t),s.updater=yf,t.stateNode=s,s._reactInternals=t,ig(t,r,e,n),t=lg(null,t,r,!0,i,n)):(t.tag=0,dn&&i&&M0(t),vr(null,t,s,n),t=t.child),t;case 16:r=t.elementType;e:{switch(up(e,t),e=t.pendingProps,s=r._init,r=s(r._payload),t.type=r,s=t.tag=gz(r),e=Cs(r,e),s){case 0:t=ag(null,t,r,e,n);break e;case 1:t=Bb(null,t,r,e,n);break e;case 11:t=zb(null,t,r,e,n);break e;case 14:t=Rb(null,t,r,Cs(r.type,e),n);break e}throw Error(He(306,r,""))}return t;case 0:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:Cs(r,s),ag(e,t,r,s,n);case 1:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:Cs(r,s),Bb(e,t,r,s,n);case 3:e:{if(Uk(t),e===null)throw Error(He(387));r=t.pendingProps,i=t.memoizedState,s=i.element,_k(e,t),Fp(t,r,null,n);var o=t.memoizedState;if(r=o.element,i.isDehydrated)if(i={element:r,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},t.updateQueue.baseState=i,t.memoizedState=i,t.flags&256){s=hl(Error(He(423)),t),t=Nb(e,t,r,n,s);break e}else if(r!==s){s=hl(Error(He(424)),t),t=Nb(e,t,r,n,s);break e}else for(Wr=Ki(t.stateNode.containerInfo.firstChild),Gr=t,dn=!0,$s=null,n=hk(t,null,r,n),t.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(dl(),r===s){t=gi(e,t,n);break e}vr(e,t,r,n)}t=t.child}return t;case 5:return gk(t),e===null&&ng(t),r=t.type,s=t.pendingProps,i=e!==null?e.memoizedProps:null,o=s.children,Y_(r,s)?o=null:i!==null&&Y_(r,i)&&(t.flags|=32),Vk(e,t),vr(e,t,o,n),t.child;case 6:return e===null&&ng(t),null;case 13:return Wk(e,t,n);case 4:return k0(t,t.stateNode.containerInfo),r=t.pendingProps,e===null?t.child=pl(t,null,r,n):vr(e,t,r,n),t.child;case 11:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:Cs(r,s),zb(e,t,r,s,n);case 7:return vr(e,t,t.pendingProps,n),t.child;case 8:return vr(e,t,t.pendingProps.children,n),t.child;case 12:return vr(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,s=t.pendingProps,i=t.memoizedProps,o=s.value,sn(Dp,r._currentValue),r._currentValue=o,i!==null)if(Ls(i.value,o)){if(i.children===s.children&&!Cr.current){t=gi(e,t,n);break e}}else for(i=t.child,i!==null&&(i.return=t);i!==null;){var a=i.dependencies;if(a!==null){o=i.child;for(var l=a.firstContext;l!==null;){if(l.context===r){if(i.tag===1){l=ci(-1,n&-n),l.tag=2;var u=i.updateQueue;if(u!==null){u=u.shared;var p=u.pending;p===null?l.next=l:(l.next=p.next,p.next=l),u.pending=l}}i.lanes|=n,l=i.alternate,l!==null&&(l.lanes|=n),rg(i.return,n,t),a.lanes|=n;break}l=l.next}}else if(i.tag===10)o=i.type===t.type?null:i.child;else if(i.tag===18){if(o=i.return,o===null)throw Error(He(341));o.lanes|=n,a=o.alternate,a!==null&&(a.lanes|=n),rg(o,n,t),o=i.sibling}else o=i.child;if(o!==null)o.return=i;else for(o=i;o!==null;){if(o===t){o=null;break}if(i=o.sibling,i!==null){i.return=o.return,o=i;break}o=o.return}i=o}vr(e,t,s.children,n),t=t.child}return t;case 9:return s=t.type,r=t.pendingProps.children,al(t,n),s=ps(s),r=r(s),t.flags|=1,vr(e,t,r,n),t.child;case 14:return r=t.type,s=Cs(r,t.pendingProps),s=Cs(r.type,s),Rb(e,t,r,s,n);case 15:return Nk(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:Cs(r,s),up(e,t),t.tag=1,kr(r)?(e=!0,$p(t)):e=!1,al(t,n),zk(t,r,s),ig(t,r,s,n),lg(null,t,r,!0,e,n);case 19:return Gk(e,t,n);case 22:return jk(e,t,n)}throw Error(He(156,t.tag))};function a$(e,t){return OC(e,t)}function _z(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function us(e,t,n,r){return new _z(e,t,n,r)}function W0(e){return e=e.prototype,!(!e||!e.isReactComponent)}function gz(e){if(typeof e=="function")return W0(e)?1:0;if(e!=null){if(e=e.$$typeof,e===u0)return 11;if(e===c0)return 14}return 2}function Yi(e,t){var n=e.alternate;return n===null?(n=us(e.tag,t,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&14680064,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function pp(e,t,n,r,s,i){var o=2;if(r=e,typeof e=="function")W0(e)&&(o=1);else if(typeof e=="string")o=5;else e:switch(e){case Na:return ea(n.children,s,i,t);case l0:o=8,s|=8;break;case k_:return e=us(12,n,t,s|2),e.elementType=k_,e.lanes=i,e;case $_:return e=us(13,n,t,s),e.elementType=$_,e.lanes=i,e;case I_:return e=us(19,n,t,s),e.elementType=I_,e.lanes=i,e;case gC:return Mf(n,s,i,t);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case mC:o=10;break e;case _C:o=9;break e;case u0:o=11;break e;case c0:o=14;break e;case Li:o=16,r=null;break e}throw Error(He(130,e==null?e:typeof e,""))}return t=us(o,n,t,s),t.elementType=e,t.type=r,t.lanes=i,t}function ea(e,t,n,r){return e=us(7,e,r,t),e.lanes=n,e}function Mf(e,t,n,r){return e=us(22,e,r,t),e.elementType=gC,e.lanes=n,e.stateNode={isHidden:!1},e}function hm(e,t,n){return e=us(6,e,null,t),e.lanes=n,e}function mm(e,t,n){return t=us(4,e.children!==null?e.children:[],e.key,t),t.lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function yz(e,t,n,r,s){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Qh(0),this.expirationTimes=Qh(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Qh(0),this.identifierPrefix=r,this.onRecoverableError=s,this.mutableSourceEagerHydrationData=null}function G0(e,t,n,r,s,i,o,a,l){return e=new yz(e,t,n,a,l),t===1?(t=1,i===!0&&(t|=8)):t=0,i=us(3,null,null,t),e.current=i,i.stateNode=e,i.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},C0(i),e}function vz(e,t,n){var r=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:Ba,key:r==null?null:""+r,children:e,containerInfo:t,implementation:n}}function l$(e){if(!e)return eo;e=e._reactInternals;e:{if(pa(e)!==e||e.tag!==1)throw Error(He(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(kr(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(t!==null);throw Error(He(171))}if(e.tag===1){var n=e.type;if(kr(n))return lk(e,n,t)}return t}function u$(e,t,n,r,s,i,o,a,l){return e=G0(n,r,!0,e,s,i,o,a,l),e.context=l$(null),n=e.current,r=wr(),s=Xi(n),i=ci(r,s),i.callback=t??null,qi(n,i,s),e.current.lanes=s,fc(e,s,r),$r(e,r),e}function xf(e,t,n,r){var s=t.current,i=wr(),o=Xi(s);return n=l$(n),t.context===null?t.context=n:t.pendingContext=n,t=ci(i,o),t.payload={element:e},r=r===void 0?null:r,r!==null&&(t.callback=r),e=qi(s,t,o),e!==null&&(Os(e,s,o,i),op(e,s,o)),o}function Up(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function Xb(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<t?n:t}}function H0(e,t){Xb(e,t),(e=e.alternate)&&Xb(e,t)}function wz(){return null}var c$=typeof reportError=="function"?reportError:function(e){console.error(e)};function K0(e){this._internalRoot=e}bf.prototype.render=K0.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(He(409));xf(e,t,null,null)};bf.prototype.unmount=K0.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;aa(function(){xf(null,e,null,null)}),t[mi]=null}};function bf(e){this._internalRoot=e}bf.prototype.unstable_scheduleHydration=function(e){if(e){var t=jC();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Bi.length&&t!==0&&t<Bi[n].priority;n++);Bi.splice(n,0,e),n===0&&UC(e)}};function q0(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function Tf(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function Yb(){}function Mz(e,t,n,r,s){if(s){if(typeof r=="function"){var i=r;r=function(){var u=Up(o);i.call(u)}}var o=u$(t,r,e,0,null,!1,!1,"",Yb);return e._reactRootContainer=o,e[mi]=o.current,Qu(e.nodeType===8?e.parentNode:e),aa(),o}for(;s=e.lastChild;)e.removeChild(s);if(typeof r=="function"){var a=r;r=function(){var u=Up(l);a.call(u)}}var l=G0(e,0,!1,null,null,!1,!1,"",Yb);return e._reactRootContainer=l,e[mi]=l.current,Qu(e.nodeType===8?e.parentNode:e),aa(function(){xf(t,l,n,r)}),l}function Ef(e,t,n,r,s){var i=n._reactRootContainer;if(i){var o=i;if(typeof s=="function"){var a=s;s=function(){var l=Up(o);a.call(l)}}xf(t,o,e,s)}else o=Mz(n,t,e,s,r);return Up(o)}BC=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=wu(t.pendingLanes);n!==0&&(f0(t,n|1),$r(t,In()),!(Nt&6)&&(ml=In()+500,oo()))}break;case 13:aa(function(){var r=_i(e,1);if(r!==null){var s=wr();Os(r,e,1,s)}}),H0(e,1)}};h0=function(e){if(e.tag===13){var t=_i(e,134217728);if(t!==null){var n=wr();Os(t,e,134217728,n)}H0(e,134217728)}};NC=function(e){if(e.tag===13){var t=Xi(e),n=_i(e,t);if(n!==null){var r=wr();Os(n,e,t,r)}H0(e,t)}};jC=function(){return Qt};VC=function(e,t){var n=Qt;try{return Qt=e,t()}finally{Qt=n}};j_=function(e,t,n){switch(t){case"input":if(O_(e,n),t=n.name,n.type==="radio"&&t!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var s=mf(r);if(!s)throw Error(He(90));vC(r),O_(r,s)}}}break;case"textarea":MC(e,n);break;case"select":t=n.value,t!=null&&rl(e,!!n.multiple,t,!1)}};CC=j0;kC=aa;var xz={usingClientEntryPoint:!1,Events:[mc,Wa,mf,PC,SC,j0]},iu={findFiberByHostInstance:qo,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},bz={bundleType:iu.bundleType,version:iu.version,rendererPackageName:iu.rendererPackageName,rendererConfig:iu.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:vi.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=AC(e),e===null?null:e.stateNode},findFiberByHostInstance:iu.findFiberByHostInstance||wz,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Od=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Od.isDisabled&&Od.supportsFiber)try{df=Od.inject(bz),Ks=Od}catch{}}Qr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=xz;Qr.createPortal=function(e,t){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!q0(t))throw Error(He(200));return vz(e,t,null,n)};Qr.createRoot=function(e,t){if(!q0(e))throw Error(He(299));var n=!1,r="",s=c$;return t!=null&&(t.unstable_strictMode===!0&&(n=!0),t.identifierPrefix!==void 0&&(r=t.identifierPrefix),t.onRecoverableError!==void 0&&(s=t.onRecoverableError)),t=G0(e,1,!1,null,null,n,!1,r,s),e[mi]=t.current,Qu(e.nodeType===8?e.parentNode:e),new K0(t)};Qr.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(He(188)):(e=Object.keys(e).join(","),Error(He(268,e)));return e=AC(t),e=e===null?null:e.stateNode,e};Qr.flushSync=function(e){return aa(e)};Qr.hydrate=function(e,t,n){if(!Tf(t))throw Error(He(200));return Ef(null,e,t,!0,n)};Qr.hydrateRoot=function(e,t,n){if(!q0(e))throw Error(He(405));var r=n!=null&&n.hydratedSources||null,s=!1,i="",o=c$;if(n!=null&&(n.unstable_strictMode===!0&&(s=!0),n.identifierPrefix!==void 0&&(i=n.identifierPrefix),n.onRecoverableError!==void 0&&(o=n.onRecoverableError)),t=u$(t,null,e,1,n??null,s,!1,i,o),e[mi]=t.current,Qu(e),r)for(e=0;e<r.length;e++)n=r[e],s=n._getVersion,s=s(n._source),t.mutableSourceEagerHydrationData==null?t.mutableSourceEagerHydrationData=[n,s]:t.mutableSourceEagerHydrationData.push(n,s);return new bf(t)};Qr.render=function(e,t,n){if(!Tf(t))throw Error(He(200));return Ef(null,e,t,!1,n)};Qr.unmountComponentAtNode=function(e){if(!Tf(e))throw Error(He(40));return e._reactRootContainer?(aa(function(){Ef(null,null,e,!1,function(){e._reactRootContainer=null,e[mi]=null})}),!0):!1};Qr.unstable_batchedUpdates=j0;Qr.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!Tf(n))throw Error(He(200));if(e==null||e._reactInternals===void 0)throw Error(He(38));return Ef(e,t,n,!1,r)};Qr.version="18.3.1-next-f1338f8080-20240426";function d$(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(d$)}catch(e){console.error(e)}}d$(),dC.exports=Qr;var p$=dC.exports;const Tz=ZS(p$);var f$,Jb=p$;f$=Jb.createRoot,Jb.hydrateRoot;var Zb=["light","dark"],Ez="(prefers-color-scheme: dark)",Pz=Fe.createContext(void 0),Sz={setTheme:e=>{},themes:[]},Cz=()=>{var e;return(e=Fe.useContext(Pz))!=null?e:Sz};Fe.memo(({forcedTheme:e,storageKey:t,attribute:n,enableSystem:r,enableColorScheme:s,defaultTheme:i,value:o,attrs:a,nonce:l})=>{let u=i==="system",p=n==="class"?`var d=document.documentElement,c=d.classList;${`c.remove(${a.map(m=>`'${m}'`).join(",")})`};`:`var d=document.documentElement,n='${n}',s='setAttribute';`,c=s?Zb.includes(i)&&i?`if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${i}'`:"if(e==='light'||e==='dark')d.style.colorScheme=e":"",d=(m,y=!1,C=!0)=>{let _=o?o[m]:m,h=y?m+"|| ''":`'${_}'`,w="";return s&&C&&!y&&Zb.includes(m)&&(w+=`d.style.colorScheme = '${m}';`),n==="class"?y||_?w+=`c.add(${h})`:w+="null":_&&(w+=`d[s](n,${h})`),w},f=e?`!function(){${p}${d(e)}}()`:r?`!function(){try{${p}var e=localStorage.getItem('${t}');if('system'===e||(!e&&${u})){var t='${Ez}',m=window.matchMedia(t);if(m.media!==t||m.matches){${d("dark")}}else{${d("light")}}}else if(e){${o?`var x=${JSON.stringify(o)};`:""}${d(o?"x[e]":"e",!0)}}${u?"":"else{"+d(i,!1,!1)+"}"}${c}}catch(e){}}()`:`!function(){try{${p}var e=localStorage.getItem('${t}');if(e){${o?`var x=${JSON.stringify(o)};`:""}${d(o?"x[e]":"e",!0)}}else{${d(i,!1,!1)};}${c}}catch(t){}}();`;return Fe.createElement("script",{nonce:l,dangerouslySetInnerHTML:{__html:f}})});var kz=e=>{switch(e){case"success":return Az;case"info":return Oz;case"warning":return Dz;case"error":return Fz;default:return null}},$z=Array(12).fill(0),Iz=({visible:e})=>Ze.createElement("div",{className:"sonner-loading-wrapper","data-visible":e},Ze.createElement("div",{className:"sonner-spinner"},$z.map((t,n)=>Ze.createElement("div",{className:"sonner-loading-bar",key:`spinner-bar-${n}`})))),Az=Ze.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor",height:"20",width:"20"},Ze.createElement("path",{fillRule:"evenodd",d:"M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",clipRule:"evenodd"})),Dz=Ze.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor",height:"20",width:"20"},Ze.createElement("path",{fillRule:"evenodd",d:"M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",clipRule:"evenodd"})),Oz=Ze.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor",height:"20",width:"20"},Ze.createElement("path",{fillRule:"evenodd",d:"M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",clipRule:"evenodd"})),Fz=Ze.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor",height:"20",width:"20"},Ze.createElement("path",{fillRule:"evenodd",d:"M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",clipRule:"evenodd"})),Lz=()=>{let[e,t]=Ze.useState(document.hidden);return Ze.useEffect(()=>{let n=()=>{t(document.hidden)};return document.addEventListener("visibilitychange",n),()=>window.removeEventListener("visibilitychange",n)},[]),e},wg=1,zz=class{constructor(){this.subscribe=t=>(this.subscribers.push(t),()=>{let n=this.subscribers.indexOf(t);this.subscribers.splice(n,1)}),this.publish=t=>{this.subscribers.forEach(n=>n(t))},this.addToast=t=>{this.publish(t),this.toasts=[...this.toasts,t]},this.create=t=>{var n;let{message:r,...s}=t,i=typeof(t==null?void 0:t.id)=="number"||((n=t.id)==null?void 0:n.length)>0?t.id:wg++,o=this.toasts.find(l=>l.id===i),a=t.dismissible===void 0?!0:t.dismissible;return o?this.toasts=this.toasts.map(l=>l.id===i?(this.publish({...l,...t,id:i,title:r}),{...l,...t,id:i,dismissible:a,title:r}):l):this.addToast({title:r,...s,dismissible:a,id:i}),i},this.dismiss=t=>(t||this.toasts.forEach(n=>{this.subscribers.forEach(r=>r({id:n.id,dismiss:!0}))}),this.subscribers.forEach(n=>n({id:t,dismiss:!0})),t),this.message=(t,n)=>this.create({...n,message:t}),this.error=(t,n)=>this.create({...n,message:t,type:"error"}),this.success=(t,n)=>this.create({...n,type:"success",message:t}),this.info=(t,n)=>this.create({...n,type:"info",message:t}),this.warning=(t,n)=>this.create({...n,type:"warning",message:t}),this.loading=(t,n)=>this.create({...n,type:"loading",message:t}),this.promise=(t,n)=>{if(!n)return;let r;n.loading!==void 0&&(r=this.create({...n,promise:t,type:"loading",message:n.loading,description:typeof n.description!="function"?n.description:void 0}));let s=t instanceof Promise?t:t(),i=r!==void 0;return s.then(async o=>{if(Bz(o)&&!o.ok){i=!1;let a=typeof n.error=="function"?await n.error(`HTTP error! status: ${o.status}`):n.error,l=typeof n.description=="function"?await n.description(`HTTP error! status: ${o.status}`):n.description;this.create({id:r,type:"error",message:a,description:l})}else if(n.success!==void 0){i=!1;let a=typeof n.success=="function"?await n.success(o):n.success,l=typeof n.description=="function"?await n.description(o):n.description;this.create({id:r,type:"success",message:a,description:l})}}).catch(async o=>{if(n.error!==void 0){i=!1;let a=typeof n.error=="function"?await n.error(o):n.error,l=typeof n.description=="function"?await n.description(o):n.description;this.create({id:r,type:"error",message:a,description:l})}}).finally(()=>{var o;i&&(this.dismiss(r),r=void 0),(o=n.finally)==null||o.call(n)}),r},this.custom=(t,n)=>{let r=(n==null?void 0:n.id)||wg++;return this.create({jsx:t(r),id:r,...n}),r},this.subscribers=[],this.toasts=[]}},jr=new zz,Rz=(e,t)=>{let n=(t==null?void 0:t.id)||wg++;return jr.addToast({title:e,...t,id:n}),n},Bz=e=>e&&typeof e=="object"&&"ok"in e&&typeof e.ok=="boolean"&&"status"in e&&typeof e.status=="number",Nz=Rz,jz=()=>jr.toasts,eT=Object.assign(Nz,{success:jr.success,info:jr.info,warning:jr.warning,error:jr.error,custom:jr.custom,message:jr.message,promise:jr.promise,dismiss:jr.dismiss,loading:jr.loading},{getHistory:jz});function Vz(e,{insertAt:t}={}){if(typeof document>"u")return;let n=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css",t==="top"&&n.firstChild?n.insertBefore(r,n.firstChild):n.appendChild(r),r.styleSheet?r.styleSheet.cssText=e:r.appendChild(document.createTextNode(e))}Vz(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999}:where([data-sonner-toaster][data-x-position="right"]){right:max(var(--offset),env(safe-area-inset-right))}:where([data-sonner-toaster][data-x-position="left"]){left:max(var(--offset),env(safe-area-inset-left))}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:max(var(--offset),env(safe-area-inset-top))}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:max(var(--offset),env(safe-area-inset-bottom))}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;background:var(--gray1);color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:0;right:0;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount, 0px));transition:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation:swipe-out .2s ease-out forwards}@keyframes swipe-out{0%{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount)));opacity:1}to{transform:translateY(calc(var(--lift) * var(--offset) + var(--swipe-amount) + var(--lift) * -100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;--mobile-offset: 16px;right:var(--mobile-offset);left:var(--mobile-offset);width:100%}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset)}[data-sonner-toaster][data-y-position=bottom]{bottom:20px}[data-sonner-toaster][data-y-position=top]{top:20px}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset);right:var(--mobile-offset);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);function Fd(e){return e.label!==void 0}var Uz=3,Wz="32px",Gz=4e3,Hz=356,Kz=14,qz=20,Qz=200;function Xz(...e){return e.filter(Boolean).join(" ")}var Yz=e=>{var t,n,r,s,i,o,a,l,u,p;let{invert:c,toast:d,unstyled:f,interacting:m,setHeights:y,visibleToasts:C,heights:_,index:h,toasts:w,expanded:M,removeToast:x,defaultRichColors:b,closeButton:T,style:S,cancelButtonStyle:$,actionButtonStyle:O,className:G="",descriptionClassName:H="",duration:N,position:J,gap:q,loadingIcon:X,expandByDefault:Y,classNames:K,icons:oe,closeButtonAriaLabel:se="Close toast",pauseWhenPageIsHidden:F,cn:I}=e,[V,ee]=Ze.useState(!1),[pe,Z]=Ze.useState(!1),[de,Se]=Ze.useState(!1),[Re,ye]=Ze.useState(!1),[Q,j]=Ze.useState(0),[he,be]=Ze.useState(0),we=Ze.useRef(null),Ce=Ze.useRef(null),De=h===0,Oe=h+1<=C,Le=d.type,je=d.dismissible!==!1,L=d.className||"",re=d.descriptionClassName||"",R=Ze.useMemo(()=>_.findIndex(ht=>ht.toastId===d.id)||0,[_,d.id]),ne=Ze.useMemo(()=>{var ht;return(ht=d.closeButton)!=null?ht:T},[d.closeButton,T]),ue=Ze.useMemo(()=>d.duration||N||Gz,[d.duration,N]),ve=Ze.useRef(0),Te=Ze.useRef(0),Ae=Ze.useRef(0),$e=Ze.useRef(null),[Ve,Je]=J.split("-"),qe=Ze.useMemo(()=>_.reduce((ht,Ft,Ct)=>Ct>=R?ht:ht+Ft.height,0),[_,R]),pt=Lz(),Tt=d.invert||c,Ht=Le==="loading";Te.current=Ze.useMemo(()=>R*q+qe,[R,qe]),Ze.useEffect(()=>{ee(!0)},[]),Ze.useLayoutEffect(()=>{if(!V)return;let ht=Ce.current,Ft=ht.style.height;ht.style.height="auto";let Ct=ht.getBoundingClientRect().height;ht.style.height=Ft,be(Ct),y(Bn=>Bn.find(An=>An.toastId===d.id)?Bn.map(An=>An.toastId===d.id?{...An,height:Ct}:An):[{toastId:d.id,height:Ct,position:d.position},...Bn])},[V,d.title,d.description,y,d.id]);let $t=Ze.useCallback(()=>{Z(!0),j(Te.current),y(ht=>ht.filter(Ft=>Ft.toastId!==d.id)),setTimeout(()=>{x(d)},Qz)},[d,x,y,Te]);Ze.useEffect(()=>{if(d.promise&&Le==="loading"||d.duration===1/0||d.type==="loading")return;let ht,Ft=ue;return M||m||F&&pt?(()=>{if(Ae.current<ve.current){let Ct=new Date().getTime()-ve.current;Ft=Ft-Ct}Ae.current=new Date().getTime()})():Ft!==1/0&&(ve.current=new Date().getTime(),ht=setTimeout(()=>{var Ct;(Ct=d.onAutoClose)==null||Ct.call(d,d),$t()},Ft)),()=>clearTimeout(ht)},[M,m,Y,d,ue,$t,d.promise,Le,F,pt]),Ze.useEffect(()=>{let ht=Ce.current;if(ht){let Ft=ht.getBoundingClientRect().height;return be(Ft),y(Ct=>[{toastId:d.id,height:Ft,position:d.position},...Ct]),()=>y(Ct=>Ct.filter(Bn=>Bn.toastId!==d.id))}},[y,d.id]),Ze.useEffect(()=>{d.delete&&$t()},[$t,d.delete]);function Pn(){return oe!=null&&oe.loading?Ze.createElement("div",{className:"sonner-loader","data-visible":Le==="loading"},oe.loading):X?Ze.createElement("div",{className:"sonner-loader","data-visible":Le==="loading"},X):Ze.createElement(Iz,{visible:Le==="loading"})}return Ze.createElement("li",{"aria-live":d.important?"assertive":"polite","aria-atomic":"true",role:"status",tabIndex:0,ref:Ce,className:I(G,L,K==null?void 0:K.toast,(t=d==null?void 0:d.classNames)==null?void 0:t.toast,K==null?void 0:K.default,K==null?void 0:K[Le],(n=d==null?void 0:d.classNames)==null?void 0:n[Le]),"data-sonner-toast":"","data-rich-colors":(r=d.richColors)!=null?r:b,"data-styled":!(d.jsx||d.unstyled||f),"data-mounted":V,"data-promise":!!d.promise,"data-removed":pe,"data-visible":Oe,"data-y-position":Ve,"data-x-position":Je,"data-index":h,"data-front":De,"data-swiping":de,"data-dismissible":je,"data-type":Le,"data-invert":Tt,"data-swipe-out":Re,"data-expanded":!!(M||Y&&V),style:{"--index":h,"--toasts-before":h,"--z-index":w.length-h,"--offset":`${pe?Q:Te.current}px`,"--initial-height":Y?"auto":`${he}px`,...S,...d.style},onPointerDown:ht=>{Ht||!je||(we.current=new Date,j(Te.current),ht.target.setPointerCapture(ht.pointerId),ht.target.tagName!=="BUTTON"&&(Se(!0),$e.current={x:ht.clientX,y:ht.clientY}))},onPointerUp:()=>{var ht,Ft,Ct,Bn;if(Re||!je)return;$e.current=null;let An=Number(((ht=Ce.current)==null?void 0:ht.style.getPropertyValue("--swipe-amount").replace("px",""))||0),Dr=new Date().getTime()-((Ft=we.current)==null?void 0:Ft.getTime()),ft=Math.abs(An)/Dr;if(Math.abs(An)>=qz||ft>.11){j(Te.current),(Ct=d.onDismiss)==null||Ct.call(d,d),$t(),ye(!0);return}(Bn=Ce.current)==null||Bn.style.setProperty("--swipe-amount","0px"),Se(!1)},onPointerMove:ht=>{var Ft;if(!$e.current||!je)return;let Ct=ht.clientY-$e.current.y,Bn=ht.clientX-$e.current.x,An=(Ve==="top"?Math.min:Math.max)(0,Ct),Dr=ht.pointerType==="touch"?10:2;Math.abs(An)>Dr?(Ft=Ce.current)==null||Ft.style.setProperty("--swipe-amount",`${Ct}px`):Math.abs(Bn)>Dr&&($e.current=null)}},ne&&!d.jsx?Ze.createElement("button",{"aria-label":se,"data-disabled":Ht,"data-close-button":!0,onClick:Ht||!je?()=>{}:()=>{var ht;$t(),(ht=d.onDismiss)==null||ht.call(d,d)},className:I(K==null?void 0:K.closeButton,(s=d==null?void 0:d.classNames)==null?void 0:s.closeButton)},Ze.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"12",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"1.5",strokeLinecap:"round",strokeLinejoin:"round"},Ze.createElement("line",{x1:"18",y1:"6",x2:"6",y2:"18"}),Ze.createElement("line",{x1:"6",y1:"6",x2:"18",y2:"18"}))):null,d.jsx||Ze.isValidElement(d.title)?d.jsx||d.title:Ze.createElement(Ze.Fragment,null,Le||d.icon||d.promise?Ze.createElement("div",{"data-icon":"",className:I(K==null?void 0:K.icon,(i=d==null?void 0:d.classNames)==null?void 0:i.icon)},d.promise||d.type==="loading"&&!d.icon?d.icon||Pn():null,d.type!=="loading"?d.icon||(oe==null?void 0:oe[Le])||kz(Le):null):null,Ze.createElement("div",{"data-content":"",className:I(K==null?void 0:K.content,(o=d==null?void 0:d.classNames)==null?void 0:o.content)},Ze.createElement("div",{"data-title":"",className:I(K==null?void 0:K.title,(a=d==null?void 0:d.classNames)==null?void 0:a.title)},d.title),d.description?Ze.createElement("div",{"data-description":"",className:I(H,re,K==null?void 0:K.description,(l=d==null?void 0:d.classNames)==null?void 0:l.description)},d.description):null),Ze.isValidElement(d.cancel)?d.cancel:d.cancel&&Fd(d.cancel)?Ze.createElement("button",{"data-button":!0,"data-cancel":!0,style:d.cancelButtonStyle||$,onClick:ht=>{var Ft,Ct;Fd(d.cancel)&&je&&((Ct=(Ft=d.cancel).onClick)==null||Ct.call(Ft,ht),$t())},className:I(K==null?void 0:K.cancelButton,(u=d==null?void 0:d.classNames)==null?void 0:u.cancelButton)},d.cancel.label):null,Ze.isValidElement(d.action)?d.action:d.action&&Fd(d.action)?Ze.createElement("button",{"data-button":!0,"data-action":!0,style:d.actionButtonStyle||O,onClick:ht=>{var Ft,Ct;Fd(d.action)&&(ht.defaultPrevented||((Ct=(Ft=d.action).onClick)==null||Ct.call(Ft,ht),$t()))},className:I(K==null?void 0:K.actionButton,(p=d==null?void 0:d.classNames)==null?void 0:p.actionButton)},d.action.label):null))};function tT(){if(typeof window>"u"||typeof document>"u")return"ltr";let e=document.documentElement.getAttribute("dir");return e==="auto"||!e?window.getComputedStyle(document.documentElement).direction:e}var Jz=e=>{let{invert:t,position:n="bottom-right",hotkey:r=["altKey","KeyT"],expand:s,closeButton:i,className:o,offset:a,theme:l="light",richColors:u,duration:p,style:c,visibleToasts:d=Uz,toastOptions:f,dir:m=tT(),gap:y=Kz,loadingIcon:C,icons:_,containerAriaLabel:h="Notifications",pauseWhenPageIsHidden:w,cn:M=Xz}=e,[x,b]=Ze.useState([]),T=Ze.useMemo(()=>Array.from(new Set([n].concat(x.filter(F=>F.position).map(F=>F.position)))),[x,n]),[S,$]=Ze.useState([]),[O,G]=Ze.useState(!1),[H,N]=Ze.useState(!1),[J,q]=Ze.useState(l!=="system"?l:typeof window<"u"&&window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"),X=Ze.useRef(null),Y=r.join("+").replace(/Key/g,"").replace(/Digit/g,""),K=Ze.useRef(null),oe=Ze.useRef(!1),se=Ze.useCallback(F=>{var I;(I=x.find(V=>V.id===F.id))!=null&&I.delete||jr.dismiss(F.id),b(V=>V.filter(({id:ee})=>ee!==F.id))},[x]);return Ze.useEffect(()=>jr.subscribe(F=>{if(F.dismiss){b(I=>I.map(V=>V.id===F.id?{...V,delete:!0}:V));return}setTimeout(()=>{Tz.flushSync(()=>{b(I=>{let V=I.findIndex(ee=>ee.id===F.id);return V!==-1?[...I.slice(0,V),{...I[V],...F},...I.slice(V+1)]:[F,...I]})})})}),[]),Ze.useEffect(()=>{if(l!=="system"){q(l);return}l==="system"&&(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?q("dark"):q("light")),typeof window<"u"&&window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",({matches:F})=>{q(F?"dark":"light")})},[l]),Ze.useEffect(()=>{x.length<=1&&G(!1)},[x]),Ze.useEffect(()=>{let F=I=>{var V,ee;r.every(pe=>I[pe]||I.code===pe)&&(G(!0),(V=X.current)==null||V.focus()),I.code==="Escape"&&(document.activeElement===X.current||(ee=X.current)!=null&&ee.contains(document.activeElement))&&G(!1)};return document.addEventListener("keydown",F),()=>document.removeEventListener("keydown",F)},[r]),Ze.useEffect(()=>{if(X.current)return()=>{K.current&&(K.current.focus({preventScroll:!0}),K.current=null,oe.current=!1)}},[X.current]),x.length?Ze.createElement("section",{"aria-label":`${h} ${Y}`,tabIndex:-1},T.map((F,I)=>{var V;let[ee,pe]=F.split("-");return Ze.createElement("ol",{key:F,dir:m==="auto"?tT():m,tabIndex:-1,ref:X,className:o,"data-sonner-toaster":!0,"data-theme":J,"data-y-position":ee,"data-x-position":pe,style:{"--front-toast-height":`${((V=S[0])==null?void 0:V.height)||0}px`,"--offset":typeof a=="number"?`${a}px`:a||Wz,"--width":`${Hz}px`,"--gap":`${y}px`,...c},onBlur:Z=>{oe.current&&!Z.currentTarget.contains(Z.relatedTarget)&&(oe.current=!1,K.current&&(K.current.focus({preventScroll:!0}),K.current=null))},onFocus:Z=>{Z.target instanceof HTMLElement&&Z.target.dataset.dismissible==="false"||oe.current||(oe.current=!0,K.current=Z.relatedTarget)},onMouseEnter:()=>G(!0),onMouseMove:()=>G(!0),onMouseLeave:()=>{H||G(!1)},onPointerDown:Z=>{Z.target instanceof HTMLElement&&Z.target.dataset.dismissible==="false"||N(!0)},onPointerUp:()=>N(!1)},x.filter(Z=>!Z.position&&I===0||Z.position===F).map((Z,de)=>{var Se,Re;return Ze.createElement(Yz,{key:Z.id,icons:_,index:de,toast:Z,defaultRichColors:u,duration:(Se=f==null?void 0:f.duration)!=null?Se:p,className:f==null?void 0:f.className,descriptionClassName:f==null?void 0:f.descriptionClassName,invert:t,visibleToasts:d,closeButton:(Re=f==null?void 0:f.closeButton)!=null?Re:i,interacting:H,position:F,style:f==null?void 0:f.style,unstyled:f==null?void 0:f.unstyled,classNames:f==null?void 0:f.classNames,cancelButtonStyle:f==null?void 0:f.cancelButtonStyle,actionButtonStyle:f==null?void 0:f.actionButtonStyle,removeToast:se,toasts:x.filter(ye=>ye.position==Z.position),heights:S.filter(ye=>ye.position==Z.position),setHeights:$,expandByDefault:s,gap:y,loadingIcon:C,expanded:O,pauseWhenPageIsHidden:w,cn:M})}))})):null};const Zz=({...e})=>{const{theme:t="system"}=Cz();return xe.jsx(Jz,{theme:t,className:"toaster group",toastOptions:{classNames:{toast:"group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",description:"group-[.toast]:text-muted-foreground",actionButton:"group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",cancelButton:"group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"}},...e})};/**
 * @remix-run/router v1.20.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function sc(){return sc=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},sc.apply(this,arguments)}var Ui;(function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"})(Ui||(Ui={}));const nT="popstate";function eR(e){e===void 0&&(e={});function t(s,i){let{pathname:o="/",search:a="",hash:l=""}=fa(s.location.hash.substr(1));return!o.startsWith("/")&&!o.startsWith(".")&&(o="/"+o),Mg("",{pathname:o,search:a,hash:l},i.state&&i.state.usr||null,i.state&&i.state.key||"default")}function n(s,i){let o=s.document.querySelector("base"),a="";if(o&&o.getAttribute("href")){let l=s.location.href,u=l.indexOf("#");a=u===-1?l:l.slice(0,u)}return a+"#"+(typeof i=="string"?i:Wp(i))}function r(s,i){Q0(s.pathname.charAt(0)==="/","relative pathnames are not supported in hash history.push("+JSON.stringify(i)+")")}return nR(t,n,r,e)}function Rn(e,t){if(e===!1||e===null||typeof e>"u")throw new Error(t)}function Q0(e,t){if(!e){typeof console<"u"&&console.warn(t);try{throw new Error(t)}catch{}}}function tR(){return Math.random().toString(36).substr(2,8)}function rT(e,t){return{usr:e.state,key:e.key,idx:t}}function Mg(e,t,n,r){return n===void 0&&(n=null),sc({pathname:typeof e=="string"?e:e.pathname,search:"",hash:""},typeof t=="string"?fa(t):t,{state:n,key:t&&t.key||r||tR()})}function Wp(e){let{pathname:t="/",search:n="",hash:r=""}=e;return n&&n!=="?"&&(t+=n.charAt(0)==="?"?n:"?"+n),r&&r!=="#"&&(t+=r.charAt(0)==="#"?r:"#"+r),t}function fa(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));let r=e.indexOf("?");r>=0&&(t.search=e.substr(r),e=e.substr(0,r)),e&&(t.pathname=e)}return t}function nR(e,t,n,r){r===void 0&&(r={});let{window:s=document.defaultView,v5Compat:i=!1}=r,o=s.history,a=Ui.Pop,l=null,u=p();u==null&&(u=0,o.replaceState(sc({},o.state,{idx:u}),""));function p(){return(o.state||{idx:null}).idx}function c(){a=Ui.Pop;let C=p(),_=C==null?null:C-u;u=C,l&&l({action:a,location:y.location,delta:_})}function d(C,_){a=Ui.Push;let h=Mg(y.location,C,_);n&&n(h,C),u=p()+1;let w=rT(h,u),M=y.createHref(h);try{o.pushState(w,"",M)}catch(x){if(x instanceof DOMException&&x.name==="DataCloneError")throw x;s.location.assign(M)}i&&l&&l({action:a,location:y.location,delta:1})}function f(C,_){a=Ui.Replace;let h=Mg(y.location,C,_);n&&n(h,C),u=p();let w=rT(h,u),M=y.createHref(h);o.replaceState(w,"",M),i&&l&&l({action:a,location:y.location,delta:0})}function m(C){let _=s.location.origin!=="null"?s.location.origin:s.location.href,h=typeof C=="string"?C:Wp(C);return h=h.replace(/ $/,"%20"),Rn(_,"No window.location.(origin|href) available to create URL for href: "+h),new URL(h,_)}let y={get action(){return a},get location(){return e(s,o)},listen(C){if(l)throw new Error("A history only accepts one active listener");return s.addEventListener(nT,c),l=C,()=>{s.removeEventListener(nT,c),l=null}},createHref(C){return t(s,C)},createURL:m,encodeLocation(C){let _=m(C);return{pathname:_.pathname,search:_.search,hash:_.hash}},push:d,replace:f,go(C){return o.go(C)}};return y}var sT;(function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"})(sT||(sT={}));function rR(e,t,n){return n===void 0&&(n="/"),sR(e,t,n,!1)}function sR(e,t,n,r){let s=typeof t=="string"?fa(t):t,i=X0(s.pathname||"/",n);if(i==null)return null;let o=h$(e);iR(o);let a=null;for(let l=0;a==null&&l<o.length;++l){let u=_R(i);a=hR(o[l],u,r)}return a}function h$(e,t,n,r){t===void 0&&(t=[]),n===void 0&&(n=[]),r===void 0&&(r="");let s=(i,o,a)=>{let l={relativePath:a===void 0?i.path||"":a,caseSensitive:i.caseSensitive===!0,childrenIndex:o,route:i};l.relativePath.startsWith("/")&&(Rn(l.relativePath.startsWith(r),'Absolute route path "'+l.relativePath+'" nested under path '+('"'+r+'" is not valid. An absolute child route path ')+"must start with the combined path of all its parent routes."),l.relativePath=l.relativePath.slice(r.length));let u=Ji([r,l.relativePath]),p=n.concat(l);i.children&&i.children.length>0&&(Rn(i.index!==!0,"Index routes must not have child routes. Please remove "+('all child routes from route path "'+u+'".')),h$(i.children,t,p,u)),!(i.path==null&&!i.index)&&t.push({path:u,score:pR(u,i.index),routesMeta:p})};return e.forEach((i,o)=>{var a;if(i.path===""||!((a=i.path)!=null&&a.includes("?")))s(i,o);else for(let l of m$(i.path))s(i,o,l)}),t}function m$(e){let t=e.split("/");if(t.length===0)return[];let[n,...r]=t,s=n.endsWith("?"),i=n.replace(/\?$/,"");if(r.length===0)return s?[i,""]:[i];let o=m$(r.join("/")),a=[];return a.push(...o.map(l=>l===""?i:[i,l].join("/"))),s&&a.push(...o),a.map(l=>e.startsWith("/")&&l===""?"/":l)}function iR(e){e.sort((t,n)=>t.score!==n.score?n.score-t.score:fR(t.routesMeta.map(r=>r.childrenIndex),n.routesMeta.map(r=>r.childrenIndex)))}const oR=/^:[\w-]+$/,aR=3,lR=2,uR=1,cR=10,dR=-2,iT=e=>e==="*";function pR(e,t){let n=e.split("/"),r=n.length;return n.some(iT)&&(r+=dR),t&&(r+=lR),n.filter(s=>!iT(s)).reduce((s,i)=>s+(oR.test(i)?aR:i===""?uR:cR),r)}function fR(e,t){return e.length===t.length&&e.slice(0,-1).every((r,s)=>r===t[s])?e[e.length-1]-t[t.length-1]:0}function hR(e,t,n){let{routesMeta:r}=e,s={},i="/",o=[];for(let a=0;a<r.length;++a){let l=r[a],u=a===r.length-1,p=i==="/"?t:t.slice(i.length)||"/",c=oT({path:l.relativePath,caseSensitive:l.caseSensitive,end:u},p),d=l.route;if(!c&&u&&n&&!r[r.length-1].route.index&&(c=oT({path:l.relativePath,caseSensitive:l.caseSensitive,end:!1},p)),!c)return null;Object.assign(s,c.params),o.push({params:s,pathname:Ji([i,c.pathname]),pathnameBase:wR(Ji([i,c.pathnameBase])),route:d}),c.pathnameBase!=="/"&&(i=Ji([i,c.pathnameBase]))}return o}function oT(e,t){typeof e=="string"&&(e={path:e,caseSensitive:!1,end:!0});let[n,r]=mR(e.path,e.caseSensitive,e.end),s=t.match(n);if(!s)return null;let i=s[0],o=i.replace(/(.)\/+$/,"$1"),a=s.slice(1);return{params:r.reduce((u,p,c)=>{let{paramName:d,isOptional:f}=p;if(d==="*"){let y=a[c]||"";o=i.slice(0,i.length-y.length).replace(/(.)\/+$/,"$1")}const m=a[c];return f&&!m?u[d]=void 0:u[d]=(m||"").replace(/%2F/g,"/"),u},{}),pathname:i,pathnameBase:o,pattern:e}}function mR(e,t,n){t===void 0&&(t=!1),n===void 0&&(n=!0),Q0(e==="*"||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were '+('"'+e.replace(/\*$/,"/*")+'" because the `*` character must ')+"always follow a `/` in the pattern. To get rid of this warning, "+('please change the route path to "'+e.replace(/\*$/,"/*")+'".'));let r=[],s="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(o,a,l)=>(r.push({paramName:a,isOptional:l!=null}),l?"/?([^\\/]+)?":"/([^\\/]+)"));return e.endsWith("*")?(r.push({paramName:"*"}),s+=e==="*"||e==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?s+="\\/*$":e!==""&&e!=="/"&&(s+="(?:(?=\\/|$))"),[new RegExp(s,t?void 0:"i"),r]}function _R(e){try{return e.split("/").map(t=>decodeURIComponent(t).replace(/\//g,"%2F")).join("/")}catch(t){return Q0(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent '+("encoding ("+t+").")),e}}function X0(e,t){if(t==="/")return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,r=e.charAt(n);return r&&r!=="/"?null:e.slice(n)||"/"}function gR(e,t){t===void 0&&(t="/");let{pathname:n,search:r="",hash:s=""}=typeof e=="string"?fa(e):e;return{pathname:n?n.startsWith("/")?n:yR(n,t):t,search:MR(r),hash:xR(s)}}function yR(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach(s=>{s===".."?n.length>1&&n.pop():s!=="."&&n.push(s)}),n.length>1?n.join("/"):"/"}function _m(e,t,n,r){return"Cannot include a '"+e+"' character in a manually specified "+("`to."+t+"` field ["+JSON.stringify(r)+"].  Please separate it out to the ")+("`to."+n+"` field. Alternatively you may provide the full path as ")+'a string in <Link to="..."> and the router will parse it for you.'}function vR(e){return e.filter((t,n)=>n===0||t.route.path&&t.route.path.length>0)}function _$(e,t){let n=vR(e);return t?n.map((r,s)=>s===n.length-1?r.pathname:r.pathnameBase):n.map(r=>r.pathnameBase)}function g$(e,t,n,r){r===void 0&&(r=!1);let s;typeof e=="string"?s=fa(e):(s=sc({},e),Rn(!s.pathname||!s.pathname.includes("?"),_m("?","pathname","search",s)),Rn(!s.pathname||!s.pathname.includes("#"),_m("#","pathname","hash",s)),Rn(!s.search||!s.search.includes("#"),_m("#","search","hash",s)));let i=e===""||s.pathname==="",o=i?"/":s.pathname,a;if(o==null)a=n;else{let c=t.length-1;if(!r&&o.startsWith("..")){let d=o.split("/");for(;d[0]==="..";)d.shift(),c-=1;s.pathname=d.join("/")}a=c>=0?t[c]:"/"}let l=gR(s,a),u=o&&o!=="/"&&o.endsWith("/"),p=(i||o===".")&&n.endsWith("/");return!l.pathname.endsWith("/")&&(u||p)&&(l.pathname+="/"),l}const Ji=e=>e.join("/").replace(/\/\/+/g,"/"),wR=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),MR=e=>!e||e==="?"?"":e.startsWith("?")?e:"?"+e,xR=e=>!e||e==="#"?"":e.startsWith("#")?e:"#"+e;function bR(e){return e!=null&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.internal=="boolean"&&"data"in e}const y$=["post","put","patch","delete"];new Set(y$);const TR=["get",...y$];new Set(TR);/**
 * React Router v6.27.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function ic(){return ic=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},ic.apply(this,arguments)}const Y0=Fe.createContext(null),ER=Fe.createContext(null),ha=Fe.createContext(null),Pf=Fe.createContext(null),ma=Fe.createContext({outlet:null,matches:[],isDataRoute:!1}),v$=Fe.createContext(null);function PR(e,t){let{relative:n}=t===void 0?{}:t;gc()||Rn(!1);let{basename:r,navigator:s}=Fe.useContext(ha),{hash:i,pathname:o,search:a}=M$(e,{relative:n}),l=o;return r!=="/"&&(l=o==="/"?r:Ji([r,o])),s.createHref({pathname:l,search:a,hash:i})}function gc(){return Fe.useContext(Pf)!=null}function yc(){return gc()||Rn(!1),Fe.useContext(Pf).location}function w$(e){Fe.useContext(ha).static||Fe.useLayoutEffect(e)}function vc(){let{isDataRoute:e}=Fe.useContext(ma);return e?BR():SR()}function SR(){gc()||Rn(!1);let e=Fe.useContext(Y0),{basename:t,future:n,navigator:r}=Fe.useContext(ha),{matches:s}=Fe.useContext(ma),{pathname:i}=yc(),o=JSON.stringify(_$(s,n.v7_relativeSplatPath)),a=Fe.useRef(!1);return w$(()=>{a.current=!0}),Fe.useCallback(function(u,p){if(p===void 0&&(p={}),!a.current)return;if(typeof u=="number"){r.go(u);return}let c=g$(u,JSON.parse(o),i,p.relative==="path");e==null&&t!=="/"&&(c.pathname=c.pathname==="/"?t:Ji([t,c.pathname])),(p.replace?r.replace:r.push)(c,p.state,p)},[t,r,o,i,e])}function M$(e,t){let{relative:n}=t===void 0?{}:t,{future:r}=Fe.useContext(ha),{matches:s}=Fe.useContext(ma),{pathname:i}=yc(),o=JSON.stringify(_$(s,r.v7_relativeSplatPath));return Fe.useMemo(()=>g$(e,JSON.parse(o),i,n==="path"),[e,o,i,n])}function CR(e,t){return kR(e,t)}function kR(e,t,n,r){gc()||Rn(!1);let{navigator:s}=Fe.useContext(ha),{matches:i}=Fe.useContext(ma),o=i[i.length-1],a=o?o.params:{};o&&o.pathname;let l=o?o.pathnameBase:"/";o&&o.route;let u=yc(),p;if(t){var c;let C=typeof t=="string"?fa(t):t;l==="/"||(c=C.pathname)!=null&&c.startsWith(l)||Rn(!1),p=C}else p=u;let d=p.pathname||"/",f=d;if(l!=="/"){let C=l.replace(/^\//,"").split("/");f="/"+d.replace(/^\//,"").split("/").slice(C.length).join("/")}let m=rR(e,{pathname:f}),y=OR(m&&m.map(C=>Object.assign({},C,{params:Object.assign({},a,C.params),pathname:Ji([l,s.encodeLocation?s.encodeLocation(C.pathname).pathname:C.pathname]),pathnameBase:C.pathnameBase==="/"?l:Ji([l,s.encodeLocation?s.encodeLocation(C.pathnameBase).pathname:C.pathnameBase])})),i,n,r);return t&&y?Fe.createElement(Pf.Provider,{value:{location:ic({pathname:"/",search:"",hash:"",state:null,key:"default"},p),navigationType:Ui.Pop}},y):y}function $R(){let e=RR(),t=bR(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,s={padding:"0.5rem",backgroundColor:"rgba(200,200,200, 0.5)"};return Fe.createElement(Fe.Fragment,null,Fe.createElement("h2",null,"Unexpected Application Error!"),Fe.createElement("h3",{style:{fontStyle:"italic"}},t),n?Fe.createElement("pre",{style:s},n):null,null)}const IR=Fe.createElement($R,null);class AR extends Fe.Component{constructor(t){super(t),this.state={location:t.location,revalidation:t.revalidation,error:t.error}}static getDerivedStateFromError(t){return{error:t}}static getDerivedStateFromProps(t,n){return n.location!==t.location||n.revalidation!=="idle"&&t.revalidation==="idle"?{error:t.error,location:t.location,revalidation:t.revalidation}:{error:t.error!==void 0?t.error:n.error,location:n.location,revalidation:t.revalidation||n.revalidation}}componentDidCatch(t,n){console.error("React Router caught the following error during render",t,n)}render(){return this.state.error!==void 0?Fe.createElement(ma.Provider,{value:this.props.routeContext},Fe.createElement(v$.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function DR(e){let{routeContext:t,match:n,children:r}=e,s=Fe.useContext(Y0);return s&&s.static&&s.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(s.staticContext._deepestRenderedBoundaryId=n.route.id),Fe.createElement(ma.Provider,{value:t},r)}function OR(e,t,n,r){var s;if(t===void 0&&(t=[]),n===void 0&&(n=null),r===void 0&&(r=null),e==null){var i;if(!n)return null;if(n.errors)e=n.matches;else if((i=r)!=null&&i.v7_partialHydration&&t.length===0&&!n.initialized&&n.matches.length>0)e=n.matches;else return null}let o=e,a=(s=n)==null?void 0:s.errors;if(a!=null){let p=o.findIndex(c=>c.route.id&&(a==null?void 0:a[c.route.id])!==void 0);p>=0||Rn(!1),o=o.slice(0,Math.min(o.length,p+1))}let l=!1,u=-1;if(n&&r&&r.v7_partialHydration)for(let p=0;p<o.length;p++){let c=o[p];if((c.route.HydrateFallback||c.route.hydrateFallbackElement)&&(u=p),c.route.id){let{loaderData:d,errors:f}=n,m=c.route.loader&&d[c.route.id]===void 0&&(!f||f[c.route.id]===void 0);if(c.route.lazy||m){l=!0,u>=0?o=o.slice(0,u+1):o=[o[0]];break}}}return o.reduceRight((p,c,d)=>{let f,m=!1,y=null,C=null;n&&(f=a&&c.route.id?a[c.route.id]:void 0,y=c.route.errorElement||IR,l&&(u<0&&d===0?(m=!0,C=null):u===d&&(m=!0,C=c.route.hydrateFallbackElement||null)));let _=t.concat(o.slice(0,d+1)),h=()=>{let w;return f?w=y:m?w=C:c.route.Component?w=Fe.createElement(c.route.Component,null):c.route.element?w=c.route.element:w=p,Fe.createElement(DR,{match:c,routeContext:{outlet:p,matches:_,isDataRoute:n!=null},children:w})};return n&&(c.route.ErrorBoundary||c.route.errorElement||d===0)?Fe.createElement(AR,{location:n.location,revalidation:n.revalidation,component:y,error:f,children:h(),routeContext:{outlet:null,matches:_,isDataRoute:!0}}):h()},null)}var x$=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(x$||{}),Gp=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(Gp||{});function FR(e){let t=Fe.useContext(Y0);return t||Rn(!1),t}function LR(e){let t=Fe.useContext(ER);return t||Rn(!1),t}function zR(e){let t=Fe.useContext(ma);return t||Rn(!1),t}function b$(e){let t=zR(),n=t.matches[t.matches.length-1];return n.route.id||Rn(!1),n.route.id}function RR(){var e;let t=Fe.useContext(v$),n=LR(Gp.UseRouteError),r=b$(Gp.UseRouteError);return t!==void 0?t:(e=n.errors)==null?void 0:e[r]}function BR(){let{router:e}=FR(x$.UseNavigateStable),t=b$(Gp.UseNavigateStable),n=Fe.useRef(!1);return w$(()=>{n.current=!0}),Fe.useCallback(function(s,i){i===void 0&&(i={}),n.current&&(typeof s=="number"?e.navigate(s):e.navigate(s,ic({fromRouteId:t},i)))},[e,t])}function Vo(e){Rn(!1)}function NR(e){let{basename:t="/",children:n=null,location:r,navigationType:s=Ui.Pop,navigator:i,static:o=!1,future:a}=e;gc()&&Rn(!1);let l=t.replace(/^\/*/,"/"),u=Fe.useMemo(()=>({basename:l,navigator:i,static:o,future:ic({v7_relativeSplatPath:!1},a)}),[l,a,i,o]);typeof r=="string"&&(r=fa(r));let{pathname:p="/",search:c="",hash:d="",state:f=null,key:m="default"}=r,y=Fe.useMemo(()=>{let C=X0(p,l);return C==null?null:{location:{pathname:C,search:c,hash:d,state:f,key:m},navigationType:s}},[l,p,c,d,f,m,s]);return y==null?null:Fe.createElement(ha.Provider,{value:u},Fe.createElement(Pf.Provider,{children:n,value:y}))}function jR(e){let{children:t,location:n}=e;return CR(xg(t),n)}new Promise(()=>{});function xg(e,t){t===void 0&&(t=[]);let n=[];return Fe.Children.forEach(e,(r,s)=>{if(!Fe.isValidElement(r))return;let i=[...t,s];if(r.type===Fe.Fragment){n.push.apply(n,xg(r.props.children,i));return}r.type!==Vo&&Rn(!1),!r.props.index||!r.props.children||Rn(!1);let o={id:r.props.id||i.join("-"),caseSensitive:r.props.caseSensitive,element:r.props.element,Component:r.props.Component,index:r.props.index,path:r.props.path,loader:r.props.loader,action:r.props.action,errorElement:r.props.errorElement,ErrorBoundary:r.props.ErrorBoundary,hasErrorBoundary:r.props.ErrorBoundary!=null||r.props.errorElement!=null,shouldRevalidate:r.props.shouldRevalidate,handle:r.props.handle,lazy:r.props.lazy};r.props.children&&(o.children=xg(r.props.children,i)),n.push(o)}),n}/**
 * React Router DOM v6.27.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function bg(){return bg=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},bg.apply(this,arguments)}function VR(e,t){if(e==null)return{};var n={},r=Object.keys(e),s,i;for(i=0;i<r.length;i++)s=r[i],!(t.indexOf(s)>=0)&&(n[s]=e[s]);return n}function UR(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}function WR(e,t){return e.button===0&&(!t||t==="_self")&&!UR(e)}const GR=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","viewTransition"],HR="6";try{window.__reactRouterVersion=HR}catch{}const KR="startTransition",aT=f3[KR];function qR(e){let{basename:t,children:n,future:r,window:s}=e,i=Fe.useRef();i.current==null&&(i.current=eR({window:s,v5Compat:!0}));let o=i.current,[a,l]=Fe.useState({action:o.action,location:o.location}),{v7_startTransition:u}=r||{},p=Fe.useCallback(c=>{u&&aT?aT(()=>l(c)):l(c)},[l,u]);return Fe.useLayoutEffect(()=>o.listen(p),[o,p]),Fe.createElement(NR,{basename:t,children:n,location:a.location,navigationType:a.action,navigator:o,future:r})}const QR=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",XR=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,T$=Fe.forwardRef(function(t,n){let{onClick:r,relative:s,reloadDocument:i,replace:o,state:a,target:l,to:u,preventScrollReset:p,viewTransition:c}=t,d=VR(t,GR),{basename:f}=Fe.useContext(ha),m,y=!1;if(typeof u=="string"&&XR.test(u)&&(m=u,QR))try{let w=new URL(window.location.href),M=u.startsWith("//")?new URL(w.protocol+u):new URL(u),x=X0(M.pathname,f);M.origin===w.origin&&x!=null?u=x+M.search+M.hash:y=!0}catch{}let C=PR(u,{relative:s}),_=YR(u,{replace:o,state:a,target:l,preventScrollReset:p,relative:s,viewTransition:c});function h(w){r&&r(w),w.defaultPrevented||_(w)}return Fe.createElement("a",bg({},d,{href:m||C,onClick:y||i?r:h,ref:n,target:l}))});var lT;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})(lT||(lT={}));var uT;(function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"})(uT||(uT={}));function YR(e,t){let{target:n,replace:r,state:s,preventScrollReset:i,relative:o,viewTransition:a}=t===void 0?{}:t,l=vc(),u=yc(),p=M$(e,{relative:o});return Fe.useCallback(c=>{if(WR(c,n)){c.preventDefault();let d=r!==void 0?r:Wp(u)===Wp(p);l(e,{replace:d,state:s,preventScrollReset:i,relative:o,viewTransition:a})}},[u,l,p,r,s,n,e,i,o,a])}const E$=Fe.createContext({transformPagePoint:e=>e,isStatic:!1,reducedMotion:"never"}),Sf=Fe.createContext({}),J0=Fe.createContext(null),Cf=typeof document<"u",JR=Cf?Fe.useLayoutEffect:Fe.useEffect,P$=Fe.createContext({strict:!1}),Z0=e=>e.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),ZR="framerAppearId",S$="data-"+Z0(ZR),C$={skipAnimations:!1,useManualTiming:!1};class cT{constructor(){this.order=[],this.scheduled=new Set}add(t){if(!this.scheduled.has(t))return this.scheduled.add(t),this.order.push(t),!0}remove(t){const n=this.order.indexOf(t);n!==-1&&(this.order.splice(n,1),this.scheduled.delete(t))}clear(){this.order.length=0,this.scheduled.clear()}}function eB(e){let t=new cT,n=new cT,r=0,s=!1,i=!1;const o=new WeakSet,a={schedule:(l,u=!1,p=!1)=>{const c=p&&s,d=c?t:n;return u&&o.add(l),d.add(l)&&c&&s&&(r=t.order.length),l},cancel:l=>{n.remove(l),o.delete(l)},process:l=>{if(s){i=!0;return}if(s=!0,[t,n]=[n,t],n.clear(),r=t.order.length,r)for(let u=0;u<r;u++){const p=t.order[u];o.has(p)&&(a.schedule(p),e()),p(l)}s=!1,i&&(i=!1,a.process(l))}};return a}const Ld=["prepare","read","update","preRender","render","postRender"],tB=40;function k$(e,t){let n=!1,r=!0;const s={delta:0,timestamp:0,isProcessing:!1},i=Ld.reduce((c,d)=>(c[d]=eB(()=>n=!0),c),{}),o=c=>{i[c].process(s)},a=()=>{const c=performance.now();n=!1,s.delta=r?1e3/60:Math.max(Math.min(c-s.timestamp,tB),1),s.timestamp=c,s.isProcessing=!0,Ld.forEach(o),s.isProcessing=!1,n&&t&&(r=!1,e(a))},l=()=>{n=!0,r=!0,s.isProcessing||e(a)};return{schedule:Ld.reduce((c,d)=>{const f=i[d];return c[d]=(m,y=!1,C=!1)=>(n||l(),f.schedule(m,y,C)),c},{}),cancel:c=>Ld.forEach(d=>i[d].cancel(c)),state:s,steps:i}}const{schedule:ey,cancel:FW}=k$(queueMicrotask,!1);function nB(e,t,n,r){const{visualElement:s}=Fe.useContext(Sf),i=Fe.useContext(P$),o=Fe.useContext(J0),a=Fe.useContext(E$).reducedMotion,l=Fe.useRef();r=r||i.renderer,!l.current&&r&&(l.current=r(e,{visualState:t,parent:s,props:n,presenceContext:o,blockInitialAnimation:o?o.initial===!1:!1,reducedMotionConfig:a}));const u=l.current;Fe.useInsertionEffect(()=>{u&&u.update(n,o)});const p=Fe.useRef(!!(n[S$]&&!window.HandoffComplete));return JR(()=>{u&&(ey.postRender(u.render),p.current&&u.animationState&&u.animationState.animateChanges())}),Fe.useEffect(()=>{u&&(u.updateFeatures(),!p.current&&u.animationState&&u.animationState.animateChanges(),p.current&&(p.current=!1,window.HandoffComplete=!0))}),u}function Ya(e){return e&&typeof e=="object"&&Object.prototype.hasOwnProperty.call(e,"current")}function rB(e,t,n){return Fe.useCallback(r=>{r&&e.mount&&e.mount(r),t&&(r?t.mount(r):t.unmount()),n&&(typeof n=="function"?n(r):Ya(n)&&(n.current=r))},[t])}function oc(e){return typeof e=="string"||Array.isArray(e)}function kf(e){return e!==null&&typeof e=="object"&&typeof e.start=="function"}const ty=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],ny=["initial",...ty];function $f(e){return kf(e.animate)||ny.some(t=>oc(e[t]))}function $$(e){return!!($f(e)||e.variants)}function sB(e,t){if($f(e)){const{initial:n,animate:r}=e;return{initial:n===!1||oc(n)?n:void 0,animate:oc(r)?r:void 0}}return e.inherit!==!1?t:{}}function iB(e){const{initial:t,animate:n}=sB(e,Fe.useContext(Sf));return Fe.useMemo(()=>({initial:t,animate:n}),[dT(t),dT(n)])}function dT(e){return Array.isArray(e)?e.join(" "):e}const pT={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},ac={};for(const e in pT)ac[e]={isEnabled:t=>pT[e].some(n=>!!t[n])};function oB(e){for(const t in e)ac[t]={...ac[t],...e[t]}}const I$=Fe.createContext({}),A$=Fe.createContext({}),aB=Symbol.for("motionComponentSymbol");function lB({preloadedFeatures:e,createVisualElement:t,useRender:n,useVisualState:r,Component:s}){e&&oB(e);function i(a,l){let u;const p={...Fe.useContext(E$),...a,layoutId:uB(a)},{isStatic:c}=p,d=iB(a),f=r(a,c);if(!c&&Cf){d.visualElement=nB(s,f,p,t);const m=Fe.useContext(A$),y=Fe.useContext(P$).strict;d.visualElement&&(u=d.visualElement.loadFeatures(p,y,e,m))}return Fe.createElement(Sf.Provider,{value:d},u&&d.visualElement?Fe.createElement(u,{visualElement:d.visualElement,...p}):null,n(s,a,rB(f,d.visualElement,l),f,c,d.visualElement))}const o=Fe.forwardRef(i);return o[aB]=s,o}function uB({layoutId:e}){const t=Fe.useContext(I$).id;return t&&e!==void 0?t+"-"+e:e}function cB(e){function t(r,s={}){return lB(e(r,s))}if(typeof Proxy>"u")return t;const n=new Map;return new Proxy(t,{get:(r,s)=>(n.has(s)||n.set(s,t(s)),n.get(s))})}const dB=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function ry(e){return typeof e!="string"||e.includes("-")?!1:!!(dB.indexOf(e)>-1||/[A-Z]/.test(e))}const Hp={};function pB(e){Object.assign(Hp,e)}const wc=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],_a=new Set(wc);function D$(e,{layout:t,layoutId:n}){return _a.has(e)||e.startsWith("origin")||(t||n!==void 0)&&(!!Hp[e]||e==="opacity")}const Ir=e=>!!(e&&e.getVelocity),fB={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},hB=wc.length;function mB(e,{enableHardwareAcceleration:t=!0,allowTransformNone:n=!0},r,s){let i="";for(let o=0;o<hB;o++){const a=wc[o];if(e[a]!==void 0){const l=fB[a]||a;i+=`${l}(${e[a]}) `}}return t&&!e.z&&(i+="translateZ(0)"),i=i.trim(),s?i=s(e,r?"":i):n&&r&&(i="none"),i}const O$=e=>t=>typeof t=="string"&&t.startsWith(e),F$=O$("--"),_B=O$("var(--"),Kp=e=>_B(e)?gB.test(e.split("/*")[0].trim()):!1,gB=/var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)$/i,yB=(e,t)=>t&&typeof e=="number"?t.transform(e):e,to=(e,t,n)=>n>t?t:n<e?e:n,bl={test:e=>typeof e=="number",parse:parseFloat,transform:e=>e},Lu={...bl,transform:e=>to(0,1,e)},zd={...bl,default:1},zu=e=>Math.round(e*1e5)/1e5,sy=/(-)?([\d]*\.?[\d])+/g,vB=/(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,wB=/^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;function Mc(e){return typeof e=="string"}const xc=e=>({test:t=>Mc(t)&&t.endsWith(e)&&t.split(" ").length===1,parse:parseFloat,transform:t=>`${t}${e}`}),Fi=xc("deg"),Qs=xc("%"),wt=xc("px"),MB=xc("vh"),xB=xc("vw"),fT={...Qs,parse:e=>Qs.parse(e)/100,transform:e=>Qs.transform(e*100)},hT={...bl,transform:Math.round},L$={borderWidth:wt,borderTopWidth:wt,borderRightWidth:wt,borderBottomWidth:wt,borderLeftWidth:wt,borderRadius:wt,radius:wt,borderTopLeftRadius:wt,borderTopRightRadius:wt,borderBottomRightRadius:wt,borderBottomLeftRadius:wt,width:wt,maxWidth:wt,height:wt,maxHeight:wt,size:wt,top:wt,right:wt,bottom:wt,left:wt,padding:wt,paddingTop:wt,paddingRight:wt,paddingBottom:wt,paddingLeft:wt,margin:wt,marginTop:wt,marginRight:wt,marginBottom:wt,marginLeft:wt,rotate:Fi,rotateX:Fi,rotateY:Fi,rotateZ:Fi,scale:zd,scaleX:zd,scaleY:zd,scaleZ:zd,skew:Fi,skewX:Fi,skewY:Fi,distance:wt,translateX:wt,translateY:wt,translateZ:wt,x:wt,y:wt,z:wt,perspective:wt,transformPerspective:wt,opacity:Lu,originX:fT,originY:fT,originZ:wt,zIndex:hT,fillOpacity:Lu,strokeOpacity:Lu,numOctaves:hT};function iy(e,t,n,r){const{style:s,vars:i,transform:o,transformOrigin:a}=e;let l=!1,u=!1,p=!0;for(const c in t){const d=t[c];if(F$(c)){i[c]=d;continue}const f=L$[c],m=yB(d,f);if(_a.has(c)){if(l=!0,o[c]=m,!p)continue;d!==(f.default||0)&&(p=!1)}else c.startsWith("origin")?(u=!0,a[c]=m):s[c]=m}if(t.transform||(l||r?s.transform=mB(e.transform,n,p,r):s.transform&&(s.transform="none")),u){const{originX:c="50%",originY:d="50%",originZ:f=0}=a;s.transformOrigin=`${c} ${d} ${f}`}}const oy=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function z$(e,t,n){for(const r in t)!Ir(t[r])&&!D$(r,n)&&(e[r]=t[r])}function bB({transformTemplate:e},t,n){return Fe.useMemo(()=>{const r=oy();return iy(r,t,{enableHardwareAcceleration:!n},e),Object.assign({},r.vars,r.style)},[t])}function TB(e,t,n){const r=e.style||{},s={};return z$(s,r,e),Object.assign(s,bB(e,t,n)),s}function EB(e,t,n){const r={},s=TB(e,t,n);return e.drag&&e.dragListener!==!1&&(r.draggable=!1,s.userSelect=s.WebkitUserSelect=s.WebkitTouchCallout="none",s.touchAction=e.drag===!0?"none":`pan-${e.drag==="x"?"y":"x"}`),e.tabIndex===void 0&&(e.onTap||e.onTapStart||e.whileTap)&&(r.tabIndex=0),r.style=s,r}const PB=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function qp(e){return e.startsWith("while")||e.startsWith("drag")&&e!=="draggable"||e.startsWith("layout")||e.startsWith("onTap")||e.startsWith("onPan")||e.startsWith("onLayout")||PB.has(e)}let R$=e=>!qp(e);function SB(e){e&&(R$=t=>t.startsWith("on")?!qp(t):e(t))}try{SB(require("@emotion/is-prop-valid").default)}catch{}function CB(e,t,n){const r={};for(const s in e)s==="values"&&typeof e.values=="object"||(R$(s)||n===!0&&qp(s)||!t&&!qp(s)||e.draggable&&s.startsWith("onDrag"))&&(r[s]=e[s]);return r}function mT(e,t,n){return typeof e=="string"?e:wt.transform(t+n*e)}function kB(e,t,n){const r=mT(t,e.x,e.width),s=mT(n,e.y,e.height);return`${r} ${s}`}const $B={offset:"stroke-dashoffset",array:"stroke-dasharray"},IB={offset:"strokeDashoffset",array:"strokeDasharray"};function AB(e,t,n=1,r=0,s=!0){e.pathLength=1;const i=s?$B:IB;e[i.offset]=wt.transform(-r);const o=wt.transform(t),a=wt.transform(n);e[i.array]=`${o} ${a}`}function ay(e,{attrX:t,attrY:n,attrScale:r,originX:s,originY:i,pathLength:o,pathSpacing:a=1,pathOffset:l=0,...u},p,c,d){if(iy(e,u,p,d),c){e.style.viewBox&&(e.attrs.viewBox=e.style.viewBox);return}e.attrs=e.style,e.style={};const{attrs:f,style:m,dimensions:y}=e;f.transform&&(y&&(m.transform=f.transform),delete f.transform),y&&(s!==void 0||i!==void 0||m.transform)&&(m.transformOrigin=kB(y,s!==void 0?s:.5,i!==void 0?i:.5)),t!==void 0&&(f.x=t),n!==void 0&&(f.y=n),r!==void 0&&(f.scale=r),o!==void 0&&AB(f,o,a,l,!1)}const B$=()=>({...oy(),attrs:{}}),ly=e=>typeof e=="string"&&e.toLowerCase()==="svg";function DB(e,t,n,r){const s=Fe.useMemo(()=>{const i=B$();return ay(i,t,{enableHardwareAcceleration:!1},ly(r),e.transformTemplate),{...i.attrs,style:{...i.style}}},[t]);if(e.style){const i={};z$(i,e.style,e),s.style={...i,...s.style}}return s}function OB(e=!1){return(n,r,s,{latestValues:i},o)=>{const l=(ry(n)?DB:EB)(r,i,o,n),u=CB(r,typeof n=="string",e),p=n!==Fe.Fragment?{...u,...l,ref:s}:{},{children:c}=r,d=Fe.useMemo(()=>Ir(c)?c.get():c,[c]);return Fe.createElement(n,{...p,children:d})}}function N$(e,{style:t,vars:n},r,s){Object.assign(e.style,t,s&&s.getProjectionStyles(r));for(const i in n)e.style.setProperty(i,n[i])}const j$=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function V$(e,t,n,r){N$(e,t,void 0,r);for(const s in t.attrs)e.setAttribute(j$.has(s)?s:Z0(s),t.attrs[s])}function uy(e,t){const{style:n}=e,r={};for(const s in n)(Ir(n[s])||t.style&&Ir(t.style[s])||D$(s,e))&&(r[s]=n[s]);return r}function U$(e,t){const n=uy(e,t);for(const r in e)if(Ir(e[r])||Ir(t[r])){const s=wc.indexOf(r)!==-1?"attr"+r.charAt(0).toUpperCase()+r.substring(1):r;n[s]=e[r]}return n}function cy(e,t,n,r={},s={}){return typeof t=="function"&&(t=t(n!==void 0?n:e.custom,r,s)),typeof t=="string"&&(t=e.variants&&e.variants[t]),typeof t=="function"&&(t=t(n!==void 0?n:e.custom,r,s)),t}function FB(e){const t=Fe.useRef(null);return t.current===null&&(t.current=e()),t.current}const Qp=e=>Array.isArray(e),LB=e=>!!(e&&typeof e=="object"&&e.mix&&e.toValue),zB=e=>Qp(e)?e[e.length-1]||0:e;function fp(e){const t=Ir(e)?e.get():e;return LB(t)?t.toValue():t}function RB({scrapeMotionValuesFromProps:e,createRenderState:t,onMount:n},r,s,i){const o={latestValues:BB(r,s,i,e),renderState:t()};return n&&(o.mount=a=>n(r,a,o)),o}const W$=e=>(t,n)=>{const r=Fe.useContext(Sf),s=Fe.useContext(J0),i=()=>RB(e,t,r,s);return n?i():FB(i)};function BB(e,t,n,r){const s={},i=r(e,{});for(const d in i)s[d]=fp(i[d]);let{initial:o,animate:a}=e;const l=$f(e),u=$$(e);t&&u&&!l&&e.inherit!==!1&&(o===void 0&&(o=t.initial),a===void 0&&(a=t.animate));let p=n?n.initial===!1:!1;p=p||o===!1;const c=p?a:o;return c&&typeof c!="boolean"&&!kf(c)&&(Array.isArray(c)?c:[c]).forEach(f=>{const m=cy(e,f);if(!m)return;const{transitionEnd:y,transition:C,..._}=m;for(const h in _){let w=_[h];if(Array.isArray(w)){const M=p?w.length-1:0;w=w[M]}w!==null&&(s[h]=w)}for(const h in y)s[h]=y[h]}),s}const zn=e=>e,{schedule:gn,cancel:yi,state:rr,steps:gm}=k$(typeof requestAnimationFrame<"u"?requestAnimationFrame:zn,!0),NB={useVisualState:W$({scrapeMotionValuesFromProps:U$,createRenderState:B$,onMount:(e,t,{renderState:n,latestValues:r})=>{gn.read(()=>{try{n.dimensions=typeof t.getBBox=="function"?t.getBBox():t.getBoundingClientRect()}catch{n.dimensions={x:0,y:0,width:0,height:0}}}),gn.render(()=>{ay(n,r,{enableHardwareAcceleration:!1},ly(t.tagName),e.transformTemplate),V$(t,n)})}})},jB={useVisualState:W$({scrapeMotionValuesFromProps:uy,createRenderState:oy})};function VB(e,{forwardMotionProps:t=!1},n,r){return{...ry(e)?NB:jB,preloadedFeatures:n,useRender:OB(t),createVisualElement:r,Component:e}}function ui(e,t,n,r={passive:!0}){return e.addEventListener(t,n,r),()=>e.removeEventListener(t,n)}const G$=e=>e.pointerType==="mouse"?typeof e.button!="number"||e.button<=0:e.isPrimary!==!1;function If(e,t="page"){return{point:{x:e[t+"X"],y:e[t+"Y"]}}}const UB=e=>t=>G$(t)&&e(t,If(t));function di(e,t,n,r){return ui(e,t,UB(n),r)}const WB=(e,t)=>n=>t(e(n)),pi=(...e)=>e.reduce(WB);function H$(e){let t=null;return()=>{const n=()=>{t=null};return t===null?(t=e,n):!1}}const _T=H$("dragHorizontal"),gT=H$("dragVertical");function K$(e){let t=!1;if(e==="y")t=gT();else if(e==="x")t=_T();else{const n=_T(),r=gT();n&&r?t=()=>{n(),r()}:(n&&n(),r&&r())}return t}function q$(){const e=K$(!0);return e?(e(),!1):!0}class ao{constructor(t){this.isMounted=!1,this.node=t}update(){}}function yT(e,t){const n="pointer"+(t?"enter":"leave"),r="onHover"+(t?"Start":"End"),s=(i,o)=>{if(i.pointerType==="touch"||q$())return;const a=e.getProps();e.animationState&&a.whileHover&&e.animationState.setActive("whileHover",t),a[r]&&gn.update(()=>a[r](i,o))};return di(e.current,n,s,{passive:!e.getProps()[r]})}class GB extends ao{mount(){this.unmount=pi(yT(this.node,!0),yT(this.node,!1))}unmount(){}}class HB extends ao{constructor(){super(...arguments),this.isActive=!1}onFocus(){let t=!1;try{t=this.node.current.matches(":focus-visible")}catch{t=!0}!t||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=pi(ui(this.node.current,"focus",()=>this.onFocus()),ui(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}const Q$=(e,t)=>t?e===t?!0:Q$(e,t.parentElement):!1;function ym(e,t){if(!t)return;const n=new PointerEvent("pointer"+e);t(n,If(n))}class KB extends ao{constructor(){super(...arguments),this.removeStartListeners=zn,this.removeEndListeners=zn,this.removeAccessibleListeners=zn,this.startPointerPress=(t,n)=>{if(this.isPressing)return;this.removeEndListeners();const r=this.node.getProps(),i=di(window,"pointerup",(a,l)=>{if(!this.checkPressEnd())return;const{onTap:u,onTapCancel:p,globalTapTarget:c}=this.node.getProps();gn.update(()=>{!c&&!Q$(this.node.current,a.target)?p&&p(a,l):u&&u(a,l)})},{passive:!(r.onTap||r.onPointerUp)}),o=di(window,"pointercancel",(a,l)=>this.cancelPress(a,l),{passive:!(r.onTapCancel||r.onPointerCancel)});this.removeEndListeners=pi(i,o),this.startPress(t,n)},this.startAccessiblePress=()=>{const t=i=>{if(i.key!=="Enter"||this.isPressing)return;const o=a=>{a.key!=="Enter"||!this.checkPressEnd()||ym("up",(l,u)=>{const{onTap:p}=this.node.getProps();p&&gn.update(()=>p(l,u))})};this.removeEndListeners(),this.removeEndListeners=ui(this.node.current,"keyup",o),ym("down",(a,l)=>{this.startPress(a,l)})},n=ui(this.node.current,"keydown",t),r=()=>{this.isPressing&&ym("cancel",(i,o)=>this.cancelPress(i,o))},s=ui(this.node.current,"blur",r);this.removeAccessibleListeners=pi(n,s)}}startPress(t,n){this.isPressing=!0;const{onTapStart:r,whileTap:s}=this.node.getProps();s&&this.node.animationState&&this.node.animationState.setActive("whileTap",!0),r&&gn.update(()=>r(t,n))}checkPressEnd(){return this.removeEndListeners(),this.isPressing=!1,this.node.getProps().whileTap&&this.node.animationState&&this.node.animationState.setActive("whileTap",!1),!q$()}cancelPress(t,n){if(!this.checkPressEnd())return;const{onTapCancel:r}=this.node.getProps();r&&gn.update(()=>r(t,n))}mount(){const t=this.node.getProps(),n=di(t.globalTapTarget?window:this.node.current,"pointerdown",this.startPointerPress,{passive:!(t.onTapStart||t.onPointerStart)}),r=ui(this.node.current,"focus",this.startAccessiblePress);this.removeStartListeners=pi(n,r)}unmount(){this.removeStartListeners(),this.removeEndListeners(),this.removeAccessibleListeners()}}const Tg=new WeakMap,vm=new WeakMap,qB=e=>{const t=Tg.get(e.target);t&&t(e)},QB=e=>{e.forEach(qB)};function XB({root:e,...t}){const n=e||document;vm.has(n)||vm.set(n,{});const r=vm.get(n),s=JSON.stringify(t);return r[s]||(r[s]=new IntersectionObserver(QB,{root:e,...t})),r[s]}function YB(e,t,n){const r=XB(t);return Tg.set(e,n),r.observe(e),()=>{Tg.delete(e),r.unobserve(e)}}const JB={some:0,all:1};class ZB extends ao{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:t={}}=this.node.getProps(),{root:n,margin:r,amount:s="some",once:i}=t,o={root:n?n.current:void 0,rootMargin:r,threshold:typeof s=="number"?s:JB[s]},a=l=>{const{isIntersecting:u}=l;if(this.isInView===u||(this.isInView=u,i&&!u&&this.hasEnteredView))return;u&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",u);const{onViewportEnter:p,onViewportLeave:c}=this.node.getProps(),d=u?p:c;d&&d(l)};return YB(this.node.current,o,a)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:t,prevProps:n}=this.node;["amount","margin","root"].some(eN(t,n))&&this.startObserver()}unmount(){}}function eN({viewport:e={}},{viewport:t={}}={}){return n=>e[n]!==t[n]}const tN={inView:{Feature:ZB},tap:{Feature:KB},focus:{Feature:HB},hover:{Feature:GB}};function X$(e,t){if(!Array.isArray(t))return!1;const n=t.length;if(n!==e.length)return!1;for(let r=0;r<n;r++)if(t[r]!==e[r])return!1;return!0}function nN(e){const t={};return e.values.forEach((n,r)=>t[r]=n.get()),t}function rN(e){const t={};return e.values.forEach((n,r)=>t[r]=n.getVelocity()),t}function Af(e,t,n){const r=e.getProps();return cy(r,t,n!==void 0?n:r.custom,nN(e),rN(e))}let Xp=zn;const ta=e=>e*1e3,fi=e=>e/1e3,sN={current:!1},Y$=e=>Array.isArray(e)&&typeof e[0]=="number";function J$(e){return!!(!e||typeof e=="string"&&Z$[e]||Y$(e)||Array.isArray(e)&&e.every(J$))}const xu=([e,t,n,r])=>`cubic-bezier(${e}, ${t}, ${n}, ${r})`,Z$={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:xu([0,.65,.55,1]),circOut:xu([.55,0,1,.45]),backIn:xu([.31,.01,.66,-.59]),backOut:xu([.33,1.53,.69,.99])};function eI(e){if(e)return Y$(e)?xu(e):Array.isArray(e)?e.map(eI):Z$[e]}function iN(e,t,n,{delay:r=0,duration:s,repeat:i=0,repeatType:o="loop",ease:a,times:l}={}){const u={[t]:n};l&&(u.offset=l);const p=eI(a);return Array.isArray(p)&&(u.easing=p),e.animate(u,{delay:r,duration:s,easing:Array.isArray(p)?"linear":p,fill:"both",iterations:i+1,direction:o==="reverse"?"alternate":"normal"})}function oN(e,{repeat:t,repeatType:n="loop"}){const r=t&&n!=="loop"&&t%2===1?0:e.length-1;return e[r]}const tI=(e,t,n)=>(((1-3*n+3*t)*e+(3*n-6*t))*e+3*t)*e,aN=1e-7,lN=12;function uN(e,t,n,r,s){let i,o,a=0;do o=t+(n-t)/2,i=tI(o,r,s)-e,i>0?n=o:t=o;while(Math.abs(i)>aN&&++a<lN);return o}function bc(e,t,n,r){if(e===t&&n===r)return zn;const s=i=>uN(i,0,1,e,n);return i=>i===0||i===1?i:tI(s(i),t,r)}const cN=bc(.42,0,1,1),dN=bc(0,0,.58,1),nI=bc(.42,0,.58,1),pN=e=>Array.isArray(e)&&typeof e[0]!="number",rI=e=>t=>t<=.5?e(2*t)/2:(2-e(2*(1-t)))/2,sI=e=>t=>1-e(1-t),dy=e=>1-Math.sin(Math.acos(e)),iI=sI(dy),fN=rI(dy),oI=bc(.33,1.53,.69,.99),py=sI(oI),hN=rI(py),mN=e=>(e*=2)<1?.5*py(e):.5*(2-Math.pow(2,-10*(e-1))),vT={linear:zn,easeIn:cN,easeInOut:nI,easeOut:dN,circIn:dy,circInOut:fN,circOut:iI,backIn:py,backInOut:hN,backOut:oI,anticipate:mN},wT=e=>{if(Array.isArray(e)){Xp(e.length===4);const[t,n,r,s]=e;return bc(t,n,r,s)}else if(typeof e=="string")return Xp(vT[e]!==void 0),vT[e];return e},lc=(e,t,n)=>{const r=t-e;return r===0?1:(n-e)/r},_n=(e,t,n)=>e+(t-e)*n;function wm(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+(t-e)*6*n:n<1/2?t:n<2/3?e+(t-e)*(2/3-n)*6:e}function _N({hue:e,saturation:t,lightness:n,alpha:r}){e/=360,t/=100,n/=100;let s=0,i=0,o=0;if(!t)s=i=o=n;else{const a=n<.5?n*(1+t):n+t-n*t,l=2*n-a;s=wm(l,a,e+1/3),i=wm(l,a,e),o=wm(l,a,e-1/3)}return{red:Math.round(s*255),green:Math.round(i*255),blue:Math.round(o*255),alpha:r}}const fy=(e,t)=>n=>!!(Mc(n)&&wB.test(n)&&n.startsWith(e)||t&&Object.prototype.hasOwnProperty.call(n,t)),aI=(e,t,n)=>r=>{if(!Mc(r))return r;const[s,i,o,a]=r.match(sy);return{[e]:parseFloat(s),[t]:parseFloat(i),[n]:parseFloat(o),alpha:a!==void 0?parseFloat(a):1}},gN=e=>to(0,255,e),Mm={...bl,transform:e=>Math.round(gN(e))},Yo={test:fy("rgb","red"),parse:aI("red","green","blue"),transform:({red:e,green:t,blue:n,alpha:r=1})=>"rgba("+Mm.transform(e)+", "+Mm.transform(t)+", "+Mm.transform(n)+", "+zu(Lu.transform(r))+")"};function yN(e){let t="",n="",r="",s="";return e.length>5?(t=e.substring(1,3),n=e.substring(3,5),r=e.substring(5,7),s=e.substring(7,9)):(t=e.substring(1,2),n=e.substring(2,3),r=e.substring(3,4),s=e.substring(4,5),t+=t,n+=n,r+=r,s+=s),{red:parseInt(t,16),green:parseInt(n,16),blue:parseInt(r,16),alpha:s?parseInt(s,16)/255:1}}const Eg={test:fy("#"),parse:yN,transform:Yo.transform},Ja={test:fy("hsl","hue"),parse:aI("hue","saturation","lightness"),transform:({hue:e,saturation:t,lightness:n,alpha:r=1})=>"hsla("+Math.round(e)+", "+Qs.transform(zu(t))+", "+Qs.transform(zu(n))+", "+zu(Lu.transform(r))+")"},xm=(e,t,n)=>{const r=e*e,s=n*(t*t-r)+r;return s<0?0:Math.sqrt(s)},vN=[Eg,Yo,Ja],wN=e=>vN.find(t=>t.test(e));function MT(e){const t=wN(e);let n=t.parse(e);return t===Ja&&(n=_N(n)),n}const xT=(e,t)=>{const n=MT(e),r=MT(t),s={...n};return i=>(s.red=xm(n.red,r.red,i),s.green=xm(n.green,r.green,i),s.blue=xm(n.blue,r.blue,i),s.alpha=_n(n.alpha,r.alpha,i),Yo.transform(s))},pr={test:e=>Yo.test(e)||Eg.test(e)||Ja.test(e),parse:e=>Yo.test(e)?Yo.parse(e):Ja.test(e)?Ja.parse(e):Eg.parse(e),transform:e=>Mc(e)?e:e.hasOwnProperty("red")?Yo.transform(e):Ja.transform(e)};function MN(e){var t,n;return isNaN(e)&&Mc(e)&&(((t=e.match(sy))===null||t===void 0?void 0:t.length)||0)+(((n=e.match(vB))===null||n===void 0?void 0:n.length)||0)>0}const lI="number",uI="color",xN="var",bN="var(",bT="${}",TT=/(var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\))|(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))|((-)?([\d]*\.?[\d])+)/gi;function Yp(e){const t=e.toString(),n=t.match(TT)||[],r=[],s={color:[],number:[],var:[]},i=[];for(let l=0;l<n.length;l++){const u=n[l];pr.test(u)?(s.color.push(l),i.push(uI),r.push(pr.parse(u))):u.startsWith(bN)?(s.var.push(l),i.push(xN),r.push(u)):(s.number.push(l),i.push(lI),r.push(parseFloat(u)))}const a=t.replace(TT,bT).split(bT);return{values:r,split:a,indexes:s,types:i}}function cI(e){return Yp(e).values}function dI(e){const{split:t,types:n}=Yp(e),r=t.length;return s=>{let i="";for(let o=0;o<r;o++)if(i+=t[o],s[o]!==void 0){const a=n[o];a===lI?i+=zu(s[o]):a===uI?i+=pr.transform(s[o]):i+=s[o]}return i}}const TN=e=>typeof e=="number"?0:e;function EN(e){const t=cI(e);return dI(e)(t.map(TN))}const no={test:MN,parse:cI,createTransformer:dI,getAnimatableNone:EN};function Pg(e,t){return n=>n>0?t:e}function PN(e,t){return n=>_n(e,t,n)}function hy(e){return typeof e=="number"?PN:typeof e=="string"?Kp(e)?Pg:pr.test(e)?xT:kN:Array.isArray(e)?pI:typeof e=="object"?pr.test(e)?xT:SN:Pg}function pI(e,t){const n=[...e],r=n.length,s=e.map((i,o)=>hy(i)(i,t[o]));return i=>{for(let o=0;o<r;o++)n[o]=s[o](i);return n}}function SN(e,t){const n={...e,...t},r={};for(const s in n)e[s]!==void 0&&t[s]!==void 0&&(r[s]=hy(e[s])(e[s],t[s]));return s=>{for(const i in r)n[i]=r[i](s);return n}}function CN(e,t){var n;const r=[],s={color:0,var:0,number:0};for(let i=0;i<t.values.length;i++){const o=t.types[i],a=e.indexes[o][s[o]],l=(n=e.values[a])!==null&&n!==void 0?n:0;r[i]=l,s[o]++}return r}const kN=(e,t)=>{const n=no.createTransformer(t),r=Yp(e),s=Yp(t);return r.indexes.var.length===s.indexes.var.length&&r.indexes.color.length===s.indexes.color.length&&r.indexes.number.length>=s.indexes.number.length?pi(pI(CN(r,s),s.values),n):Pg(e,t)};function fI(e,t,n){return typeof e=="number"&&typeof t=="number"&&typeof n=="number"?_n(e,t,n):hy(e)(e,t)}function $N(e,t,n){const r=[],s=n||fI,i=e.length-1;for(let o=0;o<i;o++){let a=s(e[o],e[o+1]);if(t){const l=Array.isArray(t)?t[o]||zn:t;a=pi(l,a)}r.push(a)}return r}function IN(e,t,{clamp:n=!0,ease:r,mixer:s}={}){const i=e.length;if(Xp(i===t.length),i===1)return()=>t[0];e[0]>e[i-1]&&(e=[...e].reverse(),t=[...t].reverse());const o=$N(t,r,s),a=o.length,l=u=>{let p=0;if(a>1)for(;p<e.length-2&&!(u<e[p+1]);p++);const c=lc(e[p],e[p+1],u);return o[p](c)};return n?u=>l(to(e[0],e[i-1],u)):l}function AN(e,t){const n=e[e.length-1];for(let r=1;r<=t;r++){const s=lc(0,t,r);e.push(_n(n,1,s))}}function DN(e){const t=[0];return AN(t,e.length-1),t}function ON(e,t){return e.map(n=>n*t)}function FN(e,t){return e.map(()=>t||nI).splice(0,e.length-1)}function Jp({duration:e=300,keyframes:t,times:n,ease:r="easeInOut"}){const s=pN(r)?r.map(wT):wT(r),i={done:!1,value:t[0]},o=ON(n&&n.length===t.length?n:DN(t),e),a=IN(o,t,{ease:Array.isArray(s)?s:FN(t,s)});return{calculatedDuration:e,next:l=>(i.value=a(l),i.done=l>=e,i)}}function hI(e,t){return t?e*(1e3/t):0}const LN=5;function mI(e,t,n){const r=Math.max(t-LN,0);return hI(n-e(r),t-r)}const bm=.001,zN=.01,RN=10,BN=.05,NN=1;function jN({duration:e=800,bounce:t=.25,velocity:n=0,mass:r=1}){let s,i,o=1-t;o=to(BN,NN,o),e=to(zN,RN,fi(e)),o<1?(s=u=>{const p=u*o,c=p*e,d=p-n,f=Sg(u,o),m=Math.exp(-c);return bm-d/f*m},i=u=>{const c=u*o*e,d=c*n+n,f=Math.pow(o,2)*Math.pow(u,2)*e,m=Math.exp(-c),y=Sg(Math.pow(u,2),o);return(-s(u)+bm>0?-1:1)*((d-f)*m)/y}):(s=u=>{const p=Math.exp(-u*e),c=(u-n)*e+1;return-bm+p*c},i=u=>{const p=Math.exp(-u*e),c=(n-u)*(e*e);return p*c});const a=5/e,l=UN(s,i,a);if(e=ta(e),isNaN(l))return{stiffness:100,damping:10,duration:e};{const u=Math.pow(l,2)*r;return{stiffness:u,damping:o*2*Math.sqrt(r*u),duration:e}}}const VN=12;function UN(e,t,n){let r=n;for(let s=1;s<VN;s++)r=r-e(r)/t(r);return r}function Sg(e,t){return e*Math.sqrt(1-t*t)}const WN=["duration","bounce"],GN=["stiffness","damping","mass"];function ET(e,t){return t.some(n=>e[n]!==void 0)}function HN(e){let t={velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1,...e};if(!ET(e,GN)&&ET(e,WN)){const n=jN(e);t={...t,...n,mass:1},t.isResolvedFromDuration=!0}return t}function _I({keyframes:e,restDelta:t,restSpeed:n,...r}){const s=e[0],i=e[e.length-1],o={done:!1,value:s},{stiffness:a,damping:l,mass:u,duration:p,velocity:c,isResolvedFromDuration:d}=HN({...r,velocity:-fi(r.velocity||0)}),f=c||0,m=l/(2*Math.sqrt(a*u)),y=i-s,C=fi(Math.sqrt(a/u)),_=Math.abs(y)<5;n||(n=_?.01:2),t||(t=_?.005:.5);let h;if(m<1){const w=Sg(C,m);h=M=>{const x=Math.exp(-m*C*M);return i-x*((f+m*C*y)/w*Math.sin(w*M)+y*Math.cos(w*M))}}else if(m===1)h=w=>i-Math.exp(-C*w)*(y+(f+C*y)*w);else{const w=C*Math.sqrt(m*m-1);h=M=>{const x=Math.exp(-m*C*M),b=Math.min(w*M,300);return i-x*((f+m*C*y)*Math.sinh(b)+w*y*Math.cosh(b))/w}}return{calculatedDuration:d&&p||null,next:w=>{const M=h(w);if(d)o.done=w>=p;else{let x=f;w!==0&&(m<1?x=mI(h,w,M):x=0);const b=Math.abs(x)<=n,T=Math.abs(i-M)<=t;o.done=b&&T}return o.value=o.done?i:M,o}}}function PT({keyframes:e,velocity:t=0,power:n=.8,timeConstant:r=325,bounceDamping:s=10,bounceStiffness:i=500,modifyTarget:o,min:a,max:l,restDelta:u=.5,restSpeed:p}){const c=e[0],d={done:!1,value:c},f=S=>a!==void 0&&S<a||l!==void 0&&S>l,m=S=>a===void 0?l:l===void 0||Math.abs(a-S)<Math.abs(l-S)?a:l;let y=n*t;const C=c+y,_=o===void 0?C:o(C);_!==C&&(y=_-c);const h=S=>-y*Math.exp(-S/r),w=S=>_+h(S),M=S=>{const $=h(S),O=w(S);d.done=Math.abs($)<=u,d.value=d.done?_:O};let x,b;const T=S=>{f(d.value)&&(x=S,b=_I({keyframes:[d.value,m(d.value)],velocity:mI(w,S,d.value),damping:s,stiffness:i,restDelta:u,restSpeed:p}))};return T(0),{calculatedDuration:null,next:S=>{let $=!1;return!b&&x===void 0&&($=!0,M(S),T(S)),x!==void 0&&S>x?b.next(S-x):(!$&&M(S),d)}}}let hp;function KN(){hp=void 0}const na={now:()=>(hp===void 0&&na.set(rr.isProcessing||C$.useManualTiming?rr.timestamp:performance.now()),hp),set:e=>{hp=e,queueMicrotask(KN)}},qN=e=>{const t=({timestamp:n})=>e(n);return{start:()=>gn.update(t,!0),stop:()=>yi(t),now:()=>rr.isProcessing?rr.timestamp:na.now()}},ST=2e4;function CT(e){let t=0;const n=50;let r=e.next(t);for(;!r.done&&t<ST;)t+=n,r=e.next(t);return t>=ST?1/0:t}const QN={decay:PT,inertia:PT,tween:Jp,keyframes:Jp,spring:_I},XN=e=>e/100;function Zp({autoplay:e=!0,delay:t=0,driver:n=qN,keyframes:r,type:s="keyframes",repeat:i=0,repeatDelay:o=0,repeatType:a="loop",onPlay:l,onStop:u,onComplete:p,onUpdate:c,...d}){let f=1,m=!1,y,C;const _=()=>{C=new Promise(F=>{y=F})};_();let h;const w=QN[s]||Jp;let M;w!==Jp&&typeof r[0]!="number"&&(M=pi(XN,fI(r[0],r[1])),r=[0,100]);const x=w({...d,keyframes:r});let b;a==="mirror"&&(b=w({...d,keyframes:[...r].reverse(),velocity:-(d.velocity||0)}));let T="idle",S=null,$=null,O=null;x.calculatedDuration===null&&i&&(x.calculatedDuration=CT(x));const{calculatedDuration:G}=x;let H=1/0,N=1/0;G!==null&&(H=G+o,N=H*(i+1)-o);let J=0;const q=F=>{if($===null)return;f>0&&($=Math.min($,F)),f<0&&($=Math.min(F-N/f,$)),S!==null?J=S:J=Math.round(F-$)*f;const I=J-t*(f>=0?1:-1),V=f>=0?I<0:I>N;J=Math.max(I,0),T==="finished"&&S===null&&(J=N);let ee=J,pe=x;if(i){const Re=Math.min(J,N)/H;let ye=Math.floor(Re),Q=Re%1;!Q&&Re>=1&&(Q=1),Q===1&&ye--,ye=Math.min(ye,i+1),!!(ye%2)&&(a==="reverse"?(Q=1-Q,o&&(Q-=o/H)):a==="mirror"&&(pe=b)),ee=to(0,1,Q)*H}const Z=V?{done:!1,value:r[0]}:pe.next(ee);M&&(Z.value=M(Z.value));let{done:de}=Z;!V&&G!==null&&(de=f>=0?J>=N:J<=0);const Se=S===null&&(T==="finished"||T==="running"&&de);return c&&c(Z.value),Se&&K(),Z},X=()=>{h&&h.stop(),h=void 0},Y=()=>{T="idle",X(),y(),_(),$=O=null},K=()=>{T="finished",p&&p(),X(),y()},oe=()=>{if(m)return;h||(h=n(q));const F=h.now();l&&l(),S!==null?$=F-S:(!$||T==="finished")&&($=F),T==="finished"&&_(),O=$,S=null,T="running",h.start()};e&&oe();const se={then(F,I){return C.then(F,I)},get time(){return fi(J)},set time(F){F=ta(F),J=F,S!==null||!h||f===0?S=F:$=h.now()-F/f},get duration(){const F=x.calculatedDuration===null?CT(x):x.calculatedDuration;return fi(F)},get speed(){return f},set speed(F){F===f||!h||(f=F,se.time=fi(J))},get state(){return T},play:oe,pause:()=>{T="paused",S=J},stop:()=>{m=!0,T!=="idle"&&(T="idle",u&&u(),Y())},cancel:()=>{O!==null&&q(O),Y()},complete:()=>{T="finished"},sample:F=>($=0,q(F))};return se}function YN(e){let t;return()=>(t===void 0&&(t=e()),t)}const JN=YN(()=>Object.hasOwnProperty.call(Element.prototype,"animate")),ZN=new Set(["opacity","clipPath","filter","transform"]),Rd=10,ej=2e4,tj=(e,t)=>t.type==="spring"||e==="backgroundColor"||!J$(t.ease);function nj(e,t,{onUpdate:n,onComplete:r,...s}){if(!(JN()&&ZN.has(t)&&!s.repeatDelay&&s.repeatType!=="mirror"&&s.damping!==0&&s.type!=="inertia"))return!1;let o=!1,a,l,u=!1;const p=()=>{l=new Promise(w=>{a=w})};p();let{keyframes:c,duration:d=300,ease:f,times:m}=s;if(tj(t,s)){const w=Zp({...s,repeat:0,delay:0});let M={done:!1,value:c[0]};const x=[];let b=0;for(;!M.done&&b<ej;)M=w.sample(b),x.push(M.value),b+=Rd;m=void 0,c=x,d=b-Rd,f="linear"}const y=iN(e.owner.current,t,c,{...s,duration:d,ease:f,times:m}),C=()=>{u=!1,y.cancel()},_=()=>{u=!0,gn.update(C),a(),p()};return y.onfinish=()=>{u||(e.set(oN(c,s)),r&&r(),_())},{then(w,M){return l.then(w,M)},attachTimeline(w){return y.timeline=w,y.onfinish=null,zn},get time(){return fi(y.currentTime||0)},set time(w){y.currentTime=ta(w)},get speed(){return y.playbackRate},set speed(w){y.playbackRate=w},get duration(){return fi(d)},play:()=>{o||(y.play(),yi(C))},pause:()=>y.pause(),stop:()=>{if(o=!0,y.playState==="idle")return;const{currentTime:w}=y;if(w){const M=Zp({...s,autoplay:!1});e.setWithVelocity(M.sample(w-Rd).value,M.sample(w).value,Rd)}_()},complete:()=>{u||y.finish()},cancel:_}}function rj({keyframes:e,delay:t,onUpdate:n,onComplete:r}){const s=()=>(n&&n(e[e.length-1]),r&&r(),{time:0,speed:1,duration:0,play:zn,pause:zn,stop:zn,then:i=>(i(),Promise.resolve()),cancel:zn,complete:zn});return t?Zp({keyframes:[0,1],duration:0,delay:t,onComplete:s}):s()}const sj={type:"spring",stiffness:500,damping:25,restSpeed:10},ij=e=>({type:"spring",stiffness:550,damping:e===0?2*Math.sqrt(550):30,restSpeed:10}),oj={type:"keyframes",duration:.8},aj={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},lj=(e,{keyframes:t})=>t.length>2?oj:_a.has(e)?e.startsWith("scale")?ij(t[1]):sj:aj,Cg=(e,t)=>e==="zIndex"?!1:!!(typeof t=="number"||Array.isArray(t)||typeof t=="string"&&(no.test(t)||t==="0")&&!t.startsWith("url(")),uj=new Set(["brightness","contrast","saturate","opacity"]);function cj(e){const[t,n]=e.slice(0,-1).split("(");if(t==="drop-shadow")return e;const[r]=n.match(sy)||[];if(!r)return e;const s=n.replace(r,"");let i=uj.has(t)?1:0;return r!==n&&(i*=100),t+"("+i+s+")"}const dj=/([a-z-]*)\(.*?\)/g,kg={...no,getAnimatableNone:e=>{const t=e.match(dj);return t?t.map(cj).join(" "):e}},pj={...L$,color:pr,backgroundColor:pr,outlineColor:pr,fill:pr,stroke:pr,borderColor:pr,borderTopColor:pr,borderRightColor:pr,borderBottomColor:pr,borderLeftColor:pr,filter:kg,WebkitFilter:kg},my=e=>pj[e];function gI(e,t){let n=my(e);return n!==kg&&(n=no),n.getAnimatableNone?n.getAnimatableNone(t):void 0}const yI=e=>/^0[^.\s]+$/.test(e);function fj(e){if(typeof e=="number")return e===0;if(e!==null)return e==="none"||e==="0"||yI(e)}function hj(e,t,n,r){const s=Cg(t,n);let i;Array.isArray(n)?i=[...n]:i=[null,n];const o=r.from!==void 0?r.from:e.get();let a;const l=[];for(let u=0;u<i.length;u++)i[u]===null&&(i[u]=u===0?o:i[u-1]),fj(i[u])&&l.push(u),typeof i[u]=="string"&&i[u]!=="none"&&i[u]!=="0"&&(a=i[u]);if(s&&l.length&&a)for(let u=0;u<l.length;u++){const p=l[u];i[p]=gI(t,a)}return i}function mj({when:e,delay:t,delayChildren:n,staggerChildren:r,staggerDirection:s,repeat:i,repeatType:o,repeatDelay:a,from:l,elapsed:u,...p}){return!!Object.keys(p).length}function _y(e,t){return e[t]||e.default||e}const gy=(e,t,n,r={})=>s=>{const i=_y(r,e)||{},o=i.delay||r.delay||0;let{elapsed:a=0}=r;a=a-ta(o);const l=hj(t,e,n,i),u=l[0],p=l[l.length-1],c=Cg(e,u),d=Cg(e,p);let f={keyframes:l,velocity:t.getVelocity(),ease:"easeOut",...i,delay:-a,onUpdate:m=>{t.set(m),i.onUpdate&&i.onUpdate(m)},onComplete:()=>{s(),i.onComplete&&i.onComplete()}};if(mj(i)||(f={...f,...lj(e,f)}),f.duration&&(f.duration=ta(f.duration)),f.repeatDelay&&(f.repeatDelay=ta(f.repeatDelay)),!c||!d||sN.current||i.type===!1||C$.skipAnimations)return rj(f);if(!r.isHandoff&&t.owner&&t.owner.current instanceof HTMLElement&&!t.owner.getProps().onUpdate){const m=nj(t,e,f);if(m)return m}return Zp(f)};function ef(e){return!!(Ir(e)&&e.add)}const vI=e=>/^\-?\d*\.?\d+$/.test(e);function yy(e,t){e.indexOf(t)===-1&&e.push(t)}function vy(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}class wy{constructor(){this.subscriptions=[]}add(t){return yy(this.subscriptions,t),()=>vy(this.subscriptions,t)}notify(t,n,r){const s=this.subscriptions.length;if(s)if(s===1)this.subscriptions[0](t,n,r);else for(let i=0;i<s;i++){const o=this.subscriptions[i];o&&o(t,n,r)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const kT=30,_j=e=>!isNaN(parseFloat(e));class gj{constructor(t,n={}){this.version="11.0.8",this.canTrackVelocity=!1,this.events={},this.updateAndNotify=(r,s=!0)=>{const i=na.now();this.updatedAt!==i&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(r),this.current!==this.prev&&this.events.change&&this.events.change.notify(this.current),s&&this.events.renderRequest&&this.events.renderRequest.notify(this.current)},this.hasAnimated=!1,this.setCurrent(t),this.canTrackVelocity=_j(this.current),this.owner=n.owner}setCurrent(t){this.current=t,this.updatedAt=na.now()}setPrevFrameValue(t=this.current){this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt}onChange(t){return this.on("change",t)}on(t,n){this.events[t]||(this.events[t]=new wy);const r=this.events[t].add(n);return t==="change"?()=>{r(),gn.read(()=>{this.events.change.getSize()||this.stop()})}:r}clearListeners(){for(const t in this.events)this.events[t].clear()}attach(t,n){this.passiveEffect=t,this.stopPassiveEffect=n}set(t,n=!0){!n||!this.passiveEffect?this.updateAndNotify(t,n):this.passiveEffect(t,this.updateAndNotify)}setWithVelocity(t,n,r){this.set(n),this.prev=void 0,this.prevFrameValue=t,this.prevUpdatedAt=this.updatedAt-r}jump(t){this.updateAndNotify(t),this.prev=t,this.prevUpdatedAt=this.prevFrameValue=void 0,this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}get(){return this.current}getPrevious(){return this.prev}getVelocity(){const t=na.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||t-this.updatedAt>kT)return 0;const n=Math.min(this.updatedAt-this.prevUpdatedAt,kT);return hI(parseFloat(this.current)-parseFloat(this.prevFrameValue),n)}start(t){return this.stop(),new Promise(n=>{this.hasAnimated=!0,this.animation=t(n),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function _l(e,t){return new gj(e,t)}const wI=e=>t=>t.test(e),yj={test:e=>e==="auto",parse:e=>e},MI=[bl,wt,Qs,Fi,xB,MB,yj],ou=e=>MI.find(wI(e)),vj=[...MI,pr,no],wj=e=>vj.find(wI(e));function Mj(e,t,n){e.hasValue(t)?e.getValue(t).set(n):e.addValue(t,_l(n))}function xj(e,t){const n=Af(e,t);let{transitionEnd:r={},transition:s={},...i}=n?e.makeTargetAnimatable(n,!1):{};i={...i,...r};for(const o in i){const a=zB(i[o]);Mj(e,o,a)}}function bj(e,t,n){var r,s;const i=Object.keys(t).filter(a=>!e.hasValue(a)),o=i.length;if(o)for(let a=0;a<o;a++){const l=i[a],u=t[l];let p=null;Array.isArray(u)&&(p=u[0]),p===null&&(p=(s=(r=n[l])!==null&&r!==void 0?r:e.readValue(l))!==null&&s!==void 0?s:t[l]),p!=null&&(typeof p=="string"&&(vI(p)||yI(p))?p=parseFloat(p):!wj(p)&&no.test(u)&&(p=gI(l,u)),e.addValue(l,_l(p,{owner:e})),n[l]===void 0&&(n[l]=p),p!==null&&e.setBaseTarget(l,p))}}function Tj(e,t){return t?(t[e]||t.default||t).from:void 0}function Ej(e,t,n){const r={};for(const s in e){const i=Tj(s,t);if(i!==void 0)r[s]=i;else{const o=n.getValue(s);o&&(r[s]=o.get())}}return r}function Pj({protectedKeys:e,needsAnimating:t},n){const r=e.hasOwnProperty(n)&&t[n]!==!0;return t[n]=!1,r}function Sj(e,t){const n=e.get();if(Array.isArray(t)){for(let r=0;r<t.length;r++)if(t[r]!==n)return!0}else return n!==t}function xI(e,t,{delay:n=0,transitionOverride:r,type:s}={}){let{transition:i=e.getDefaultTransition(),transitionEnd:o,...a}=e.makeTargetAnimatable(t);const l=e.getValue("willChange");r&&(i=r);const u=[],p=s&&e.animationState&&e.animationState.getState()[s];for(const c in a){const d=e.getValue(c),f=a[c];if(!d||f===void 0||p&&Pj(p,c))continue;const m={delay:n,elapsed:0,..._y(i||{},c)};if(window.HandoffAppearAnimations){const _=e.getProps()[S$];if(_){const h=window.HandoffAppearAnimations(_,c,d,gn);h!==null&&(m.elapsed=h,m.isHandoff=!0)}}let y=!m.isHandoff&&!Sj(d,f);if(m.type==="spring"&&(d.getVelocity()||m.velocity)&&(y=!1),d.animation&&(y=!1),y)continue;d.start(gy(c,d,f,e.shouldReduceMotion&&_a.has(c)?{type:!1}:m));const C=d.animation;ef(l)&&(l.add(c),C.then(()=>l.remove(c))),u.push(C)}return o&&Promise.all(u).then(()=>{o&&xj(e,o)}),u}function $g(e,t,n={}){const r=Af(e,t,n.custom);let{transition:s=e.getDefaultTransition()||{}}=r||{};n.transitionOverride&&(s=n.transitionOverride);const i=r?()=>Promise.all(xI(e,r,n)):()=>Promise.resolve(),o=e.variantChildren&&e.variantChildren.size?(l=0)=>{const{delayChildren:u=0,staggerChildren:p,staggerDirection:c}=s;return Cj(e,t,u+l,p,c,n)}:()=>Promise.resolve(),{when:a}=s;if(a){const[l,u]=a==="beforeChildren"?[i,o]:[o,i];return l().then(()=>u())}else return Promise.all([i(),o(n.delay)])}function Cj(e,t,n=0,r=0,s=1,i){const o=[],a=(e.variantChildren.size-1)*r,l=s===1?(u=0)=>u*r:(u=0)=>a-u*r;return Array.from(e.variantChildren).sort(kj).forEach((u,p)=>{u.notify("AnimationStart",t),o.push($g(u,t,{...i,delay:n+l(p)}).then(()=>u.notify("AnimationComplete",t)))}),Promise.all(o)}function kj(e,t){return e.sortNodePosition(t)}function $j(e,t,n={}){e.notify("AnimationStart",t);let r;if(Array.isArray(t)){const s=t.map(i=>$g(e,i,n));r=Promise.all(s)}else if(typeof t=="string")r=$g(e,t,n);else{const s=typeof t=="function"?Af(e,t,n.custom):t;r=Promise.all(xI(e,s,n))}return r.then(()=>e.notify("AnimationComplete",t))}const Ij=[...ty].reverse(),Aj=ty.length;function Dj(e){return t=>Promise.all(t.map(({animation:n,options:r})=>$j(e,n,r)))}function Oj(e){let t=Dj(e);const n=Lj();let r=!0;const s=(l,u)=>{const p=Af(e,u);if(p){const{transition:c,transitionEnd:d,...f}=p;l={...l,...f,...d}}return l};function i(l){t=l(e)}function o(l,u){const p=e.getProps(),c=e.getVariantContext(!0)||{},d=[],f=new Set;let m={},y=1/0;for(let _=0;_<Aj;_++){const h=Ij[_],w=n[h],M=p[h]!==void 0?p[h]:c[h],x=oc(M),b=h===u?w.isActive:null;b===!1&&(y=_);let T=M===c[h]&&M!==p[h]&&x;if(T&&r&&e.manuallyAnimateOnMount&&(T=!1),w.protectedKeys={...m},!w.isActive&&b===null||!M&&!w.prevProp||kf(M)||typeof M=="boolean")continue;let $=Fj(w.prevProp,M)||h===u&&w.isActive&&!T&&x||_>y&&x,O=!1;const G=Array.isArray(M)?M:[M];let H=G.reduce(s,{});b===!1&&(H={});const{prevResolvedValues:N={}}=w,J={...N,...H},q=X=>{$=!0,f.has(X)&&(O=!0,f.delete(X)),w.needsAnimating[X]=!0};for(const X in J){const Y=H[X],K=N[X];if(m.hasOwnProperty(X))continue;let oe=!1;Qp(Y)&&Qp(K)?oe=!X$(Y,K):oe=Y!==K,oe?Y!==void 0?q(X):f.add(X):Y!==void 0&&f.has(X)?q(X):w.protectedKeys[X]=!0}w.prevProp=M,w.prevResolvedValues=H,w.isActive&&(m={...m,...H}),r&&e.blockInitialAnimation&&($=!1),$&&(!T||O)&&d.push(...G.map(X=>({animation:X,options:{type:h,...l}})))}if(f.size){const _={};f.forEach(h=>{const w=e.getBaseTarget(h);w!==void 0&&(_[h]=w)}),d.push({animation:_})}let C=!!d.length;return r&&(p.initial===!1||p.initial===p.animate)&&!e.manuallyAnimateOnMount&&(C=!1),r=!1,C?t(d):Promise.resolve()}function a(l,u,p){var c;if(n[l].isActive===u)return Promise.resolve();(c=e.variantChildren)===null||c===void 0||c.forEach(f=>{var m;return(m=f.animationState)===null||m===void 0?void 0:m.setActive(l,u)}),n[l].isActive=u;const d=o(p,l);for(const f in n)n[f].protectedKeys={};return d}return{animateChanges:o,setActive:a,setAnimateFunction:i,getState:()=>n}}function Fj(e,t){return typeof t=="string"?t!==e:Array.isArray(t)?!X$(t,e):!1}function Fo(e=!1){return{isActive:e,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function Lj(){return{animate:Fo(!0),whileInView:Fo(),whileHover:Fo(),whileTap:Fo(),whileDrag:Fo(),whileFocus:Fo(),exit:Fo()}}class zj extends ao{constructor(t){super(t),t.animationState||(t.animationState=Oj(t))}updateAnimationControlsSubscription(){const{animate:t}=this.node.getProps();this.unmount(),kf(t)&&(this.unmount=t.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:t}=this.node.getProps(),{animate:n}=this.node.prevProps||{};t!==n&&this.updateAnimationControlsSubscription()}unmount(){}}let Rj=0;class Bj extends ao{constructor(){super(...arguments),this.id=Rj++}update(){if(!this.node.presenceContext)return;const{isPresent:t,onExitComplete:n,custom:r}=this.node.presenceContext,{isPresent:s}=this.node.prevPresenceContext||{};if(!this.node.animationState||t===s)return;const i=this.node.animationState.setActive("exit",!t,{custom:r??this.node.getProps().custom});n&&!t&&i.then(()=>n(this.id))}mount(){const{register:t}=this.node.presenceContext||{};t&&(this.unmount=t(this.id))}unmount(){}}const Nj={animation:{Feature:zj},exit:{Feature:Bj}},$T=(e,t)=>Math.abs(e-t);function jj(e,t){const n=$T(e.x,t.x),r=$T(e.y,t.y);return Math.sqrt(n**2+r**2)}class bI{constructor(t,n,{transformPagePoint:r,contextWindow:s,dragSnapToOrigin:i=!1}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const c=Em(this.lastMoveEventInfo,this.history),d=this.startEvent!==null,f=jj(c.offset,{x:0,y:0})>=3;if(!d&&!f)return;const{point:m}=c,{timestamp:y}=rr;this.history.push({...m,timestamp:y});const{onStart:C,onMove:_}=this.handlers;d||(C&&C(this.lastMoveEvent,c),this.startEvent=this.lastMoveEvent),_&&_(this.lastMoveEvent,c)},this.handlePointerMove=(c,d)=>{this.lastMoveEvent=c,this.lastMoveEventInfo=Tm(d,this.transformPagePoint),gn.update(this.updatePoint,!0)},this.handlePointerUp=(c,d)=>{this.end();const{onEnd:f,onSessionEnd:m,resumeAnimation:y}=this.handlers;if(this.dragSnapToOrigin&&y&&y(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const C=Em(c.type==="pointercancel"?this.lastMoveEventInfo:Tm(d,this.transformPagePoint),this.history);this.startEvent&&f&&f(c,C),m&&m(c,C)},!G$(t))return;this.dragSnapToOrigin=i,this.handlers=n,this.transformPagePoint=r,this.contextWindow=s||window;const o=If(t),a=Tm(o,this.transformPagePoint),{point:l}=a,{timestamp:u}=rr;this.history=[{...l,timestamp:u}];const{onSessionStart:p}=n;p&&p(t,Em(a,this.history)),this.removeListeners=pi(di(this.contextWindow,"pointermove",this.handlePointerMove),di(this.contextWindow,"pointerup",this.handlePointerUp),di(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(t){this.handlers=t}end(){this.removeListeners&&this.removeListeners(),yi(this.updatePoint)}}function Tm(e,t){return t?{point:t(e.point)}:e}function IT(e,t){return{x:e.x-t.x,y:e.y-t.y}}function Em({point:e},t){return{point:e,delta:IT(e,TI(t)),offset:IT(e,Vj(t)),velocity:Uj(t,.1)}}function Vj(e){return e[0]}function TI(e){return e[e.length-1]}function Uj(e,t){if(e.length<2)return{x:0,y:0};let n=e.length-1,r=null;const s=TI(e);for(;n>=0&&(r=e[n],!(s.timestamp-r.timestamp>ta(t)));)n--;if(!r)return{x:0,y:0};const i=fi(s.timestamp-r.timestamp);if(i===0)return{x:0,y:0};const o={x:(s.x-r.x)/i,y:(s.y-r.y)/i};return o.x===1/0&&(o.x=0),o.y===1/0&&(o.y=0),o}function qr(e){return e.max-e.min}function Ig(e,t=0,n=.01){return Math.abs(e-t)<=n}function AT(e,t,n,r=.5){e.origin=r,e.originPoint=_n(t.min,t.max,e.origin),e.scale=qr(n)/qr(t),(Ig(e.scale,1,1e-4)||isNaN(e.scale))&&(e.scale=1),e.translate=_n(n.min,n.max,e.origin)-e.originPoint,(Ig(e.translate)||isNaN(e.translate))&&(e.translate=0)}function Ru(e,t,n,r){AT(e.x,t.x,n.x,r?r.originX:void 0),AT(e.y,t.y,n.y,r?r.originY:void 0)}function DT(e,t,n){e.min=n.min+t.min,e.max=e.min+qr(t)}function Wj(e,t,n){DT(e.x,t.x,n.x),DT(e.y,t.y,n.y)}function OT(e,t,n){e.min=t.min-n.min,e.max=e.min+qr(t)}function Bu(e,t,n){OT(e.x,t.x,n.x),OT(e.y,t.y,n.y)}function Gj(e,{min:t,max:n},r){return t!==void 0&&e<t?e=r?_n(t,e,r.min):Math.max(e,t):n!==void 0&&e>n&&(e=r?_n(n,e,r.max):Math.min(e,n)),e}function FT(e,t,n){return{min:t!==void 0?e.min+t:void 0,max:n!==void 0?e.max+n-(e.max-e.min):void 0}}function Hj(e,{top:t,left:n,bottom:r,right:s}){return{x:FT(e.x,n,s),y:FT(e.y,t,r)}}function LT(e,t){let n=t.min-e.min,r=t.max-e.max;return t.max-t.min<e.max-e.min&&([n,r]=[r,n]),{min:n,max:r}}function Kj(e,t){return{x:LT(e.x,t.x),y:LT(e.y,t.y)}}function qj(e,t){let n=.5;const r=qr(e),s=qr(t);return s>r?n=lc(t.min,t.max-r,e.min):r>s&&(n=lc(e.min,e.max-s,t.min)),to(0,1,n)}function Qj(e,t){const n={};return t.min!==void 0&&(n.min=t.min-e.min),t.max!==void 0&&(n.max=t.max-e.min),n}const Ag=.35;function Xj(e=Ag){return e===!1?e=0:e===!0&&(e=Ag),{x:zT(e,"left","right"),y:zT(e,"top","bottom")}}function zT(e,t,n){return{min:RT(e,t),max:RT(e,n)}}function RT(e,t){return typeof e=="number"?e:e[t]||0}const BT=()=>({translate:0,scale:1,origin:0,originPoint:0}),Za=()=>({x:BT(),y:BT()}),NT=()=>({min:0,max:0}),$n=()=>({x:NT(),y:NT()});function ss(e){return[e("x"),e("y")]}function EI({top:e,left:t,right:n,bottom:r}){return{x:{min:t,max:n},y:{min:e,max:r}}}function Yj({x:e,y:t}){return{top:t.min,right:e.max,bottom:t.max,left:e.min}}function Jj(e,t){if(!t)return e;const n=t({x:e.left,y:e.top}),r=t({x:e.right,y:e.bottom});return{top:n.y,left:n.x,bottom:r.y,right:r.x}}function Pm(e){return e===void 0||e===1}function Dg({scale:e,scaleX:t,scaleY:n}){return!Pm(e)||!Pm(t)||!Pm(n)}function Uo(e){return Dg(e)||PI(e)||e.z||e.rotate||e.rotateX||e.rotateY}function PI(e){return jT(e.x)||jT(e.y)}function jT(e){return e&&e!=="0%"}function tf(e,t,n){const r=e-n,s=t*r;return n+s}function VT(e,t,n,r,s){return s!==void 0&&(e=tf(e,s,r)),tf(e,n,r)+t}function Og(e,t=0,n=1,r,s){e.min=VT(e.min,t,n,r,s),e.max=VT(e.max,t,n,r,s)}function SI(e,{x:t,y:n}){Og(e.x,t.translate,t.scale,t.originPoint),Og(e.y,n.translate,n.scale,n.originPoint)}function Zj(e,t,n,r=!1){const s=n.length;if(!s)return;t.x=t.y=1;let i,o;for(let a=0;a<s;a++){i=n[a],o=i.projectionDelta;const l=i.instance;l&&l.style&&l.style.display==="contents"||(r&&i.options.layoutScroll&&i.scroll&&i!==i.root&&el(e,{x:-i.scroll.offset.x,y:-i.scroll.offset.y}),o&&(t.x*=o.x.scale,t.y*=o.y.scale,SI(e,o)),r&&Uo(i.latestValues)&&el(e,i.latestValues))}t.x=UT(t.x),t.y=UT(t.y)}function UT(e){return Number.isInteger(e)||e>1.0000000000001||e<.999999999999?e:1}function Ri(e,t){e.min=e.min+t,e.max=e.max+t}function WT(e,t,[n,r,s]){const i=t[s]!==void 0?t[s]:.5,o=_n(e.min,e.max,i);Og(e,t[n],t[r],o,t.scale)}const e4=["x","scaleX","originX"],t4=["y","scaleY","originY"];function el(e,t){WT(e.x,t,e4),WT(e.y,t,t4)}function CI(e,t){return EI(Jj(e.getBoundingClientRect(),t))}function n4(e,t,n){const r=CI(e,n),{scroll:s}=t;return s&&(Ri(r.x,s.offset.x),Ri(r.y,s.offset.y)),r}const kI=({current:e})=>e?e.ownerDocument.defaultView:null,r4=new WeakMap;class s4{constructor(t){this.openGlobalLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=$n(),this.visualElement=t}start(t,{snapToCursor:n=!1}={}){const{presenceContext:r}=this.visualElement;if(r&&r.isPresent===!1)return;const s=p=>{const{dragSnapToOrigin:c}=this.getProps();c?this.pauseAnimation():this.stopAnimation(),n&&this.snapToCursor(If(p,"page").point)},i=(p,c)=>{const{drag:d,dragPropagation:f,onDragStart:m}=this.getProps();if(d&&!f&&(this.openGlobalLock&&this.openGlobalLock(),this.openGlobalLock=K$(d),!this.openGlobalLock))return;this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),ss(C=>{let _=this.getAxisMotionValue(C).get()||0;if(Qs.test(_)){const{projection:h}=this.visualElement;if(h&&h.layout){const w=h.layout.layoutBox[C];w&&(_=qr(w)*(parseFloat(_)/100))}}this.originPoint[C]=_}),m&&gn.update(()=>m(p,c),!1,!0);const{animationState:y}=this.visualElement;y&&y.setActive("whileDrag",!0)},o=(p,c)=>{const{dragPropagation:d,dragDirectionLock:f,onDirectionLock:m,onDrag:y}=this.getProps();if(!d&&!this.openGlobalLock)return;const{offset:C}=c;if(f&&this.currentDirection===null){this.currentDirection=i4(C),this.currentDirection!==null&&m&&m(this.currentDirection);return}this.updateAxis("x",c.point,C),this.updateAxis("y",c.point,C),this.visualElement.render(),y&&y(p,c)},a=(p,c)=>this.stop(p,c),l=()=>ss(p=>{var c;return this.getAnimationState(p)==="paused"&&((c=this.getAxisMotionValue(p).animation)===null||c===void 0?void 0:c.play())}),{dragSnapToOrigin:u}=this.getProps();this.panSession=new bI(t,{onSessionStart:s,onStart:i,onMove:o,onSessionEnd:a,resumeAnimation:l},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:u,contextWindow:kI(this.visualElement)})}stop(t,n){const r=this.isDragging;if(this.cancel(),!r)return;const{velocity:s}=n;this.startAnimation(s);const{onDragEnd:i}=this.getProps();i&&gn.update(()=>i(t,n))}cancel(){this.isDragging=!1;const{projection:t,animationState:n}=this.visualElement;t&&(t.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:r}=this.getProps();!r&&this.openGlobalLock&&(this.openGlobalLock(),this.openGlobalLock=null),n&&n.setActive("whileDrag",!1)}updateAxis(t,n,r){const{drag:s}=this.getProps();if(!r||!Bd(t,s,this.currentDirection))return;const i=this.getAxisMotionValue(t);let o=this.originPoint[t]+r[t];this.constraints&&this.constraints[t]&&(o=Gj(o,this.constraints[t],this.elastic[t])),i.set(o)}resolveConstraints(){var t;const{dragConstraints:n,dragElastic:r}=this.getProps(),s=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):(t=this.visualElement.projection)===null||t===void 0?void 0:t.layout,i=this.constraints;n&&Ya(n)?this.constraints||(this.constraints=this.resolveRefConstraints()):n&&s?this.constraints=Hj(s.layoutBox,n):this.constraints=!1,this.elastic=Xj(r),i!==this.constraints&&s&&this.constraints&&!this.hasMutatedConstraints&&ss(o=>{this.getAxisMotionValue(o)&&(this.constraints[o]=Qj(s.layoutBox[o],this.constraints[o]))})}resolveRefConstraints(){const{dragConstraints:t,onMeasureDragConstraints:n}=this.getProps();if(!t||!Ya(t))return!1;const r=t.current,{projection:s}=this.visualElement;if(!s||!s.layout)return!1;const i=n4(r,s.root,this.visualElement.getTransformPagePoint());let o=Kj(s.layout.layoutBox,i);if(n){const a=n(Yj(o));this.hasMutatedConstraints=!!a,a&&(o=EI(a))}return o}startAnimation(t){const{drag:n,dragMomentum:r,dragElastic:s,dragTransition:i,dragSnapToOrigin:o,onDragTransitionEnd:a}=this.getProps(),l=this.constraints||{},u=ss(p=>{if(!Bd(p,n,this.currentDirection))return;let c=l&&l[p]||{};o&&(c={min:0,max:0});const d=s?200:1e6,f=s?40:1e7,m={type:"inertia",velocity:r?t[p]:0,bounceStiffness:d,bounceDamping:f,timeConstant:750,restDelta:1,restSpeed:10,...i,...c};return this.startAxisValueAnimation(p,m)});return Promise.all(u).then(a)}startAxisValueAnimation(t,n){const r=this.getAxisMotionValue(t);return r.start(gy(t,r,0,n))}stopAnimation(){ss(t=>this.getAxisMotionValue(t).stop())}pauseAnimation(){ss(t=>{var n;return(n=this.getAxisMotionValue(t).animation)===null||n===void 0?void 0:n.pause()})}getAnimationState(t){var n;return(n=this.getAxisMotionValue(t).animation)===null||n===void 0?void 0:n.state}getAxisMotionValue(t){const n="_drag"+t.toUpperCase(),r=this.visualElement.getProps(),s=r[n];return s||this.visualElement.getValue(t,(r.initial?r.initial[t]:void 0)||0)}snapToCursor(t){ss(n=>{const{drag:r}=this.getProps();if(!Bd(n,r,this.currentDirection))return;const{projection:s}=this.visualElement,i=this.getAxisMotionValue(n);if(s&&s.layout){const{min:o,max:a}=s.layout.layoutBox[n];i.set(t[n]-_n(o,a,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:t,dragConstraints:n}=this.getProps(),{projection:r}=this.visualElement;if(!Ya(n)||!r||!this.constraints)return;this.stopAnimation();const s={x:0,y:0};ss(o=>{const a=this.getAxisMotionValue(o);if(a){const l=a.get();s[o]=qj({min:l,max:l},this.constraints[o])}});const{transformTemplate:i}=this.visualElement.getProps();this.visualElement.current.style.transform=i?i({},""):"none",r.root&&r.root.updateScroll(),r.updateLayout(),this.resolveConstraints(),ss(o=>{if(!Bd(o,t,null))return;const a=this.getAxisMotionValue(o),{min:l,max:u}=this.constraints[o];a.set(_n(l,u,s[o]))})}addListeners(){if(!this.visualElement.current)return;r4.set(this.visualElement,this);const t=this.visualElement.current,n=di(t,"pointerdown",l=>{const{drag:u,dragListener:p=!0}=this.getProps();u&&p&&this.start(l)}),r=()=>{const{dragConstraints:l}=this.getProps();Ya(l)&&(this.constraints=this.resolveRefConstraints())},{projection:s}=this.visualElement,i=s.addEventListener("measure",r);s&&!s.layout&&(s.root&&s.root.updateScroll(),s.updateLayout()),r();const o=ui(window,"resize",()=>this.scalePositionWithinConstraints()),a=s.addEventListener("didUpdate",({delta:l,hasLayoutChanged:u})=>{this.isDragging&&u&&(ss(p=>{const c=this.getAxisMotionValue(p);c&&(this.originPoint[p]+=l[p].translate,c.set(c.get()+l[p].translate))}),this.visualElement.render())});return()=>{o(),n(),i(),a&&a()}}getProps(){const t=this.visualElement.getProps(),{drag:n=!1,dragDirectionLock:r=!1,dragPropagation:s=!1,dragConstraints:i=!1,dragElastic:o=Ag,dragMomentum:a=!0}=t;return{...t,drag:n,dragDirectionLock:r,dragPropagation:s,dragConstraints:i,dragElastic:o,dragMomentum:a}}}function Bd(e,t,n){return(t===!0||t===e)&&(n===null||n===e)}function i4(e,t=10){let n=null;return Math.abs(e.y)>t?n="y":Math.abs(e.x)>t&&(n="x"),n}class o4 extends ao{constructor(t){super(t),this.removeGroupControls=zn,this.removeListeners=zn,this.controls=new s4(t)}mount(){const{dragControls:t}=this.node.getProps();t&&(this.removeGroupControls=t.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||zn}unmount(){this.removeGroupControls(),this.removeListeners()}}const GT=e=>(t,n)=>{e&&gn.update(()=>e(t,n))};class a4 extends ao{constructor(){super(...arguments),this.removePointerDownListener=zn}onPointerDown(t){this.session=new bI(t,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:kI(this.node)})}createPanHandlers(){const{onPanSessionStart:t,onPanStart:n,onPan:r,onPanEnd:s}=this.node.getProps();return{onSessionStart:GT(t),onStart:GT(n),onMove:r,onEnd:(i,o)=>{delete this.session,s&&gn.update(()=>s(i,o))}}}mount(){this.removePointerDownListener=di(this.node.current,"pointerdown",t=>this.onPointerDown(t))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}function l4(){const e=Fe.useContext(J0);if(e===null)return[!0,null];const{isPresent:t,onExitComplete:n,register:r}=e,s=Fe.useId();return Fe.useEffect(()=>r(s),[]),!t&&n?[!1,()=>n&&n(s)]:[!0]}const mp={hasAnimatedSinceResize:!0,hasEverUpdated:!1};function HT(e,t){return t.max===t.min?0:e/(t.max-t.min)*100}const au={correct:(e,t)=>{if(!t.target)return e;if(typeof e=="string")if(wt.test(e))e=parseFloat(e);else return e;const n=HT(e,t.target.x),r=HT(e,t.target.y);return`${n}% ${r}%`}},u4={correct:(e,{treeScale:t,projectionDelta:n})=>{const r=e,s=no.parse(e);if(s.length>5)return r;const i=no.createTransformer(e),o=typeof s[0]!="number"?1:0,a=n.x.scale*t.x,l=n.y.scale*t.y;s[0+o]/=a,s[1+o]/=l;const u=_n(a,l,.5);return typeof s[2+o]=="number"&&(s[2+o]/=u),typeof s[3+o]=="number"&&(s[3+o]/=u),i(s)}};class c4 extends Ze.Component{componentDidMount(){const{visualElement:t,layoutGroup:n,switchLayoutGroup:r,layoutId:s}=this.props,{projection:i}=t;pB(d4),i&&(n.group&&n.group.add(i),r&&r.register&&s&&r.register(i),i.root.didUpdate(),i.addEventListener("animationComplete",()=>{this.safeToRemove()}),i.setOptions({...i.options,onExitComplete:()=>this.safeToRemove()})),mp.hasEverUpdated=!0}getSnapshotBeforeUpdate(t){const{layoutDependency:n,visualElement:r,drag:s,isPresent:i}=this.props,o=r.projection;return o&&(o.isPresent=i,s||t.layoutDependency!==n||n===void 0?o.willUpdate():this.safeToRemove(),t.isPresent!==i&&(i?o.promote():o.relegate()||gn.postRender(()=>{const a=o.getStack();(!a||!a.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:t}=this.props.visualElement;t&&(t.root.didUpdate(),ey.postRender(()=>{!t.currentAnimation&&t.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:t,layoutGroup:n,switchLayoutGroup:r}=this.props,{projection:s}=t;s&&(s.scheduleCheckAfterUnmount(),n&&n.group&&n.group.remove(s),r&&r.deregister&&r.deregister(s))}safeToRemove(){const{safeToRemove:t}=this.props;t&&t()}render(){return null}}function $I(e){const[t,n]=l4(),r=Fe.useContext(I$);return Ze.createElement(c4,{...e,layoutGroup:r,switchLayoutGroup:Fe.useContext(A$),isPresent:t,safeToRemove:n})}const d4={borderRadius:{...au,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:au,borderTopRightRadius:au,borderBottomLeftRadius:au,borderBottomRightRadius:au,boxShadow:u4},II=["TopLeft","TopRight","BottomLeft","BottomRight"],p4=II.length,KT=e=>typeof e=="string"?parseFloat(e):e,qT=e=>typeof e=="number"||wt.test(e);function f4(e,t,n,r,s,i){s?(e.opacity=_n(0,n.opacity!==void 0?n.opacity:1,h4(r)),e.opacityExit=_n(t.opacity!==void 0?t.opacity:1,0,m4(r))):i&&(e.opacity=_n(t.opacity!==void 0?t.opacity:1,n.opacity!==void 0?n.opacity:1,r));for(let o=0;o<p4;o++){const a=`border${II[o]}Radius`;let l=QT(t,a),u=QT(n,a);if(l===void 0&&u===void 0)continue;l||(l=0),u||(u=0),l===0||u===0||qT(l)===qT(u)?(e[a]=Math.max(_n(KT(l),KT(u),r),0),(Qs.test(u)||Qs.test(l))&&(e[a]+="%")):e[a]=u}(t.rotate||n.rotate)&&(e.rotate=_n(t.rotate||0,n.rotate||0,r))}function QT(e,t){return e[t]!==void 0?e[t]:e.borderRadius}const h4=AI(0,.5,iI),m4=AI(.5,.95,zn);function AI(e,t,n){return r=>r<e?0:r>t?1:n(lc(e,t,r))}function XT(e,t){e.min=t.min,e.max=t.max}function rs(e,t){XT(e.x,t.x),XT(e.y,t.y)}function YT(e,t,n,r,s){return e-=t,e=tf(e,1/n,r),s!==void 0&&(e=tf(e,1/s,r)),e}function _4(e,t=0,n=1,r=.5,s,i=e,o=e){if(Qs.test(t)&&(t=parseFloat(t),t=_n(o.min,o.max,t/100)-o.min),typeof t!="number")return;let a=_n(i.min,i.max,r);e===i&&(a-=t),e.min=YT(e.min,t,n,a,s),e.max=YT(e.max,t,n,a,s)}function JT(e,t,[n,r,s],i,o){_4(e,t[n],t[r],t[s],t.scale,i,o)}const g4=["x","scaleX","originX"],y4=["y","scaleY","originY"];function ZT(e,t,n,r){JT(e.x,t,g4,n?n.x:void 0,r?r.x:void 0),JT(e.y,t,y4,n?n.y:void 0,r?r.y:void 0)}function eE(e){return e.translate===0&&e.scale===1}function DI(e){return eE(e.x)&&eE(e.y)}function v4(e,t){return e.x.min===t.x.min&&e.x.max===t.x.max&&e.y.min===t.y.min&&e.y.max===t.y.max}function OI(e,t){return Math.round(e.x.min)===Math.round(t.x.min)&&Math.round(e.x.max)===Math.round(t.x.max)&&Math.round(e.y.min)===Math.round(t.y.min)&&Math.round(e.y.max)===Math.round(t.y.max)}function tE(e){return qr(e.x)/qr(e.y)}class w4{constructor(){this.members=[]}add(t){yy(this.members,t),t.scheduleRender()}remove(t){if(vy(this.members,t),t===this.prevLead&&(this.prevLead=void 0),t===this.lead){const n=this.members[this.members.length-1];n&&this.promote(n)}}relegate(t){const n=this.members.findIndex(s=>t===s);if(n===0)return!1;let r;for(let s=n;s>=0;s--){const i=this.members[s];if(i.isPresent!==!1){r=i;break}}return r?(this.promote(r),!0):!1}promote(t,n){const r=this.lead;if(t!==r&&(this.prevLead=r,this.lead=t,t.show(),r)){r.instance&&r.scheduleRender(),t.scheduleRender(),t.resumeFrom=r,n&&(t.resumeFrom.preserveOpacity=!0),r.snapshot&&(t.snapshot=r.snapshot,t.snapshot.latestValues=r.animationValues||r.latestValues),t.root&&t.root.isUpdating&&(t.isLayoutDirty=!0);const{crossfade:s}=t.options;s===!1&&r.hide()}}exitAnimationComplete(){this.members.forEach(t=>{const{options:n,resumingFrom:r}=t;n.onExitComplete&&n.onExitComplete(),r&&r.options.onExitComplete&&r.options.onExitComplete()})}scheduleRender(){this.members.forEach(t=>{t.instance&&t.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function nE(e,t,n){let r="";const s=e.x.translate/t.x,i=e.y.translate/t.y;if((s||i)&&(r=`translate3d(${s}px, ${i}px, 0) `),(t.x!==1||t.y!==1)&&(r+=`scale(${1/t.x}, ${1/t.y}) `),n){const{rotate:l,rotateX:u,rotateY:p}=n;l&&(r+=`rotate(${l}deg) `),u&&(r+=`rotateX(${u}deg) `),p&&(r+=`rotateY(${p}deg) `)}const o=e.x.scale*t.x,a=e.y.scale*t.y;return(o!==1||a!==1)&&(r+=`scale(${o}, ${a})`),r||"none"}const M4=(e,t)=>e.depth-t.depth;class x4{constructor(){this.children=[],this.isDirty=!1}add(t){yy(this.children,t),this.isDirty=!0}remove(t){vy(this.children,t),this.isDirty=!0}forEach(t){this.isDirty&&this.children.sort(M4),this.isDirty=!1,this.children.forEach(t)}}function b4(e,t){const n=na.now(),r=({timestamp:s})=>{const i=s-n;i>=t&&(yi(r),e(i-t))};return gn.read(r,!0),()=>yi(r)}function T4(e){window.MotionDebug&&window.MotionDebug.record(e)}function E4(e){return e instanceof SVGElement&&e.tagName!=="svg"}function P4(e,t,n){const r=Ir(e)?e:_l(e);return r.start(gy("",r,t,n)),r.animation}const rE=["","X","Y","Z"],S4={visibility:"hidden"},sE=1e3;let C4=0;const Wo={type:"projectionFrame",totalNodes:0,resolvedTargetDeltas:0,recalculatedProjection:0};function FI({attachResizeListener:e,defaultParent:t,measureScroll:n,checkIsScrollRoot:r,resetTransform:s}){return class{constructor(o={},a=t==null?void 0:t()){this.id=C4++,this.animationId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.updateScheduled=!1,this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,Wo.totalNodes=Wo.resolvedTargetDeltas=Wo.recalculatedProjection=0,this.nodes.forEach(I4),this.nodes.forEach(L4),this.nodes.forEach(z4),this.nodes.forEach(A4),T4(Wo)},this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=o,this.root=a?a.root||a:this,this.path=a?[...a.path,a]:[],this.parent=a,this.depth=a?a.depth+1:0;for(let l=0;l<this.path.length;l++)this.path[l].shouldResetTransform=!0;this.root===this&&(this.nodes=new x4)}addEventListener(o,a){return this.eventHandlers.has(o)||this.eventHandlers.set(o,new wy),this.eventHandlers.get(o).add(a)}notifyListeners(o,...a){const l=this.eventHandlers.get(o);l&&l.notify(...a)}hasListeners(o){return this.eventHandlers.has(o)}mount(o,a=this.root.hasTreeAnimated){if(this.instance)return;this.isSVG=E4(o),this.instance=o;const{layoutId:l,layout:u,visualElement:p}=this.options;if(p&&!p.current&&p.mount(o),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),a&&(u||l)&&(this.isLayoutDirty=!0),e){let c;const d=()=>this.root.updateBlockedByResize=!1;e(o,()=>{this.root.updateBlockedByResize=!0,c&&c(),c=b4(d,250),mp.hasAnimatedSinceResize&&(mp.hasAnimatedSinceResize=!1,this.nodes.forEach(oE))})}l&&this.root.registerSharedNode(l,this),this.options.animate!==!1&&p&&(l||u)&&this.addEventListener("didUpdate",({delta:c,hasLayoutChanged:d,hasRelativeTargetChanged:f,layout:m})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const y=this.options.transition||p.getDefaultTransition()||V4,{onLayoutAnimationStart:C,onLayoutAnimationComplete:_}=p.getProps(),h=!this.targetLayout||!OI(this.targetLayout,m)||f,w=!d&&f;if(this.options.layoutRoot||this.resumeFrom&&this.resumeFrom.instance||w||d&&(h||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0),this.setAnimationOrigin(c,w);const M={..._y(y,"layout"),onPlay:C,onComplete:_};(p.shouldReduceMotion||this.options.layoutRoot)&&(M.delay=0,M.type=!1),this.startAnimation(M)}else d||oE(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=m})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const o=this.getStack();o&&o.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,yi(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(R4),this.animationId++)}getTransformTemplate(){const{visualElement:o}=this.options;return o&&o.getProps().transformTemplate}willUpdate(o=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let p=0;p<this.path.length;p++){const c=this.path[p];c.shouldResetTransform=!0,c.updateScroll("snapshot"),c.options.layoutRoot&&c.willUpdate(!1)}const{layoutId:a,layout:l}=this.options;if(a===void 0&&!l)return;const u=this.getTransformTemplate();this.prevTransformTemplateValue=u?u(this.latestValues,""):void 0,this.updateSnapshot(),o&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(iE);return}this.isUpdating||this.nodes.forEach(O4),this.isUpdating=!1,window.HandoffCancelAllAnimations&&window.HandoffCancelAllAnimations(),this.nodes.forEach(F4),this.nodes.forEach(k4),this.nodes.forEach($4),this.clearAllSnapshots();const a=na.now();rr.delta=to(0,1e3/60,a-rr.timestamp),rr.timestamp=a,rr.isProcessing=!0,gm.update.process(rr),gm.preRender.process(rr),gm.render.process(rr),rr.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,ey.read(()=>this.update()))}clearAllSnapshots(){this.nodes.forEach(D4),this.sharedNodes.forEach(B4)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,gn.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){gn.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure())}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let l=0;l<this.path.length;l++)this.path[l].updateScroll();const o=this.layout;this.layout=this.measure(!1),this.layoutCorrected=$n(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:a}=this.options;a&&a.notify("LayoutMeasure",this.layout.layoutBox,o?o.layoutBox:void 0)}updateScroll(o="measure"){let a=!!(this.options.layoutScroll&&this.instance);this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===o&&(a=!1),a&&(this.scroll={animationId:this.root.animationId,phase:o,isRoot:r(this.instance),offset:n(this.instance)})}resetTransform(){if(!s)return;const o=this.isLayoutDirty||this.shouldResetTransform,a=this.projectionDelta&&!DI(this.projectionDelta),l=this.getTransformTemplate(),u=l?l(this.latestValues,""):void 0,p=u!==this.prevTransformTemplateValue;o&&(a||Uo(this.latestValues)||p)&&(s(this.instance,u),this.shouldResetTransform=!1,this.scheduleRender())}measure(o=!0){const a=this.measurePageBox();let l=this.removeElementScroll(a);return o&&(l=this.removeTransform(l)),U4(l),{animationId:this.root.animationId,measuredBox:a,layoutBox:l,latestValues:{},source:this.id}}measurePageBox(){const{visualElement:o}=this.options;if(!o)return $n();const a=o.measureViewportBox(),{scroll:l}=this.root;return l&&(Ri(a.x,l.offset.x),Ri(a.y,l.offset.y)),a}removeElementScroll(o){const a=$n();rs(a,o);for(let l=0;l<this.path.length;l++){const u=this.path[l],{scroll:p,options:c}=u;if(u!==this.root&&p&&c.layoutScroll){if(p.isRoot){rs(a,o);const{scroll:d}=this.root;d&&(Ri(a.x,-d.offset.x),Ri(a.y,-d.offset.y))}Ri(a.x,p.offset.x),Ri(a.y,p.offset.y)}}return a}applyTransform(o,a=!1){const l=$n();rs(l,o);for(let u=0;u<this.path.length;u++){const p=this.path[u];!a&&p.options.layoutScroll&&p.scroll&&p!==p.root&&el(l,{x:-p.scroll.offset.x,y:-p.scroll.offset.y}),Uo(p.latestValues)&&el(l,p.latestValues)}return Uo(this.latestValues)&&el(l,this.latestValues),l}removeTransform(o){const a=$n();rs(a,o);for(let l=0;l<this.path.length;l++){const u=this.path[l];if(!u.instance||!Uo(u.latestValues))continue;Dg(u.latestValues)&&u.updateSnapshot();const p=$n(),c=u.measurePageBox();rs(p,c),ZT(a,u.latestValues,u.snapshot?u.snapshot.layoutBox:void 0,p)}return Uo(this.latestValues)&&ZT(a,this.latestValues),a}setTargetDelta(o){this.targetDelta=o,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(o){this.options={...this.options,...o,crossfade:o.crossfade!==void 0?o.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==rr.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(o=!1){var a;const l=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=l.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=l.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=l.isSharedProjectionDirty);const u=!!this.resumingFrom||this!==l;if(!(o||u&&this.isSharedProjectionDirty||this.isProjectionDirty||!((a=this.parent)===null||a===void 0)&&a.isProjectionDirty||this.attemptToResolveRelativeTarget))return;const{layout:c,layoutId:d}=this.options;if(!(!this.layout||!(c||d))){if(this.resolvedRelativeTargetAt=rr.timestamp,!this.targetDelta&&!this.relativeTarget){const f=this.getClosestProjectingParent();f&&f.layout&&this.animationProgress!==1?(this.relativeParent=f,this.forceRelativeParentToResolveTarget(),this.relativeTarget=$n(),this.relativeTargetOrigin=$n(),Bu(this.relativeTargetOrigin,this.layout.layoutBox,f.layout.layoutBox),rs(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}if(!(!this.relativeTarget&&!this.targetDelta)){if(this.target||(this.target=$n(),this.targetWithTransforms=$n()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),Wj(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):rs(this.target,this.layout.layoutBox),SI(this.target,this.targetDelta)):rs(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget){this.attemptToResolveRelativeTarget=!1;const f=this.getClosestProjectingParent();f&&!!f.resumingFrom==!!this.resumingFrom&&!f.options.layoutScroll&&f.target&&this.animationProgress!==1?(this.relativeParent=f,this.forceRelativeParentToResolveTarget(),this.relativeTarget=$n(),this.relativeTargetOrigin=$n(),Bu(this.relativeTargetOrigin,this.target,f.target),rs(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}Wo.resolvedTargetDeltas++}}}getClosestProjectingParent(){if(!(!this.parent||Dg(this.parent.latestValues)||PI(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}calcProjection(){var o;const a=this.getLead(),l=!!this.resumingFrom||this!==a;let u=!0;if((this.isProjectionDirty||!((o=this.parent)===null||o===void 0)&&o.isProjectionDirty)&&(u=!1),l&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(u=!1),this.resolvedRelativeTargetAt===rr.timestamp&&(u=!1),u)return;const{layout:p,layoutId:c}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(p||c))return;rs(this.layoutCorrected,this.layout.layoutBox);const d=this.treeScale.x,f=this.treeScale.y;Zj(this.layoutCorrected,this.treeScale,this.path,l),a.layout&&!a.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(a.target=a.layout.layoutBox,a.targetWithTransforms=$n());const{target:m}=a;if(!m){this.projectionTransform&&(this.projectionDelta=Za(),this.projectionTransform="none",this.scheduleRender());return}this.projectionDelta||(this.projectionDelta=Za(),this.projectionDeltaWithTransform=Za());const y=this.projectionTransform;Ru(this.projectionDelta,this.layoutCorrected,m,this.latestValues),this.projectionTransform=nE(this.projectionDelta,this.treeScale),(this.projectionTransform!==y||this.treeScale.x!==d||this.treeScale.y!==f)&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",m)),Wo.recalculatedProjection++}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(o=!0){if(this.options.scheduleRender&&this.options.scheduleRender(),o){const a=this.getStack();a&&a.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}setAnimationOrigin(o,a=!1){const l=this.snapshot,u=l?l.latestValues:{},p={...this.latestValues},c=Za();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!a;const d=$n(),f=l?l.source:void 0,m=this.layout?this.layout.source:void 0,y=f!==m,C=this.getStack(),_=!C||C.members.length<=1,h=!!(y&&!_&&this.options.crossfade===!0&&!this.path.some(j4));this.animationProgress=0;let w;this.mixTargetDelta=M=>{const x=M/1e3;aE(c.x,o.x,x),aE(c.y,o.y,x),this.setTargetDelta(c),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(Bu(d,this.layout.layoutBox,this.relativeParent.layout.layoutBox),N4(this.relativeTarget,this.relativeTargetOrigin,d,x),w&&v4(this.relativeTarget,w)&&(this.isProjectionDirty=!1),w||(w=$n()),rs(w,this.relativeTarget)),y&&(this.animationValues=p,f4(p,u,this.latestValues,x,h,_)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=x},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(o){this.notifyListeners("animationStart"),this.currentAnimation&&this.currentAnimation.stop(),this.resumingFrom&&this.resumingFrom.currentAnimation&&this.resumingFrom.currentAnimation.stop(),this.pendingAnimation&&(yi(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=gn.update(()=>{mp.hasAnimatedSinceResize=!0,this.currentAnimation=P4(0,sE,{...o,onUpdate:a=>{this.mixTargetDelta(a),o.onUpdate&&o.onUpdate(a)},onComplete:()=>{o.onComplete&&o.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const o=this.getStack();o&&o.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(sE),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const o=this.getLead();let{targetWithTransforms:a,target:l,layout:u,latestValues:p}=o;if(!(!a||!l||!u)){if(this!==o&&this.layout&&u&&LI(this.options.animationType,this.layout.layoutBox,u.layoutBox)){l=this.target||$n();const c=qr(this.layout.layoutBox.x);l.x.min=o.target.x.min,l.x.max=l.x.min+c;const d=qr(this.layout.layoutBox.y);l.y.min=o.target.y.min,l.y.max=l.y.min+d}rs(a,l),el(a,p),Ru(this.projectionDeltaWithTransform,this.layoutCorrected,a,p)}}registerSharedNode(o,a){this.sharedNodes.has(o)||this.sharedNodes.set(o,new w4),this.sharedNodes.get(o).add(a);const u=a.options.initialPromotionConfig;a.promote({transition:u?u.transition:void 0,preserveFollowOpacity:u&&u.shouldPreserveFollowOpacity?u.shouldPreserveFollowOpacity(a):void 0})}isLead(){const o=this.getStack();return o?o.lead===this:!0}getLead(){var o;const{layoutId:a}=this.options;return a?((o=this.getStack())===null||o===void 0?void 0:o.lead)||this:this}getPrevLead(){var o;const{layoutId:a}=this.options;return a?(o=this.getStack())===null||o===void 0?void 0:o.prevLead:void 0}getStack(){const{layoutId:o}=this.options;if(o)return this.root.sharedNodes.get(o)}promote({needsReset:o,transition:a,preserveFollowOpacity:l}={}){const u=this.getStack();u&&u.promote(this,l),o&&(this.projectionDelta=void 0,this.needsReset=!0),a&&this.setOptions({transition:a})}relegate(){const o=this.getStack();return o?o.relegate(this):!1}resetRotation(){const{visualElement:o}=this.options;if(!o)return;let a=!1;const{latestValues:l}=o;if((l.rotate||l.rotateX||l.rotateY||l.rotateZ)&&(a=!0),!a)return;const u={};for(let p=0;p<rE.length;p++){const c="rotate"+rE[p];l[c]&&(u[c]=l[c],o.setStaticValue(c,0))}o.render();for(const p in u)o.setStaticValue(p,u[p]);o.scheduleRender()}getProjectionStyles(o){var a,l;if(!this.instance||this.isSVG)return;if(!this.isVisible)return S4;const u={visibility:""},p=this.getTransformTemplate();if(this.needsReset)return this.needsReset=!1,u.opacity="",u.pointerEvents=fp(o==null?void 0:o.pointerEvents)||"",u.transform=p?p(this.latestValues,""):"none",u;const c=this.getLead();if(!this.projectionDelta||!this.layout||!c.target){const y={};return this.options.layoutId&&(y.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,y.pointerEvents=fp(o==null?void 0:o.pointerEvents)||""),this.hasProjected&&!Uo(this.latestValues)&&(y.transform=p?p({},""):"none",this.hasProjected=!1),y}const d=c.animationValues||c.latestValues;this.applyTransformsToTarget(),u.transform=nE(this.projectionDeltaWithTransform,this.treeScale,d),p&&(u.transform=p(d,u.transform));const{x:f,y:m}=this.projectionDelta;u.transformOrigin=`${f.origin*100}% ${m.origin*100}% 0`,c.animationValues?u.opacity=c===this?(l=(a=d.opacity)!==null&&a!==void 0?a:this.latestValues.opacity)!==null&&l!==void 0?l:1:this.preserveOpacity?this.latestValues.opacity:d.opacityExit:u.opacity=c===this?d.opacity!==void 0?d.opacity:"":d.opacityExit!==void 0?d.opacityExit:0;for(const y in Hp){if(d[y]===void 0)continue;const{correct:C,applyTo:_}=Hp[y],h=u.transform==="none"?d[y]:C(d[y],c);if(_){const w=_.length;for(let M=0;M<w;M++)u[_[M]]=h}else u[y]=h}return this.options.layoutId&&(u.pointerEvents=c===this?fp(o==null?void 0:o.pointerEvents)||"":"none"),u}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(o=>{var a;return(a=o.currentAnimation)===null||a===void 0?void 0:a.stop()}),this.root.nodes.forEach(iE),this.root.sharedNodes.clear()}}}function k4(e){e.updateLayout()}function $4(e){var t;const n=((t=e.resumeFrom)===null||t===void 0?void 0:t.snapshot)||e.snapshot;if(e.isLead()&&e.layout&&n&&e.hasListeners("didUpdate")){const{layoutBox:r,measuredBox:s}=e.layout,{animationType:i}=e.options,o=n.source!==e.layout.source;i==="size"?ss(c=>{const d=o?n.measuredBox[c]:n.layoutBox[c],f=qr(d);d.min=r[c].min,d.max=d.min+f}):LI(i,n.layoutBox,r)&&ss(c=>{const d=o?n.measuredBox[c]:n.layoutBox[c],f=qr(r[c]);d.max=d.min+f,e.relativeTarget&&!e.currentAnimation&&(e.isProjectionDirty=!0,e.relativeTarget[c].max=e.relativeTarget[c].min+f)});const a=Za();Ru(a,r,n.layoutBox);const l=Za();o?Ru(l,e.applyTransform(s,!0),n.measuredBox):Ru(l,r,n.layoutBox);const u=!DI(a);let p=!1;if(!e.resumeFrom){const c=e.getClosestProjectingParent();if(c&&!c.resumeFrom){const{snapshot:d,layout:f}=c;if(d&&f){const m=$n();Bu(m,n.layoutBox,d.layoutBox);const y=$n();Bu(y,r,f.layoutBox),OI(m,y)||(p=!0),c.options.layoutRoot&&(e.relativeTarget=y,e.relativeTargetOrigin=m,e.relativeParent=c)}}}e.notifyListeners("didUpdate",{layout:r,snapshot:n,delta:l,layoutDelta:a,hasLayoutChanged:u,hasRelativeTargetChanged:p})}else if(e.isLead()){const{onExitComplete:r}=e.options;r&&r()}e.options.transition=void 0}function I4(e){Wo.totalNodes++,e.parent&&(e.isProjecting()||(e.isProjectionDirty=e.parent.isProjectionDirty),e.isSharedProjectionDirty||(e.isSharedProjectionDirty=!!(e.isProjectionDirty||e.parent.isProjectionDirty||e.parent.isSharedProjectionDirty)),e.isTransformDirty||(e.isTransformDirty=e.parent.isTransformDirty))}function A4(e){e.isProjectionDirty=e.isSharedProjectionDirty=e.isTransformDirty=!1}function D4(e){e.clearSnapshot()}function iE(e){e.clearMeasurements()}function O4(e){e.isLayoutDirty=!1}function F4(e){const{visualElement:t}=e.options;t&&t.getProps().onBeforeLayoutMeasure&&t.notify("BeforeLayoutMeasure"),e.resetTransform()}function oE(e){e.finishAnimation(),e.targetDelta=e.relativeTarget=e.target=void 0,e.isProjectionDirty=!0}function L4(e){e.resolveTargetDelta()}function z4(e){e.calcProjection()}function R4(e){e.resetRotation()}function B4(e){e.removeLeadSnapshot()}function aE(e,t,n){e.translate=_n(t.translate,0,n),e.scale=_n(t.scale,1,n),e.origin=t.origin,e.originPoint=t.originPoint}function lE(e,t,n,r){e.min=_n(t.min,n.min,r),e.max=_n(t.max,n.max,r)}function N4(e,t,n,r){lE(e.x,t.x,n.x,r),lE(e.y,t.y,n.y,r)}function j4(e){return e.animationValues&&e.animationValues.opacityExit!==void 0}const V4={duration:.45,ease:[.4,0,.1,1]},uE=e=>typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(e),cE=uE("applewebkit/")&&!uE("chrome/")?Math.round:zn;function dE(e){e.min=cE(e.min),e.max=cE(e.max)}function U4(e){dE(e.x),dE(e.y)}function LI(e,t,n){return e==="position"||e==="preserve-aspect"&&!Ig(tE(t),tE(n),.2)}const W4=FI({attachResizeListener:(e,t)=>ui(e,"resize",t),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),Sm={current:void 0},zI=FI({measureScroll:e=>({x:e.scrollLeft,y:e.scrollTop}),defaultParent:()=>{if(!Sm.current){const e=new W4({});e.mount(window),e.setOptions({layoutScroll:!0}),Sm.current=e}return Sm.current},resetTransform:(e,t)=>{e.style.transform=t!==void 0?t:"none"},checkIsScrollRoot:e=>window.getComputedStyle(e).position==="fixed"}),G4={pan:{Feature:a4},drag:{Feature:o4,ProjectionNode:zI,MeasureLayout:$I}},H4=/var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;function K4(e){const t=H4.exec(e);if(!t)return[,];const[,n,r]=t;return[n,r]}function Fg(e,t,n=1){const[r,s]=K4(e);if(!r)return;const i=window.getComputedStyle(t).getPropertyValue(r);if(i){const o=i.trim();return vI(o)?parseFloat(o):o}else return Kp(s)?Fg(s,t,n+1):s}function q4(e,{...t},n){const r=e.current;if(!(r instanceof Element))return{target:t,transitionEnd:n};n&&(n={...n}),e.values.forEach(s=>{const i=s.get();if(!Kp(i))return;const o=Fg(i,r);o&&s.set(o)});for(const s in t){const i=t[s];if(!Kp(i))continue;const o=Fg(i,r);o&&(t[s]=o,n||(n={}),n[s]===void 0&&(n[s]=i))}return{target:t,transitionEnd:n}}const Q4=new Set(["width","height","top","left","right","bottom","x","y","translateX","translateY"]),RI=e=>Q4.has(e),X4=e=>Object.keys(e).some(RI),pE=e=>e===bl||e===wt,fE=(e,t)=>parseFloat(e.split(", ")[t]),hE=(e,t)=>(n,{transform:r})=>{if(r==="none"||!r)return 0;const s=r.match(/^matrix3d\((.+)\)$/);if(s)return fE(s[1],t);{const i=r.match(/^matrix\((.+)\)$/);return i?fE(i[1],e):0}},Y4=new Set(["x","y","z"]),J4=wc.filter(e=>!Y4.has(e));function Z4(e){const t=[];return J4.forEach(n=>{const r=e.getValue(n);r!==void 0&&(t.push([n,r.get()]),r.set(n.startsWith("scale")?1:0))}),t.length&&e.render(),t}const gl={width:({x:e},{paddingLeft:t="0",paddingRight:n="0"})=>e.max-e.min-parseFloat(t)-parseFloat(n),height:({y:e},{paddingTop:t="0",paddingBottom:n="0"})=>e.max-e.min-parseFloat(t)-parseFloat(n),top:(e,{top:t})=>parseFloat(t),left:(e,{left:t})=>parseFloat(t),bottom:({y:e},{top:t})=>parseFloat(t)+(e.max-e.min),right:({x:e},{left:t})=>parseFloat(t)+(e.max-e.min),x:hE(4,13),y:hE(5,14)};gl.translateX=gl.x;gl.translateY=gl.y;const eV=(e,t,n)=>{const r=t.measureViewportBox(),s=t.current,i=getComputedStyle(s),{display:o}=i,a={};o==="none"&&t.setStaticValue("display",e.display||"block"),n.forEach(u=>{a[u]=gl[u](r,i)}),t.render();const l=t.measureViewportBox();return n.forEach(u=>{const p=t.getValue(u);p&&p.jump(a[u]),e[u]=gl[u](l,i)}),e},tV=(e,t,n={},r={})=>{t={...t},r={...r};const s=Object.keys(t).filter(RI);let i=[],o=!1;const a=[];if(s.forEach(l=>{const u=e.getValue(l);if(!e.hasValue(l))return;let p=n[l],c=ou(p);const d=t[l];let f;if(Qp(d)){const m=d.length,y=d[0]===null?1:0;p=d[y],c=ou(p);for(let C=y;C<m&&d[C]!==null;C++)f?Xp(ou(d[C])===f):f=ou(d[C])}else f=ou(d);if(c!==f)if(pE(c)&&pE(f)){const m=u.get();typeof m=="string"&&u.set(parseFloat(m)),typeof d=="string"?t[l]=parseFloat(d):Array.isArray(d)&&f===wt&&(t[l]=d.map(parseFloat))}else c!=null&&c.transform&&(f!=null&&f.transform)&&(p===0||d===0)?p===0?u.set(f.transform(p)):t[l]=c.transform(d):(o||(i=Z4(e),o=!0),a.push(l),r[l]=r[l]!==void 0?r[l]:t[l],u.jump(d))}),a.length){const l=a.indexOf("height")>=0?window.pageYOffset:null,u=eV(t,e,a);return i.length&&i.forEach(([p,c])=>{e.getValue(p).set(c)}),e.render(),Cf&&l!==null&&window.scrollTo({top:l}),{target:u,transitionEnd:r}}else return{target:t,transitionEnd:r}};function nV(e,t,n,r){return X4(t)?tV(e,t,n,r):{target:t,transitionEnd:r}}const rV=(e,t,n,r)=>{const s=q4(e,t,r);return t=s.target,r=s.transitionEnd,nV(e,t,n,r)},Lg={current:null},BI={current:!1};function sV(){if(BI.current=!0,!!Cf)if(window.matchMedia){const e=window.matchMedia("(prefers-reduced-motion)"),t=()=>Lg.current=e.matches;e.addListener(t),t()}else Lg.current=!1}function iV(e,t,n){const{willChange:r}=t;for(const s in t){const i=t[s],o=n[s];if(Ir(i))e.addValue(s,i),ef(r)&&r.add(s);else if(Ir(o))e.addValue(s,_l(i,{owner:e})),ef(r)&&r.remove(s);else if(o!==i)if(e.hasValue(s)){const a=e.getValue(s);!a.hasAnimated&&a.set(i)}else{const a=e.getStaticValue(s);e.addValue(s,_l(a!==void 0?a:i,{owner:e}))}}for(const s in n)t[s]===void 0&&e.removeValue(s);return t}const mE=new WeakMap,NI=Object.keys(ac),oV=NI.length,_E=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"],aV=ny.length;class lV{constructor({parent:t,props:n,presenceContext:r,reducedMotionConfig:s,visualState:i},o={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.scheduleRender=()=>gn.render(this.render,!1,!0);const{latestValues:a,renderState:l}=i;this.latestValues=a,this.baseTarget={...a},this.initialValues=n.initial?{...a}:{},this.renderState=l,this.parent=t,this.props=n,this.presenceContext=r,this.depth=t?t.depth+1:0,this.reducedMotionConfig=s,this.options=o,this.isControllingVariants=$f(n),this.isVariantNode=$$(n),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(t&&t.current);const{willChange:u,...p}=this.scrapeMotionValuesFromProps(n,{});for(const c in p){const d=p[c];a[c]!==void 0&&Ir(d)&&(d.set(a[c],!1),ef(u)&&u.add(c))}}scrapeMotionValuesFromProps(t,n){return{}}mount(t){this.current=t,mE.set(t,this),this.projection&&!this.projection.instance&&this.projection.mount(t),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((n,r)=>this.bindToMotionValue(r,n)),BI.current||sV(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:Lg.current,this.parent&&this.parent.children.add(this),this.update(this.props,this.presenceContext)}unmount(){mE.delete(this.current),this.projection&&this.projection.unmount(),yi(this.notifyUpdate),yi(this.render),this.valueSubscriptions.forEach(t=>t()),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent&&this.parent.children.delete(this);for(const t in this.events)this.events[t].clear();for(const t in this.features)this.features[t].unmount();this.current=null}bindToMotionValue(t,n){const r=_a.has(t),s=n.on("change",o=>{this.latestValues[t]=o,this.props.onUpdate&&gn.update(this.notifyUpdate,!1,!0),r&&this.projection&&(this.projection.isTransformDirty=!0)}),i=n.on("renderRequest",this.scheduleRender);this.valueSubscriptions.set(t,()=>{s(),i()})}sortNodePosition(t){return!this.current||!this.sortInstanceNodePosition||this.type!==t.type?0:this.sortInstanceNodePosition(this.current,t.current)}loadFeatures({children:t,...n},r,s,i){let o,a;for(let l=0;l<oV;l++){const u=NI[l],{isEnabled:p,Feature:c,ProjectionNode:d,MeasureLayout:f}=ac[u];d&&(o=d),p(n)&&(!this.features[u]&&c&&(this.features[u]=new c(this)),f&&(a=f))}if((this.type==="html"||this.type==="svg")&&!this.projection&&o){this.projection=new o(this.latestValues,this.parent&&this.parent.projection);const{layoutId:l,layout:u,drag:p,dragConstraints:c,layoutScroll:d,layoutRoot:f}=n;this.projection.setOptions({layoutId:l,layout:u,alwaysMeasureLayout:!!p||c&&Ya(c),visualElement:this,scheduleRender:()=>this.scheduleRender(),animationType:typeof u=="string"?u:"both",initialPromotionConfig:i,layoutScroll:d,layoutRoot:f})}return a}updateFeatures(){for(const t in this.features){const n=this.features[t];n.isMounted?n.update():(n.mount(),n.isMounted=!0)}}triggerBuild(){this.build(this.renderState,this.latestValues,this.options,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):$n()}getStaticValue(t){return this.latestValues[t]}setStaticValue(t,n){this.latestValues[t]=n}makeTargetAnimatable(t,n=!0){return this.makeTargetAnimatableFromInstance(t,n)}update(t,n){(t.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=t,this.prevPresenceContext=this.presenceContext,this.presenceContext=n;for(let r=0;r<_E.length;r++){const s=_E[r];this.propEventSubscriptions[s]&&(this.propEventSubscriptions[s](),delete this.propEventSubscriptions[s]);const i=t["on"+s];i&&(this.propEventSubscriptions[s]=this.on(s,i))}this.prevMotionValues=iV(this,this.scrapeMotionValuesFromProps(t,this.prevProps),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(t){return this.props.variants?this.props.variants[t]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}getVariantContext(t=!1){if(t)return this.parent?this.parent.getVariantContext():void 0;if(!this.isControllingVariants){const r=this.parent?this.parent.getVariantContext()||{}:{};return this.props.initial!==void 0&&(r.initial=this.props.initial),r}const n={};for(let r=0;r<aV;r++){const s=ny[r],i=this.props[s];(oc(i)||i===!1)&&(n[s]=i)}return n}addVariantChild(t){const n=this.getClosestVariantNode();if(n)return n.variantChildren&&n.variantChildren.add(t),()=>n.variantChildren.delete(t)}addValue(t,n){n!==this.values.get(t)&&(this.removeValue(t),this.bindToMotionValue(t,n)),this.values.set(t,n),this.latestValues[t]=n.get()}removeValue(t){this.values.delete(t);const n=this.valueSubscriptions.get(t);n&&(n(),this.valueSubscriptions.delete(t)),delete this.latestValues[t],this.removeValueFromRenderState(t,this.renderState)}hasValue(t){return this.values.has(t)}getValue(t,n){if(this.props.values&&this.props.values[t])return this.props.values[t];let r=this.values.get(t);return r===void 0&&n!==void 0&&(r=_l(n,{owner:this}),this.addValue(t,r)),r}readValue(t){var n;return this.latestValues[t]!==void 0||!this.current?this.latestValues[t]:(n=this.getBaseTargetFromProps(this.props,t))!==null&&n!==void 0?n:this.readValueFromInstance(this.current,t,this.options)}setBaseTarget(t,n){this.baseTarget[t]=n}getBaseTarget(t){var n;const{initial:r}=this.props,s=typeof r=="string"||typeof r=="object"?(n=cy(this.props,r))===null||n===void 0?void 0:n[t]:void 0;if(r&&s!==void 0)return s;const i=this.getBaseTargetFromProps(this.props,t);return i!==void 0&&!Ir(i)?i:this.initialValues[t]!==void 0&&s===void 0?void 0:this.baseTarget[t]}on(t,n){return this.events[t]||(this.events[t]=new wy),this.events[t].add(n)}notify(t,...n){this.events[t]&&this.events[t].notify(...n)}}class jI extends lV{sortInstanceNodePosition(t,n){return t.compareDocumentPosition(n)&2?1:-1}getBaseTargetFromProps(t,n){return t.style?t.style[n]:void 0}removeValueFromRenderState(t,{vars:n,style:r}){delete n[t],delete r[t]}makeTargetAnimatableFromInstance({transition:t,transitionEnd:n,...r},s){const i=Ej(r,t||{},this);if(s){bj(this,r,i);const o=rV(this,r,i,n);n=o.transitionEnd,r=o.target}return{transition:t,transitionEnd:n,...r}}}function uV(e){return window.getComputedStyle(e)}class cV extends jI{constructor(){super(...arguments),this.type="html"}readValueFromInstance(t,n){if(_a.has(n)){const r=my(n);return r&&r.default||0}else{const r=uV(t),s=(F$(n)?r.getPropertyValue(n):r[n])||0;return typeof s=="string"?s.trim():s}}measureInstanceViewportBox(t,{transformPagePoint:n}){return CI(t,n)}build(t,n,r,s){iy(t,n,r,s.transformTemplate)}scrapeMotionValuesFromProps(t,n){return uy(t,n)}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:t}=this.props;Ir(t)&&(this.childSubscription=t.on("change",n=>{this.current&&(this.current.textContent=`${n}`)}))}renderInstance(t,n,r,s){N$(t,n,r,s)}}class dV extends jI{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1}getBaseTargetFromProps(t,n){return t[n]}readValueFromInstance(t,n){if(_a.has(n)){const r=my(n);return r&&r.default||0}return n=j$.has(n)?n:Z0(n),t.getAttribute(n)}measureInstanceViewportBox(){return $n()}scrapeMotionValuesFromProps(t,n){return U$(t,n)}build(t,n,r,s){ay(t,n,r,this.isSVGTag,s.transformTemplate)}renderInstance(t,n,r,s){V$(t,n,r,s)}mount(t){this.isSVGTag=ly(t.tagName),super.mount(t)}}const pV=(e,t)=>ry(e)?new dV(t,{enableHardwareAcceleration:!1}):new cV(t,{enableHardwareAcceleration:!0}),fV={layout:{ProjectionNode:zI,MeasureLayout:$I}},hV={...Nj,...tN,...G4,...fV},an=cB((e,t)=>VB(e,t,hV,pV)),_p=new Map,Go=[],mV=(e,t,n)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){const r=_p.get(e);if(r===void 0)_p.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){const s=Go.indexOf(e);s!==-1&&Go.splice(s,1);for(let i=0;i<Go.length;i++)if(_p.get(Go[i]).priority<=n){Go.splice(i,0,e);return}Go.push(e)}return}throw new TypeError("not a valid backend")},_V=async e=>{const t=_p.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{const n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(r){return n||(t.error=`${r}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},gV=async e=>{const t=e.executionProviders||[],n=t.map(l=>typeof l=="string"?l:l.name),r=n.length===0?Go:n;let s;const i=[],o=new Set;for(const l of r){const u=await _V(l);typeof u=="string"?i.push({name:l,err:u}):(s||(s=u),s===u&&o.add(l))}if(!s)throw new Error(`no available backend found. ERR: ${i.map(l=>`[${l.name}] ${l.err}`).join(", ")}`);for(const{name:l,err:u}of i)n.includes(l)&&console.warn(`removing requested execution provider "${l}" from session options because it is not available: ${u}`);const a=t.filter(l=>o.has(typeof l=="string"?l:l.name));return[s,new Proxy(e,{get:(l,u)=>u==="executionProviders"?a:Reflect.get(l,u)})]},yV="1.21.0";let gE="warning";const Fs={wasm:{},webgl:{},webgpu:{},versions:{common:yV},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);gE=e}},get logLevel(){return gE}};Object.defineProperty(Fs,"logLevel",{enumerable:!0});const vV=Fs,wV=(e,t)=>{const n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];const r=n.getContext("2d");if(r!=null){let s,i;(t==null?void 0:t.tensorLayout)!==void 0&&t.tensorLayout==="NHWC"?(s=e.dims[2],i=e.dims[3]):(s=e.dims[3],i=e.dims[2]);const o=(t==null?void 0:t.format)!==void 0?t.format:"RGB",a=t==null?void 0:t.norm;let l,u;a===void 0||a.mean===void 0?l=[255,255,255,255]:typeof a.mean=="number"?l=[a.mean,a.mean,a.mean,a.mean]:(l=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(l[3]=a.mean[3])),a===void 0||a.bias===void 0?u=[0,0,0,0]:typeof a.bias=="number"?u=[a.bias,a.bias,a.bias,a.bias]:(u=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(u[3]=a.bias[3]));const p=i*s;let c=0,d=p,f=p*2,m=-1;o==="RGBA"?(c=0,d=p,f=p*2,m=p*3):o==="RGB"?(c=0,d=p,f=p*2):o==="RBG"&&(c=0,f=p,d=p*2);for(let y=0;y<i;y++)for(let C=0;C<s;C++){const _=(e.data[c++]-u[0])*l[0],h=(e.data[d++]-u[1])*l[1],w=(e.data[f++]-u[2])*l[2],M=m===-1?255:(e.data[m++]-u[3])*l[3];r.fillStyle="rgba("+_+","+h+","+w+","+M+")",r.fillRect(C,y,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},MV=(e,t)=>{const n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let r;if(n!=null){let s,i,o;(t==null?void 0:t.tensorLayout)!==void 0&&t.tensorLayout==="NHWC"?(s=e.dims[2],i=e.dims[1],o=e.dims[3]):(s=e.dims[3],i=e.dims[2],o=e.dims[1]);const a=t!==void 0&&t.format!==void 0?t.format:"RGB",l=t==null?void 0:t.norm;let u,p;l===void 0||l.mean===void 0?u=[255,255,255,255]:typeof l.mean=="number"?u=[l.mean,l.mean,l.mean,l.mean]:(u=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(u[3]=l.mean[3])),l===void 0||l.bias===void 0?p=[0,0,0,0]:typeof l.bias=="number"?p=[l.bias,l.bias,l.bias,l.bias]:(p=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(p[3]=l.bias[3]));const c=i*s;if(t!==void 0&&(t.format!==void 0&&o===4&&t.format!=="RGBA"||o===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const d=4;let f=0,m=1,y=2,C=3,_=0,h=c,w=c*2,M=-1;a==="RGBA"?(_=0,h=c,w=c*2,M=c*3):a==="RGB"?(_=0,h=c,w=c*2):a==="RBG"&&(_=0,w=c,h=c*2),r=n.createImageData(s,i);for(let x=0;x<i*s;f+=d,m+=d,y+=d,C+=d,x++)r.data[f]=(e.data[_++]-p[0])*u[0],r.data[m]=(e.data[h++]-p[1])*u[1],r.data[y]=(e.data[w++]-p[2])*u[2],r.data[C]=M===-1?255:(e.data[M++]-p[3])*u[3]}else throw new Error("Can not access image data");return r},Cm=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:n,width:r}=t,s=t.norm??{mean:255,bias:0};let i,o;typeof s.mean=="number"?i=[s.mean,s.mean,s.mean,s.mean]:i=[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],typeof s.bias=="number"?o=[s.bias,s.bias,s.bias,s.bias]:o=[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];const a=t.format!==void 0?t.format:"RGBA",l=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",u=n*r,p=l==="RGBA"?new Float32Array(u*4):new Float32Array(u*3);let c=4,d=0,f=1,m=2,y=3,C=0,_=u,h=u*2,w=-1;a==="RGB"&&(c=3,d=0,f=1,m=2,y=-1),l==="RGBA"?w=u*3:l==="RBG"?(C=0,h=u,_=u*2):l==="BGR"&&(h=0,_=u,C=u*2);for(let x=0;x<u;x++,d+=c,m+=c,f+=c,y+=c)p[C++]=(e[d]+o[0])/i[0],p[_++]=(e[f]+o[1])/i[1],p[h++]=(e[m]+o[2])/i[2],w!==-1&&y!==-1&&(p[w++]=(e[y]+o[3])/i[3]);return l==="RGBA"?new ls("float32",p,[1,4,n,r]):new ls("float32",p,[1,3,n,r])},xV=async(e,t)=>{const n=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,r=typeof ImageData<"u"&&e instanceof ImageData,s=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,i=typeof e=="string";let o,a=t??{};const l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=p=>typeof HTMLCanvasElement<"u"&&p instanceof HTMLCanvasElement||p instanceof OffscreenCanvas?p.getContext("2d"):null;if(n){const p=l();p.width=e.width,p.height=e.height;const c=u(p);if(c!=null){let d=e.height,f=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(d=t.resizedHeight,f=t.resizedWidth),t!==void 0){if(a=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");a.tensorFormat="RGBA",a.height=d,a.width=f}else a.tensorFormat="RGBA",a.height=d,a.width=f;c.drawImage(e,0,0),o=c.getImageData(0,0,f,d).data}else throw new Error("Can not access image data")}else if(r){let p,c;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(p=t.resizedHeight,c=t.resizedWidth):(p=e.height,c=e.width),t!==void 0&&(a=t),a.format="RGBA",a.height=p,a.width=c,t!==void 0){const d=l();d.width=c,d.height=p;const f=u(d);if(f!=null)f.putImageData(e,0,0),o=f.getImageData(0,0,c,p).data;else throw new Error("Can not access image data")}else o=e.data}else if(s){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");const p=l();p.width=e.width,p.height=e.height;const c=u(p);if(c!=null){const d=e.height,f=e.width;return c.drawImage(e,0,0,f,d),o=c.getImageData(0,0,f,d).data,a.height=d,a.width=f,Cm(o,a)}else throw new Error("Can not access image data")}else{if(i)return new Promise((p,c)=>{const d=l(),f=u(d);if(!e||!f)return c();const m=new Image;m.crossOrigin="Anonymous",m.src=e,m.onload=()=>{d.width=m.width,d.height=m.height,f.drawImage(m,0,0,d.width,d.height);const y=f.getImageData(0,0,d.width,d.height);a.height=d.height,a.width=d.width,p(Cm(y.data,a))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(o!==void 0)return Cm(o,a);throw new Error("Input data provided is not supported - aborted tensor creation")},bV=(e,t)=>{const{width:n,height:r,download:s,dispose:i}=t,o=[1,r,n,4];return new ls({location:"texture",type:"float32",texture:e,dims:o,download:s,dispose:i})},TV=(e,t)=>{const{dataType:n,dims:r,download:s,dispose:i}=t;return new ls({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:s,dispose:i})},EV=(e,t)=>{const{dataType:n,dims:r,download:s,dispose:i}=t;return new ls({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:r,download:s,dispose:i})},PV=(e,t,n)=>new ls({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]}),tl=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),gp=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let yE=!1;const SV=()=>{if(!yE){yE=!0;const e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,n=globalThis.Float16Array,r=typeof n<"u"&&n.from;e&&(tl.set("int64",BigInt64Array),gp.set(BigInt64Array,"int64")),t&&(tl.set("uint64",BigUint64Array),gp.set(BigUint64Array,"uint64")),r?(tl.set("float16",n),gp.set(n,"float16")):tl.set("float16",Uint16Array)}},CV=e=>{let t=1;for(let n=0;n<e.length;n++){const r=e[n];if(typeof r!="number"||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},kV=(e,t)=>{switch(e.location){case"cpu":return new ls(e.type,e.data,t);case"cpu-pinned":return new ls({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new ls({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new ls({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new ls({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}};let ls=class{constructor(t,n,r){SV();let s,i;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,s=t.type,i=t.dims,t.location){case"cpu-pinned":{const a=tl.get(s);if(!a)throw new TypeError(`unsupported type "${s}" to create tensor from pinned buffer`);if(!(t.data instanceof a))throw new TypeError(`buffer should be of type ${a.name}`);this.cpuData=t.data;break}case"texture":{if(s!=="float32")throw new TypeError(`unsupported type "${s}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case"ml-tensor":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint64"&&s!=="int8"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,l;if(typeof t=="string")if(s=t,l=r,t==="string"){if(!Array.isArray(n))throw new TypeError("A string tensor's data must be a string array.");a=n}else{const u=tl.get(t);if(u===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(n)){if(t==="float16"&&u===Uint16Array||t==="uint4"||t==="int4")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${u.name} as data.`);t==="uint64"||t==="int64"?a=u.from(n,BigInt):a=u.from(n)}else if(n instanceof u)a=n;else if(n instanceof Uint8ClampedArray)if(t==="uint8")a=Uint8Array.from(n);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(t==="float16"&&n instanceof Uint16Array&&u!==Uint16Array)a=new globalThis.Float16Array(n.buffer,n.byteOffset,n.length);else throw new TypeError(`A ${s} tensor's data must be type of ${u}`)}else if(l=n,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const u=typeof t[0];if(u==="string")s="string",a=t;else if(u==="boolean")s="bool",a=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${u}.`)}else if(t instanceof Uint8ClampedArray)s="uint8",a=Uint8Array.from(t);else{const u=gp.get(t.constructor);if(u===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);s=u,a=t}if(l===void 0)l=[a.length];else if(!Array.isArray(l))throw new TypeError("A tensor's dims must be a number array");i=l,this.cpuData=a,this.dataLocation="cpu"}const o=CV(i);if(this.cpuData&&o!==this.cpuData.length&&!((s==="uint4"||s==="int4")&&Math.ceil(o/2)===this.cpuData.length))throw new Error(`Tensor's size(${o}) does not match data length(${this.cpuData.length}).`);this.type=s,this.dims=i,this.size=o}static async fromImage(t,n){return xV(t,n)}static fromTexture(t,n){return bV(t,n)}static fromGpuBuffer(t,n){return TV(t,n)}static fromMLTensor(t,n){return EV(t,n)}static fromPinnedBuffer(t,n,r){return PV(t,n,r)}toDataURL(t){return wV(this,t)}toImageData(t){return MV(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const n=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=n,t&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return kV(this,t)}};const za=ls,VI=(e,t)=>{(typeof Fs.trace>"u"?!Fs.wasm.trace:!Fs.trace)||console.timeStamp(`${e}::ORT::${t}`)},UI=(e,t)=>{var s;const n=((s=new Error().stack)==null?void 0:s.split(/\r\n|\r|\n/g))||[];let r=!1;for(let i=0;i<n.length;i++){if(r&&!n[i].includes("TRACE_FUNC")){let o=`FUNC_${e}::${n[i].trim().split(" ")[1]}`;t&&(o+=`::${t}`),VI("CPU",o);return}n[i].includes("TRACE_FUNC")&&(r=!0)}},zg=e=>{(typeof Fs.trace>"u"?!Fs.wasm.trace:!Fs.trace)||UI("BEGIN",e)},Rg=e=>{(typeof Fs.trace>"u"?!Fs.wasm.trace:!Fs.trace)||UI("END",e)};let $V=class WI{constructor(t){this.handler=t}async run(t,n,r){zg();const s={};let i={};if(typeof t!="object"||t===null||t instanceof za||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof za)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");o=!1;for(const u of n){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);s[u]=null}if(typeof r=="object"&&r!==null)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else{let u=!1;const p=Object.getOwnPropertyNames(n);for(const c of this.outputNames)if(p.indexOf(c)!==-1){const d=n[c];(d===null||d instanceof za)&&(u=!0,o=!1,s[c]=d)}if(u){if(typeof r=="object"&&r!==null)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else i=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const u of this.inputNames)if(typeof t[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(o)for(const u of this.outputNames)s[u]=null;const a=await this.handler.run(t,s,i),l={};for(const u in a)if(Object.hasOwnProperty.call(a,u)){const p=a[u];p instanceof za?l[u]=p:l[u]=new za(p.type,p.data,p.dims)}return Rg(),l}async release(){return this.handler.dispose()}static async create(t,n,r,s){zg();let i,o={};if(typeof t=="string"){if(i=t,typeof n=="object"&&n!==null)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(i=t,typeof n=="object"&&n!==null)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){const p=t;let c=0,d=t.byteLength;if(typeof n=="object"&&n!==null)o=n;else if(typeof n=="number"){if(c=n,!Number.isSafeInteger(c))throw new RangeError("'byteOffset' must be an integer.");if(c<0||c>=p.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${p.byteLength}).`);if(d=t.byteLength-c,typeof r=="number"){if(d=r,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||c+d>p.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${p.byteLength-c}].`);if(typeof s=="object"&&s!==null)o=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(typeof r<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(p,c,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const[a,l]=await gV(o),u=await a.createInferenceSessionHandler(i,l);return Rg(),new WI(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};const IV=$V,AV=Object.freeze(Object.defineProperty({__proto__:null,InferenceSession:IV,TRACE:VI,TRACE_FUNC_BEGIN:zg,TRACE_FUNC_END:Rg,Tensor:za,env:vV,registerBackend:mV},Symbol.toStringTag,{value:"Module"}));/*!
 * ONNX Runtime Web v1.22.0-dev.20250409-89f8206ba4
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var My=Object.defineProperty,DV=Object.getOwnPropertyDescriptor,OV=Object.getOwnPropertyNames,FV=Object.prototype.hasOwnProperty,LV=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),Ue=(e,t)=>()=>(e&&(t=e(e=0)),t),Tl=(e,t)=>{for(var n in t)My(e,n,{get:t[n],enumerable:!0})},zV=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of OV(t))!FV.call(e,s)&&s!==n&&My(e,s,{get:()=>t[s],enumerable:!(r=DV(t,s))||r.enumerable});return e},uc=e=>zV(My({},"__esModule",{value:!0}),e),lu,Ai,Jo,vE,GI,HI=Ue(()=>{lu=new Map,Ai=[],Jo=(e,t,n)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let r=lu.get(e);if(r===void 0)lu.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let s=Ai.indexOf(e);s!==-1&&Ai.splice(s,1);for(let i=0;i<Ai.length;i++)if(lu.get(Ai[i]).priority<=n){Ai.splice(i,0,e);return}Ai.push(e)}return}throw new TypeError("not a valid backend")},vE=async e=>{let t=lu.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(r){return n||(t.error=`${r}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},GI=async e=>{let t=e.executionProviders||[],n=t.map(l=>typeof l=="string"?l:l.name),r=n.length===0?Ai:n,s,i=[],o=new Set;for(let l of r){let u=await vE(l);typeof u=="string"?i.push({name:l,err:u}):(s||(s=u),s===u&&o.add(l))}if(!s)throw new Error(`no available backend found. ERR: ${i.map(l=>`[${l.name}] ${l.err}`).join(", ")}`);for(let{name:l,err:u}of i)n.includes(l)&&console.warn(`removing requested execution provider "${l}" from session options because it is not available: ${u}`);let a=t.filter(l=>o.has(typeof l=="string"?l:l.name));return[s,new Proxy(e,{get:(l,u)=>u==="executionProviders"?a:Reflect.get(l,u)})]}}),RV=Ue(()=>{HI()}),KI,BV=Ue(()=>{KI="1.22.0-dev.20250409-89f8206ba4"}),km,is,qI=Ue(()=>{BV(),km="warning",is={wasm:{},webgl:{},webgpu:{},versions:{common:KI},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);km=e}},get logLevel(){return km}},Object.defineProperty(is,"logLevel",{enumerable:!0})}),Zt,NV=Ue(()=>{qI(),Zt=is}),QI,XI,jV=Ue(()=>{QI=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let r=n.getContext("2d");if(r!=null){let s,i;(t==null?void 0:t.tensorLayout)!==void 0&&t.tensorLayout==="NHWC"?(s=e.dims[2],i=e.dims[3]):(s=e.dims[3],i=e.dims[2]);let o=(t==null?void 0:t.format)!==void 0?t.format:"RGB",a=t==null?void 0:t.norm,l,u;a===void 0||a.mean===void 0?l=[255,255,255,255]:typeof a.mean=="number"?l=[a.mean,a.mean,a.mean,a.mean]:(l=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(l[3]=a.mean[3])),a===void 0||a.bias===void 0?u=[0,0,0,0]:typeof a.bias=="number"?u=[a.bias,a.bias,a.bias,a.bias]:(u=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(u[3]=a.bias[3]));let p=i*s,c=0,d=p,f=p*2,m=-1;o==="RGBA"?(c=0,d=p,f=p*2,m=p*3):o==="RGB"?(c=0,d=p,f=p*2):o==="RBG"&&(c=0,f=p,d=p*2);for(let y=0;y<i;y++)for(let C=0;C<s;C++){let _=(e.data[c++]-u[0])*l[0],h=(e.data[d++]-u[1])*l[1],w=(e.data[f++]-u[2])*l[2],M=m===-1?255:(e.data[m++]-u[3])*l[3];r.fillStyle="rgba("+_+","+h+","+w+","+M+")",r.fillRect(C,y,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},XI=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),r;if(n!=null){let s,i,o;(t==null?void 0:t.tensorLayout)!==void 0&&t.tensorLayout==="NHWC"?(s=e.dims[2],i=e.dims[1],o=e.dims[3]):(s=e.dims[3],i=e.dims[2],o=e.dims[1]);let a=t!==void 0&&t.format!==void 0?t.format:"RGB",l=t==null?void 0:t.norm,u,p;l===void 0||l.mean===void 0?u=[255,255,255,255]:typeof l.mean=="number"?u=[l.mean,l.mean,l.mean,l.mean]:(u=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(u[3]=l.mean[3])),l===void 0||l.bias===void 0?p=[0,0,0,0]:typeof l.bias=="number"?p=[l.bias,l.bias,l.bias,l.bias]:(p=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(p[3]=l.bias[3]));let c=i*s;if(t!==void 0&&(t.format!==void 0&&o===4&&t.format!=="RGBA"||o===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let d=4,f=0,m=1,y=2,C=3,_=0,h=c,w=c*2,M=-1;a==="RGBA"?(_=0,h=c,w=c*2,M=c*3):a==="RGB"?(_=0,h=c,w=c*2):a==="RBG"&&(_=0,w=c,h=c*2),r=n.createImageData(s,i);for(let x=0;x<i*s;f+=d,m+=d,y+=d,C+=d,x++)r.data[f]=(e.data[_++]-p[0])*u[0],r.data[m]=(e.data[h++]-p[1])*u[1],r.data[y]=(e.data[w++]-p[2])*u[2],r.data[C]=M===-1?255:(e.data[M++]-p[3])*u[3]}else throw new Error("Can not access image data");return r}}),Nd,YI,JI,ZI,eA,tA,VV=Ue(()=>{xy(),Nd=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:r}=t,s=t.norm??{mean:255,bias:0},i,o;typeof s.mean=="number"?i=[s.mean,s.mean,s.mean,s.mean]:i=[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],typeof s.bias=="number"?o=[s.bias,s.bias,s.bias,s.bias]:o=[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];let a=t.format!==void 0?t.format:"RGBA",l=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",u=n*r,p=l==="RGBA"?new Float32Array(u*4):new Float32Array(u*3),c=4,d=0,f=1,m=2,y=3,C=0,_=u,h=u*2,w=-1;a==="RGB"&&(c=3,d=0,f=1,m=2,y=-1),l==="RGBA"?w=u*3:l==="RBG"?(C=0,h=u,_=u*2):l==="BGR"&&(h=0,_=u,C=u*2);for(let M=0;M<u;M++,d+=c,m+=c,f+=c,y+=c)p[C++]=(e[d]+o[0])/i[0],p[_++]=(e[f]+o[1])/i[1],p[h++]=(e[m]+o[2])/i[2],w!==-1&&y!==-1&&(p[w++]=(e[y]+o[3])/i[3]);return l==="RGBA"?new Ur("float32",p,[1,4,n,r]):new Ur("float32",p,[1,3,n,r])},YI=async(e,t)=>{let n=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,r=typeof ImageData<"u"&&e instanceof ImageData,s=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,i=typeof e=="string",o,a=t??{},l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=p=>typeof HTMLCanvasElement<"u"&&p instanceof HTMLCanvasElement||p instanceof OffscreenCanvas?p.getContext("2d"):null;if(n){let p=l();p.width=e.width,p.height=e.height;let c=u(p);if(c!=null){let d=e.height,f=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(d=t.resizedHeight,f=t.resizedWidth),t!==void 0){if(a=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");a.tensorFormat="RGBA",a.height=d,a.width=f}else a.tensorFormat="RGBA",a.height=d,a.width=f;c.drawImage(e,0,0),o=c.getImageData(0,0,f,d).data}else throw new Error("Can not access image data")}else if(r){let p,c;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(p=t.resizedHeight,c=t.resizedWidth):(p=e.height,c=e.width),t!==void 0&&(a=t),a.format="RGBA",a.height=p,a.width=c,t!==void 0){let d=l();d.width=c,d.height=p;let f=u(d);if(f!=null)f.putImageData(e,0,0),o=f.getImageData(0,0,c,p).data;else throw new Error("Can not access image data")}else o=e.data}else if(s){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");let p=l();p.width=e.width,p.height=e.height;let c=u(p);if(c!=null){let d=e.height,f=e.width;return c.drawImage(e,0,0,f,d),o=c.getImageData(0,0,f,d).data,a.height=d,a.width=f,Nd(o,a)}else throw new Error("Can not access image data")}else{if(i)return new Promise((p,c)=>{let d=l(),f=u(d);if(!e||!f)return c();let m=new Image;m.crossOrigin="Anonymous",m.src=e,m.onload=()=>{d.width=m.width,d.height=m.height,f.drawImage(m,0,0,d.width,d.height);let y=f.getImageData(0,0,d.width,d.height);a.height=d.height,a.width=d.width,p(Nd(y.data,a))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(o!==void 0)return Nd(o,a);throw new Error("Input data provided is not supported - aborted tensor creation")},JI=(e,t)=>{let{width:n,height:r,download:s,dispose:i}=t,o=[1,r,n,4];return new Ur({location:"texture",type:"float32",texture:e,dims:o,download:s,dispose:i})},ZI=(e,t)=>{let{dataType:n,dims:r,download:s,dispose:i}=t;return new Ur({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:s,dispose:i})},eA=(e,t)=>{let{dataType:n,dims:r,download:s,dispose:i}=t;return new Ur({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:r,download:s,dispose:i})},tA=(e,t,n)=>new Ur({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})}),Ho,bu,$m,nA,UV=Ue(()=>{Ho=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),bu=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),$m=!1,nA=()=>{if(!$m){$m=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,n=globalThis.Float16Array,r=typeof n<"u"&&n.from;e&&(Ho.set("int64",BigInt64Array),bu.set(BigInt64Array,"int64")),t&&(Ho.set("uint64",BigUint64Array),bu.set(BigUint64Array,"uint64")),r?(Ho.set("float16",n),bu.set(n,"float16")):Ho.set("float16",Uint16Array)}}}),rA,sA,WV=Ue(()=>{xy(),rA=e=>{let t=1;for(let n=0;n<e.length;n++){let r=e[n];if(typeof r!="number"||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},sA=(e,t)=>{switch(e.location){case"cpu":return new Ur(e.type,e.data,t);case"cpu-pinned":return new Ur({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Ur({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Ur({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new Ur({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),Ur,xy=Ue(()=>{jV(),VV(),UV(),WV(),Ur=class{constructor(e,t,n){nA();let r,s;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,r=e.type,s=e.dims,e.location){case"cpu-pinned":{let o=Ho.get(r);if(!o)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof o))throw new TypeError(`buffer should be of type ${o.name}`);this.cpuData=e.data;break}case"texture":{if(r!=="float32")throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(r!=="float32"&&r!=="float16"&&r!=="int32"&&r!=="int64"&&r!=="uint32"&&r!=="uint64"&&r!=="int8"&&r!=="uint8"&&r!=="bool"&&r!=="uint4"&&r!=="int4")throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let o,a;if(typeof e=="string")if(r=e,a=n,e==="string"){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");o=t}else{let l=Ho.get(e);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if(e==="float16"&&l===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${l.name} as data.`);e==="uint64"||e==="int64"?o=l.from(t,BigInt):o=l.from(t)}else if(t instanceof l)o=t;else if(t instanceof Uint8ClampedArray)if(e==="uint8")o=Uint8Array.from(t);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(e==="float16"&&t instanceof Uint16Array&&l!==Uint16Array)o=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length);else throw new TypeError(`A ${r} tensor's data must be type of ${l}`)}else if(a=t,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let l=typeof e[0];if(l==="string")r="string",o=e;else if(l==="boolean")r="bool",o=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${l}.`)}else if(e instanceof Uint8ClampedArray)r="uint8",o=Uint8Array.from(e);else{let l=bu.get(e.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=l,o=e}if(a===void 0)a=[o.length];else if(!Array.isArray(a))throw new TypeError("A tensor's dims must be a number array");s=a,this.cpuData=o,this.dataLocation="cpu"}let i=rA(s);if(this.cpuData&&i!==this.cpuData.length&&!((r==="uint4"||r==="int4")&&Math.ceil(i/2)===this.cpuData.length))throw new Error(`Tensor's size(${i}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=s,this.size=i}static async fromImage(e,t){return YI(e,t)}static fromTexture(e,t){return JI(e,t)}static fromGpuBuffer(e,t){return ZI(e,t)}static fromMLTensor(e,t){return eA(e,t)}static fromPinnedBuffer(e,t,n){return tA(e,t,n)}toDataURL(e){return QI(this,e)}toImageData(e){return XI(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return sA(this,e)}}}),As,iA=Ue(()=>{xy(),As=Ur}),cc,Im,zs,ds,oA=Ue(()=>{qI(),cc=(e,t)=>{(typeof is.trace>"u"?!is.wasm.trace:!is.trace)||console.timeStamp(`${e}::ORT::${t}`)},Im=(e,t)=>{var s;let n=((s=new Error().stack)==null?void 0:s.split(/\r\n|\r|\n/g))||[],r=!1;for(let i=0;i<n.length;i++){if(r&&!n[i].includes("TRACE_FUNC")){let o=`FUNC_${e}::${n[i].trim().split(" ")[1]}`;t&&(o+=`::${t}`),cc("CPU",o);return}n[i].includes("TRACE_FUNC")&&(r=!0)}},zs=e=>{(typeof is.trace>"u"?!is.wasm.trace:!is.trace)||Im("BEGIN",e)},ds=e=>{(typeof is.trace>"u"?!is.wasm.trace:!is.trace)||Im("END",e)}}),aA,GV=Ue(()=>{HI(),iA(),oA(),aA=class lA{constructor(t){this.handler=t}async run(t,n,r){zs();let s={},i={};if(typeof t!="object"||t===null||t instanceof As||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof As)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");o=!1;for(let u of n){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);s[u]=null}if(typeof r=="object"&&r!==null)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else{let u=!1,p=Object.getOwnPropertyNames(n);for(let c of this.outputNames)if(p.indexOf(c)!==-1){let d=n[c];(d===null||d instanceof As)&&(u=!0,o=!1,s[c]=d)}if(u){if(typeof r=="object"&&r!==null)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else i=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let u of this.inputNames)if(typeof t[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(o)for(let u of this.outputNames)s[u]=null;let a=await this.handler.run(t,s,i),l={};for(let u in a)if(Object.hasOwnProperty.call(a,u)){let p=a[u];p instanceof As?l[u]=p:l[u]=new As(p.type,p.data,p.dims)}return ds(),l}async release(){return this.handler.dispose()}static async create(t,n,r,s){zs();let i,o={};if(typeof t=="string"){if(i=t,typeof n=="object"&&n!==null)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(i=t,typeof n=="object"&&n!==null)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let p=t,c=0,d=t.byteLength;if(typeof n=="object"&&n!==null)o=n;else if(typeof n=="number"){if(c=n,!Number.isSafeInteger(c))throw new RangeError("'byteOffset' must be an integer.");if(c<0||c>=p.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${p.byteLength}).`);if(d=t.byteLength-c,typeof r=="number"){if(d=r,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||c+d>p.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${p.byteLength-c}].`);if(typeof s=="object"&&s!==null)o=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(typeof r<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(p,c,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[a,l]=await GI(o),u=await a.createInferenceSessionHandler(i,l);return ds(),new lA(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),by,HV=Ue(()=>{GV(),by=aA}),KV=Ue(()=>{}),qV=Ue(()=>{}),QV=Ue(()=>{}),XV=Ue(()=>{}),uA={};Tl(uA,{InferenceSession:()=>by,TRACE:()=>cc,TRACE_FUNC_BEGIN:()=>zs,TRACE_FUNC_END:()=>ds,Tensor:()=>As,env:()=>Zt,registerBackend:()=>Jo});var Rs=Ue(()=>{RV(),NV(),HV(),iA(),KV(),qV(),oA(),QV(),XV()}),Ty=Ue(()=>{}),cA={};Tl(cA,{default:()=>dA});var Am,Dm,dA,YV=Ue(()=>{var e;_F(),ga(),Ey(),Am="ort-wasm-proxy-worker",Dm=((e=globalThis.self)==null?void 0:e.name)===Am,Dm&&(self.onmessage=t=>{let{type:n,in:r}=t.data;try{switch(n){case"init-wasm":Py(r.wasm).then(()=>{Wy(r).then(()=>{postMessage({type:n})},s=>{postMessage({type:n,err:s})})},s=>{postMessage({type:n,err:s})});break;case"init-ep":{let{epName:s,env:i}=r;Gy(i,s).then(()=>{postMessage({type:n})},o=>{postMessage({type:n,err:o})});break}case"copy-from":{let{buffer:s}=r,i=uf(s);postMessage({type:n,out:i});break}case"create":{let{model:s,options:i}=r;Hy(s,i).then(o=>{postMessage({type:n,out:o})},o=>{postMessage({type:n,err:o})});break}case"release":Ky(r),postMessage({type:n});break;case"run":{let{sessionId:s,inputIndices:i,inputs:o,outputIndices:a,options:l}=r;qy(s,i,o,a,new Array(a.length).fill(null),l).then(u=>{u.some(p=>p[3]!=="cpu")?postMessage({type:n,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:n,out:u},Xy([...o,...u]))},u=>{postMessage({type:n,err:u})});break}case"end-profiling":Qy(r),postMessage({type:n});break;default:}}catch(s){postMessage({type:n,err:s})}}),dA=Dm?null:t=>new Worker(t??Nr,{type:"module",name:Am})}),pA={};Tl(pA,{default:()=>fA});var Om,Fm,fA,wE,JV=Ue(()=>{var e,t;Fm=(Om=import.meta.url,async function(n={}){var Xl;var r,s,i=n,o=new Promise((g,P)=>{r=g,s=P}),a=typeof window=="object",l=typeof WorkerGlobalScope<"u",u=l&&((Xl=self.name)==null?void 0:Xl.startsWith("em-pthread"));i.mountExternalData=(g,P)=>{g.startsWith("./")&&(g=g.substring(2)),(i.Eb||(i.Eb=new Map)).set(g,P)},i.unmountExternalData=()=>{delete i.Eb};var p=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,pc:!0}).buffer.constructor;let c=g=>async(...P)=>{var D;try{if(i.Fb)throw Error("Session already started");let B=i.Fb={dc:P[0],errors:[]},W=await g(...P);if(i.Fb!==B)throw Error("Session mismatch");(D=i.Jb)==null||D.flush();let ce=B.errors;if(0<ce.length){let Pe=await Promise.all(ce);if(Pe=Pe.filter(ze=>ze),0<Pe.length)throw Error(Pe.join(`
`))}return W}finally{i.Fb=null}};i.jsepInit=(g,P)=>{if(g==="webgpu"){[i.Jb,i.Ub,i.Yb,i.Kb,i.Xb,i.jb,i.Zb,i.ac,i.Vb,i.Wb,i.$b]=P;let D=i.Jb;i.jsepRegisterBuffer=(B,W,ce,Pe)=>D.registerBuffer(B,W,ce,Pe),i.jsepGetBuffer=B=>D.getBuffer(B),i.jsepCreateDownloader=(B,W,ce)=>D.createDownloader(B,W,ce),i.jsepOnCreateSession=B=>{D.onCreateSession(B)},i.jsepOnReleaseSession=B=>{D.onReleaseSession(B)},i.jsepOnRunStart=B=>D.onRunStart(B),i.bc=(B,W)=>{D.upload(B,W)}}else if(g==="webnn"){let D=P[0];[i.nc,i.Nb,i.webnnEnsureTensor,i.Ob,i.webnnDownloadTensor]=P.slice(1),i.webnnReleaseTensorId=i.Nb,i.webnnUploadTensor=i.Ob,i.webnnOnRunStart=B=>D.onRunStart(B),i.webnnOnRunEnd=D.onRunEnd.bind(D),i.webnnRegisterMLContext=(B,W)=>{D.registerMLContext(B,W)},i.webnnOnReleaseSession=B=>{D.onReleaseSession(B)},i.webnnCreateMLTensorDownloader=(B,W)=>D.createMLTensorDownloader(B,W),i.webnnRegisterMLTensor=(B,W,ce,Pe)=>D.registerMLTensor(B,W,ce,Pe),i.webnnCreateMLContext=B=>D.createMLContext(B),i.webnnRegisterMLConstant=(B,W,ce,Pe,ze,Qe)=>D.registerMLConstant(B,W,ce,Pe,ze,i.Eb,Qe),i.webnnRegisterGraphInput=D.registerGraphInput.bind(D),i.webnnIsGraphInput=D.isGraphInput.bind(D),i.webnnCreateTemporaryTensor=D.createTemporaryTensor.bind(D),i.webnnIsInt64Supported=D.isInt64Supported.bind(D)}};let d=()=>{let g=(P,D,B)=>(...W)=>{let ce=en,Pe=D==null?void 0:D();W=P(...W);let ze=D==null?void 0:D();return Pe!==ze&&(P=ze,B(Pe),D=B=null),en!=ce?new Promise((Qe,nt)=>{Lr={resolve:Qe,reject:nt}}):W};(()=>{for(let P of["_OrtAppendExecutionProvider","_OrtCreateSession","_OrtRun","_OrtRunWithBinding","_OrtBindInput"])i[P]=g(i[P],()=>i[P],D=>i[P]=D)})(),c!==void 0&&(i._OrtRun=c(i._OrtRun),i._OrtRunWithBinding=c(i._OrtRunWithBinding)),d=void 0};i.asyncInit=()=>{d==null||d()};var f,m,y=Object.assign({},i),C=(g,P)=>{throw P},_="";(a||l)&&(l?_=self.location.href:typeof document<"u"&&document.currentScript&&(_=document.currentScript.src),Om&&(_=Om),_=_.startsWith("blob:")?"":_.slice(0,_.replace(/[?#].*/,"").lastIndexOf("/")+1),l&&(m=g=>{var P=new XMLHttpRequest;return P.open("GET",g,!1),P.responseType="arraybuffer",P.send(null),new Uint8Array(P.response)}),f=async g=>{if(F(g))return new Promise((D,B)=>{var W=new XMLHttpRequest;W.open("GET",g,!0),W.responseType="arraybuffer",W.onload=()=>{W.status==200||W.status==0&&W.response?D(W.response):B(W.status)},W.onerror=B,W.send(null)});var P=await fetch(g,{credentials:"same-origin"});if(P.ok)return P.arrayBuffer();throw Error(P.status+" : "+P.url)});var h=console.log.bind(console),w=console.error.bind(console),M=h,x=w;Object.assign(i,y),y=null;var b,T,S,$,O,G,H,N,J,q,X,Y,K,oe=i.wasmBinary,se=!1,F=g=>g.startsWith("file://");function I(){return b.buffer!=$.buffer&&j(),$}function V(){return b.buffer!=$.buffer&&j(),O}function ee(){return b.buffer!=$.buffer&&j(),G}function pe(){return b.buffer!=$.buffer&&j(),H}function Z(){return b.buffer!=$.buffer&&j(),N}function de(){return b.buffer!=$.buffer&&j(),J}function Se(){return b.buffer!=$.buffer&&j(),q}function Re(){return b.buffer!=$.buffer&&j(),K}if(u){let g=function(P){try{var D=P.data,B=D.Bb;if(B==="load"){let W=[];self.onmessage=ce=>W.push(ce),self.startWorker=()=>{postMessage({Bb:"loaded"});for(let ce of W)g(ce);self.onmessage=g};for(let ce of D.Rb)i[ce]&&!i[ce].proxy||(i[ce]=(...Pe)=>{postMessage({Bb:"callHandler",Qb:ce,args:Pe})},ce=="print"&&(M=i[ce]),ce=="printErr"&&(x=i[ce]));b=D.kc,j(),ye(D.lc)}else if(B==="run"){Ct(D.Ab),So(D.Ab,0,0,1,0,0),Pn(),Ee(D.Ab),Q||(Vl(),Q=!0);try{Bn(D.fc,D.Hb)}catch(W){if(W!="unwind")throw W}}else D.target!=="setimmediate"&&(B==="checkMailbox"?Q&&We():B&&(x(`worker: received unknown command ${B}`),x(D)))}catch(W){throw Ul(),W}};var ye,Q=!1;x=function(...P){P=P.join(" "),console.error(P)},self.alert=function(...P){postMessage({Bb:"alert",text:P.join(" "),ic:Ci()})},self.onunhandledrejection=P=>{throw P.reason||P},self.onmessage=g}function j(){var g=b.buffer;i.HEAP8=$=new Int8Array(g),i.HEAP16=G=new Int16Array(g),i.HEAPU8=O=new Uint8Array(g),i.HEAPU16=H=new Uint16Array(g),i.HEAP32=N=new Int32Array(g),i.HEAPU32=J=new Uint32Array(g),i.HEAPF32=q=new Float32Array(g),i.HEAPF64=K=new Float64Array(g),i.HEAP64=X=new BigInt64Array(g),i.HEAPU64=Y=new BigUint64Array(g)}function he(){u?startWorker(i):ut.Ca()}u||(b=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),j());var be,we=0,Ce=null;function De(){if(--we==0&&Ce){var g=Ce;Ce=null,g()}}function Oe(g){throw x(g="Aborted("+g+")"),se=!0,g=new WebAssembly.RuntimeError(g+". Build with -sASSERTIONS for more info."),s(g),g}function Le(){return{a:{L:re,Aa:L,b:Dr,$:hs,A:ms,pa:_s,X:Be,Z:et,qa:it,na:Yt,ga:Or,ma:_r,J:gs,Y:ys,V:Yr,oa:vs,W:ws,va:uo,E:co,Q:po,O:ho,D:_o,u:go,r:js,P:yo,z:U,R:te,ja:le,T:Xe,aa:tt,M:_t,F:It,ia:Ee,sa:Lt,t:un,Ba:tr,w:Dn,o:xn,l:bi,c:Js,n:Tc,j:Sc,v:Cc,p:kc,f:$c,s:Ic,m:El,e:Ac,k:Dc,i:Pl,g:Oc,d:Sl,da:Fc,ea:kl,fa:zc,ba:bo,ca:$l,N:Il,xa:Bc,ua:jc,h:Vc,C:Al,G:ei,ta:Nc,x:Uc,ra:Df,U:Wc,q:Rc,y:Of,K:Gc,S:Dl,za:Hc,ya:Kc,ka:Ll,la:xa,_:Je,B:zl,I:Rl,ha:ba,H:Bl,a:b,wa:$e}}}var je={829644:(g,P,D,B,W)=>{if(i===void 0||!i.Eb)return 1;if((g=Gt(Number(g>>>0))).startsWith("./")&&(g=g.substring(2)),!(g=i.Eb.get(g)))return 2;if(P=Number(P>>>0),D=Number(D>>>0),B=Number(B>>>0),P+D>g.byteLength)return 3;try{let ce=g.subarray(P,P+D);switch(W){case 0:V().set(ce,B>>>0);break;case 1:i.mc?i.mc(B,ce):i.bc(B,ce);break;default:return 4}return 0}catch{return 4}},830468:(g,P,D)=>{i.Ob(g,V().subarray(P>>>0,P+D>>>0))},830532:()=>i.nc(),830574:g=>{i.Nb(g)},830611:()=>{i.Vb()},830642:()=>{i.Wb()},830671:()=>{i.$b()},830696:g=>i.Ub(g),830729:g=>i.Yb(g),830761:(g,P,D)=>{i.Kb(Number(g),Number(P),Number(D),!0)},830824:(g,P,D)=>{i.Kb(Number(g),Number(P),Number(D))},830881:()=>typeof wasmOffsetConverter<"u",830938:g=>{i.jb("Abs",g,void 0)},830989:g=>{i.jb("Neg",g,void 0)},831040:g=>{i.jb("Floor",g,void 0)},831093:g=>{i.jb("Ceil",g,void 0)},831145:g=>{i.jb("Reciprocal",g,void 0)},831203:g=>{i.jb("Sqrt",g,void 0)},831255:g=>{i.jb("Exp",g,void 0)},831306:g=>{i.jb("Erf",g,void 0)},831357:g=>{i.jb("Sigmoid",g,void 0)},831412:(g,P,D)=>{i.jb("HardSigmoid",g,{alpha:P,beta:D})},831491:g=>{i.jb("Log",g,void 0)},831542:g=>{i.jb("Sin",g,void 0)},831593:g=>{i.jb("Cos",g,void 0)},831644:g=>{i.jb("Tan",g,void 0)},831695:g=>{i.jb("Asin",g,void 0)},831747:g=>{i.jb("Acos",g,void 0)},831799:g=>{i.jb("Atan",g,void 0)},831851:g=>{i.jb("Sinh",g,void 0)},831903:g=>{i.jb("Cosh",g,void 0)},831955:g=>{i.jb("Asinh",g,void 0)},832008:g=>{i.jb("Acosh",g,void 0)},832061:g=>{i.jb("Atanh",g,void 0)},832114:g=>{i.jb("Tanh",g,void 0)},832166:g=>{i.jb("Not",g,void 0)},832217:(g,P,D)=>{i.jb("Clip",g,{min:P,max:D})},832286:g=>{i.jb("Clip",g,void 0)},832338:(g,P)=>{i.jb("Elu",g,{alpha:P})},832396:g=>{i.jb("Gelu",g,void 0)},832448:g=>{i.jb("Relu",g,void 0)},832500:(g,P)=>{i.jb("LeakyRelu",g,{alpha:P})},832564:(g,P)=>{i.jb("ThresholdedRelu",g,{alpha:P})},832634:(g,P)=>{i.jb("Cast",g,{to:P})},832692:g=>{i.jb("Add",g,void 0)},832743:g=>{i.jb("Sub",g,void 0)},832794:g=>{i.jb("Mul",g,void 0)},832845:g=>{i.jb("Div",g,void 0)},832896:g=>{i.jb("Pow",g,void 0)},832947:g=>{i.jb("Equal",g,void 0)},833e3:g=>{i.jb("Greater",g,void 0)},833055:g=>{i.jb("GreaterOrEqual",g,void 0)},833117:g=>{i.jb("Less",g,void 0)},833169:g=>{i.jb("LessOrEqual",g,void 0)},833228:(g,P,D,B,W)=>{i.jb("ReduceMean",g,{keepDims:!!P,noopWithEmptyAxes:!!D,axes:B?Array.from(Z().subarray(Number(B)>>>0,Number(W)>>>0)):[]})},833403:(g,P,D,B,W)=>{i.jb("ReduceMax",g,{keepDims:!!P,noopWithEmptyAxes:!!D,axes:B?Array.from(Z().subarray(Number(B)>>>0,Number(W)>>>0)):[]})},833577:(g,P,D,B,W)=>{i.jb("ReduceMin",g,{keepDims:!!P,noopWithEmptyAxes:!!D,axes:B?Array.from(Z().subarray(Number(B)>>>0,Number(W)>>>0)):[]})},833751:(g,P,D,B,W)=>{i.jb("ReduceProd",g,{keepDims:!!P,noopWithEmptyAxes:!!D,axes:B?Array.from(Z().subarray(Number(B)>>>0,Number(W)>>>0)):[]})},833926:(g,P,D,B,W)=>{i.jb("ReduceSum",g,{keepDims:!!P,noopWithEmptyAxes:!!D,axes:B?Array.from(Z().subarray(Number(B)>>>0,Number(W)>>>0)):[]})},834100:(g,P,D,B,W)=>{i.jb("ReduceL1",g,{keepDims:!!P,noopWithEmptyAxes:!!D,axes:B?Array.from(Z().subarray(Number(B)>>>0,Number(W)>>>0)):[]})},834273:(g,P,D,B,W)=>{i.jb("ReduceL2",g,{keepDims:!!P,noopWithEmptyAxes:!!D,axes:B?Array.from(Z().subarray(Number(B)>>>0,Number(W)>>>0)):[]})},834446:(g,P,D,B,W)=>{i.jb("ReduceLogSum",g,{keepDims:!!P,noopWithEmptyAxes:!!D,axes:B?Array.from(Z().subarray(Number(B)>>>0,Number(W)>>>0)):[]})},834623:(g,P,D,B,W)=>{i.jb("ReduceSumSquare",g,{keepDims:!!P,noopWithEmptyAxes:!!D,axes:B?Array.from(Z().subarray(Number(B)>>>0,Number(W)>>>0)):[]})},834803:(g,P,D,B,W)=>{i.jb("ReduceLogSumExp",g,{keepDims:!!P,noopWithEmptyAxes:!!D,axes:B?Array.from(Z().subarray(Number(B)>>>0,Number(W)>>>0)):[]})},834983:g=>{i.jb("Where",g,void 0)},835036:(g,P,D)=>{i.jb("Transpose",g,{perm:P?Array.from(Z().subarray(Number(P)>>>0,Number(D)>>>0)):[]})},835160:(g,P,D,B)=>{i.jb("DepthToSpace",g,{blocksize:P,mode:Gt(D),format:B?"NHWC":"NCHW"})},835293:(g,P,D,B)=>{i.jb("DepthToSpace",g,{blocksize:P,mode:Gt(D),format:B?"NHWC":"NCHW"})},835426:(g,P,D,B,W,ce,Pe,ze,Qe,nt,vt,At,Ut,Cn,ti)=>{i.jb("ConvTranspose",g,{format:Qe?"NHWC":"NCHW",autoPad:P,dilations:[D],group:B,kernelShape:[W],pads:[ce,Pe],strides:[ze],wIsConst:()=>!!I()[nt>>>0],outputPadding:vt?Array.from(Z().subarray(Number(vt)>>>0,Number(At)>>>0)):[],outputShape:Ut?Array.from(Z().subarray(Number(Ut)>>>0,Number(Cn)>>>0)):[],activation:Gt(ti)})},835859:(g,P,D,B,W,ce,Pe,ze,Qe,nt,vt,At,Ut,Cn)=>{i.jb("ConvTranspose",g,{format:ze?"NHWC":"NCHW",autoPad:P,dilations:Array.from(Z().subarray(Number(D)>>>0,2+(Number(D)>>>0)>>>0)),group:B,kernelShape:Array.from(Z().subarray(Number(W)>>>0,2+(Number(W)>>>0)>>>0)),pads:Array.from(Z().subarray(Number(ce)>>>0,4+(Number(ce)>>>0)>>>0)),strides:Array.from(Z().subarray(Number(Pe)>>>0,2+(Number(Pe)>>>0)>>>0)),wIsConst:()=>!!I()[Qe>>>0],outputPadding:nt?Array.from(Z().subarray(Number(nt)>>>0,Number(vt)>>>0)):[],outputShape:At?Array.from(Z().subarray(Number(At)>>>0,Number(Ut)>>>0)):[],activation:Gt(Cn)})},836520:(g,P,D,B,W,ce,Pe,ze,Qe,nt,vt,At,Ut,Cn,ti)=>{i.jb("ConvTranspose",g,{format:Qe?"NHWC":"NCHW",autoPad:P,dilations:[D],group:B,kernelShape:[W],pads:[ce,Pe],strides:[ze],wIsConst:()=>!!I()[nt>>>0],outputPadding:vt?Array.from(Z().subarray(Number(vt)>>>0,Number(At)>>>0)):[],outputShape:Ut?Array.from(Z().subarray(Number(Ut)>>>0,Number(Cn)>>>0)):[],activation:Gt(ti)})},836953:(g,P,D,B,W,ce,Pe,ze,Qe,nt,vt,At,Ut,Cn)=>{i.jb("ConvTranspose",g,{format:ze?"NHWC":"NCHW",autoPad:P,dilations:Array.from(Z().subarray(Number(D)>>>0,2+(Number(D)>>>0)>>>0)),group:B,kernelShape:Array.from(Z().subarray(Number(W)>>>0,2+(Number(W)>>>0)>>>0)),pads:Array.from(Z().subarray(Number(ce)>>>0,4+(Number(ce)>>>0)>>>0)),strides:Array.from(Z().subarray(Number(Pe)>>>0,2+(Number(Pe)>>>0)>>>0)),wIsConst:()=>!!I()[Qe>>>0],outputPadding:nt?Array.from(Z().subarray(Number(nt)>>>0,Number(vt)>>>0)):[],outputShape:At?Array.from(Z().subarray(Number(At)>>>0,Number(Ut)>>>0)):[],activation:Gt(Cn)})},837614:(g,P)=>{i.jb("GlobalAveragePool",g,{format:P?"NHWC":"NCHW"})},837705:(g,P,D,B,W,ce,Pe,ze,Qe,nt,vt,At,Ut,Cn)=>{i.jb("AveragePool",g,{format:Cn?"NHWC":"NCHW",auto_pad:P,ceil_mode:D,count_include_pad:B,storage_order:W,dilations:ce?Array.from(Z().subarray(Number(ce)>>>0,Number(Pe)>>>0)):[],kernel_shape:ze?Array.from(Z().subarray(Number(ze)>>>0,Number(Qe)>>>0)):[],pads:nt?Array.from(Z().subarray(Number(nt)>>>0,Number(vt)>>>0)):[],strides:At?Array.from(Z().subarray(Number(At)>>>0,Number(Ut)>>>0)):[]})},838184:(g,P)=>{i.jb("GlobalAveragePool",g,{format:P?"NHWC":"NCHW"})},838275:(g,P,D,B,W,ce,Pe,ze,Qe,nt,vt,At,Ut,Cn)=>{i.jb("AveragePool",g,{format:Cn?"NHWC":"NCHW",auto_pad:P,ceil_mode:D,count_include_pad:B,storage_order:W,dilations:ce?Array.from(Z().subarray(Number(ce)>>>0,Number(Pe)>>>0)):[],kernel_shape:ze?Array.from(Z().subarray(Number(ze)>>>0,Number(Qe)>>>0)):[],pads:nt?Array.from(Z().subarray(Number(nt)>>>0,Number(vt)>>>0)):[],strides:At?Array.from(Z().subarray(Number(At)>>>0,Number(Ut)>>>0)):[]})},838754:(g,P)=>{i.jb("GlobalMaxPool",g,{format:P?"NHWC":"NCHW"})},838841:(g,P,D,B,W,ce,Pe,ze,Qe,nt,vt,At,Ut,Cn)=>{i.jb("MaxPool",g,{format:Cn?"NHWC":"NCHW",auto_pad:P,ceil_mode:D,count_include_pad:B,storage_order:W,dilations:ce?Array.from(Z().subarray(Number(ce)>>>0,Number(Pe)>>>0)):[],kernel_shape:ze?Array.from(Z().subarray(Number(ze)>>>0,Number(Qe)>>>0)):[],pads:nt?Array.from(Z().subarray(Number(nt)>>>0,Number(vt)>>>0)):[],strides:At?Array.from(Z().subarray(Number(At)>>>0,Number(Ut)>>>0)):[]})},839316:(g,P)=>{i.jb("GlobalMaxPool",g,{format:P?"NHWC":"NCHW"})},839403:(g,P,D,B,W,ce,Pe,ze,Qe,nt,vt,At,Ut,Cn)=>{i.jb("MaxPool",g,{format:Cn?"NHWC":"NCHW",auto_pad:P,ceil_mode:D,count_include_pad:B,storage_order:W,dilations:ce?Array.from(Z().subarray(Number(ce)>>>0,Number(Pe)>>>0)):[],kernel_shape:ze?Array.from(Z().subarray(Number(ze)>>>0,Number(Qe)>>>0)):[],pads:nt?Array.from(Z().subarray(Number(nt)>>>0,Number(vt)>>>0)):[],strides:At?Array.from(Z().subarray(Number(At)>>>0,Number(Ut)>>>0)):[]})},839878:(g,P,D,B,W)=>{i.jb("Gemm",g,{alpha:P,beta:D,transA:B,transB:W})},839982:g=>{i.jb("MatMul",g,void 0)},840036:(g,P,D,B)=>{i.jb("ArgMax",g,{keepDims:!!P,selectLastIndex:!!D,axis:B})},840144:(g,P,D,B)=>{i.jb("ArgMin",g,{keepDims:!!P,selectLastIndex:!!D,axis:B})},840252:(g,P)=>{i.jb("Softmax",g,{axis:P})},840315:(g,P)=>{i.jb("Concat",g,{axis:P})},840375:(g,P,D,B,W)=>{i.jb("Split",g,{axis:P,numOutputs:D,splitSizes:B?Array.from(Z().subarray(Number(B)>>>0,Number(W)>>>0)):[]})},840531:g=>{i.jb("Expand",g,void 0)},840585:(g,P)=>{i.jb("Gather",g,{axis:Number(P)})},840656:(g,P)=>{i.jb("GatherElements",g,{axis:Number(P)})},840735:(g,P)=>{i.jb("GatherND",g,{batch_dims:Number(P)})},840814:(g,P,D,B,W,ce,Pe,ze,Qe,nt,vt)=>{i.jb("Resize",g,{antialias:P,axes:D?Array.from(Z().subarray(Number(D)>>>0,Number(B)>>>0)):[],coordinateTransformMode:Gt(W),cubicCoeffA:ce,excludeOutside:Pe,extrapolationValue:ze,keepAspectRatioPolicy:Gt(Qe),mode:Gt(nt),nearestMode:Gt(vt)})},841176:(g,P,D,B,W,ce,Pe)=>{i.jb("Slice",g,{starts:P?Array.from(Z().subarray(Number(P)>>>0,Number(D)>>>0)):[],ends:B?Array.from(Z().subarray(Number(B)>>>0,Number(W)>>>0)):[],axes:ce?Array.from(Z().subarray(Number(ce)>>>0,Number(Pe)>>>0)):[]})},841440:g=>{i.jb("Tile",g,void 0)},841492:(g,P,D)=>{i.jb("InstanceNormalization",g,{epsilon:P,format:D?"NHWC":"NCHW"})},841606:(g,P,D)=>{i.jb("InstanceNormalization",g,{epsilon:P,format:D?"NHWC":"NCHW"})},841720:g=>{i.jb("Range",g,void 0)},841773:(g,P)=>{i.jb("Einsum",g,{equation:Gt(P)})},841854:(g,P,D,B,W)=>{i.jb("Pad",g,{mode:P,value:D,pads:B?Array.from(Z().subarray(Number(B)>>>0,Number(W)>>>0)):[]})},841997:(g,P,D,B,W,ce)=>{i.jb("BatchNormalization",g,{epsilon:P,momentum:D,spatial:!!W,trainingMode:!!B,format:ce?"NHWC":"NCHW"})},842166:(g,P,D,B,W,ce)=>{i.jb("BatchNormalization",g,{epsilon:P,momentum:D,spatial:!!W,trainingMode:!!B,format:ce?"NHWC":"NCHW"})},842335:(g,P,D)=>{i.jb("CumSum",g,{exclusive:Number(P),reverse:Number(D)})},842432:(g,P,D)=>{i.jb("DequantizeLinear",g,{axis:P,blockSize:D})},842522:(g,P,D,B,W)=>{i.jb("GridSample",g,{align_corners:P,mode:Gt(D),padding_mode:Gt(B),format:W?"NHWC":"NCHW"})},842692:(g,P,D,B,W)=>{i.jb("GridSample",g,{align_corners:P,mode:Gt(D),padding_mode:Gt(B),format:W?"NHWC":"NCHW"})},842862:(g,P)=>{i.jb("ScatterND",g,{reduction:Gt(P)})},842947:(g,P,D,B,W,ce,Pe,ze,Qe)=>{i.jb("Attention",g,{numHeads:P,isUnidirectional:D,maskFilterValue:B,scale:W,doRotary:ce,qkvHiddenSizes:Pe?Array.from(Z().subarray(Number(ze)>>>0,Number(ze)+Pe>>>0)):[],pastPresentShareBuffer:!!Qe})},843219:g=>{i.jb("BiasAdd",g,void 0)},843274:g=>{i.jb("BiasSplitGelu",g,void 0)},843335:g=>{i.jb("FastGelu",g,void 0)},843391:(g,P,D,B,W,ce,Pe,ze,Qe,nt,vt,At,Ut,Cn,ti,Qc)=>{i.jb("Conv",g,{format:At?"NHWC":"NCHW",auto_pad:P,dilations:D?Array.from(Z().subarray(Number(D)>>>0,Number(B)>>>0)):[],group:W,kernel_shape:ce?Array.from(Z().subarray(Number(ce)>>>0,Number(Pe)>>>0)):[],pads:ze?Array.from(Z().subarray(Number(ze)>>>0,Number(Qe)>>>0)):[],strides:nt?Array.from(Z().subarray(Number(nt)>>>0,Number(vt)>>>0)):[],w_is_const:()=>!!I()[Number(Ut)>>>0],activation:Gt(Cn),activation_params:ti?Array.from(Se().subarray(Number(ti)>>>0,Number(Qc)>>>0)):[]})},843975:g=>{i.jb("Gelu",g,void 0)},844027:(g,P,D,B,W,ce,Pe,ze,Qe)=>{i.jb("GroupQueryAttention",g,{numHeads:P,kvNumHeads:D,scale:B,softcap:W,doRotary:ce,rotaryInterleaved:Pe,smoothSoftmax:ze,localWindowSize:Qe})},844244:(g,P,D,B)=>{i.jb("LayerNormalization",g,{axis:P,epsilon:D,simplified:!!B})},844355:(g,P,D,B)=>{i.jb("LayerNormalization",g,{axis:P,epsilon:D,simplified:!!B})},844466:(g,P,D,B,W,ce)=>{i.jb("MatMulNBits",g,{k:P,n:D,accuracyLevel:B,bits:W,blockSize:ce})},844593:(g,P,D,B,W,ce)=>{i.jb("MultiHeadAttention",g,{numHeads:P,isUnidirectional:D,maskFilterValue:B,scale:W,doRotary:ce})},844752:(g,P)=>{i.jb("QuickGelu",g,{alpha:P})},844816:(g,P,D,B,W)=>{i.jb("RotaryEmbedding",g,{interleaved:!!P,numHeads:D,rotaryEmbeddingDim:B,scale:W})},844955:(g,P,D)=>{i.jb("SkipLayerNormalization",g,{epsilon:P,simplified:!!D})},845057:(g,P,D)=>{i.jb("SkipLayerNormalization",g,{epsilon:P,simplified:!!D})},845159:(g,P,D,B)=>{i.jb("GatherBlockQuantized",g,{gatherAxis:P,quantizeAxis:D,blockSize:B})},845280:g=>{i.Zb(g)},845314:(g,P)=>i.ac(Number(g),Number(P),i.Fb.dc,i.Fb.errors)};function L(g,P,D){return zr(async()=>{await i.Xb(Number(g),Number(P),Number(D))})}function re(){return typeof wasmOffsetConverter<"u"}class R{constructor(P){ie(this,"name","ExitStatus");this.message=`Program terminated with exit(${P})`,this.status=P}}var ne=g=>{g.terminate(),g.onmessage=()=>{}},ue=[],ve=g=>{qe.length==0&&(Ft(),ht(qe[0]));var P=qe.pop();if(!P)return 6;pt.push(P),Ht[g.Ab]=P,P.Ab=g.Ab;var D={Bb:"run",fc:g.ec,Hb:g.Hb,Ab:g.Ab};return P.postMessage(D,g.Mb),0},Te=0,Ae=(g,P,...D)=>{for(var B=2*D.length,W=Ca(),ce=ko(8*B),Pe=ce>>>3,ze=0;ze<D.length;ze++){var Qe=D[ze];typeof Qe=="bigint"?(X[Pe+2*ze]=1n,X[Pe+2*ze+1]=Qe):(X[Pe+2*ze]=0n,Re()[Pe+2*ze+1>>>0]=Qe)}return g=Wl(g,0,B,ce,P),Co(W),g};function $e(g){if(u)return Ae(0,1,g);if(S=g,!(0<Te)){for(var P of pt)ne(P);for(P of qe)ne(P);qe=[],pt=[],Ht={},se=!0}C(0,new R(g))}function Ve(g){if(u)return Ae(1,0,g);Je(g)}var Je=g=>{if(S=g,u)throw Ve(g),"unwind";$e(g)},qe=[],pt=[],Tt=[],Ht={},$t=g=>{var P=g.Ab;delete Ht[P],qe.push(g),pt.splice(pt.indexOf(g),1),g.Ab=0,Ea(P)};function Pn(){Tt.forEach(g=>g())}var ht=g=>new Promise(P=>{g.onmessage=W=>{var ce=(W=W.data).Bb;if(W.Gb&&W.Gb!=Ci()){var Pe=Ht[W.Gb];Pe?Pe.postMessage(W,W.Mb):x(`Internal error! Worker sent a message "${ce}" to target pthread ${W.Gb}, but that thread no longer exists!`)}else ce==="checkMailbox"?We():ce==="spawnThread"?ve(W):ce==="cleanupThread"?$t(Ht[W.hc]):ce==="loaded"?(g.loaded=!0,P(g)):ce==="alert"?alert(`Thread ${W.ic}: ${W.text}`):W.target==="setimmediate"?g.postMessage(W):ce==="callHandler"?i[W.Qb](...W.args):ce&&x(`worker sent an unknown command ${ce}`)},g.onerror=W=>{throw x(`worker sent an error! ${W.filename}:${W.lineno}: ${W.message}`),W};var D,B=[];for(D of[])i.propertyIsEnumerable(D)&&B.push(D);g.postMessage({Bb:"load",Rb:B,kc:b,lc:T})});function Ft(){var g=new Worker((()=>{let P=URL;return import.meta.url>"file:"&&import.meta.url<"file;"?new P("ort.bundle.min.mjs",import.meta.url):new URL(import.meta.url)})(),{type:"module",workerData:"em-pthread",name:"em-pthread"});qe.push(g)}var Ct=g=>{j();var P=de()[g+52>>>2>>>0];g=de()[g+56>>>2>>>0],Hl(P,P-g),Co(P)},Bn=(g,P)=>{Te=0,g=Kl(g,P),0<Te?S=g:Pa(g)};class An{constructor(P){this.Ib=P-24}}function Dr(g,P,D){var B=new An(g>>>=0);throw P>>>=0,D>>>=0,de()[B.Ib+16>>>2>>>0]=0,de()[B.Ib+4>>>2>>>0]=P,de()[B.Ib+8>>>2>>>0]=D,g}function ft(g,P,D,B){return u?Ae(2,1,g,P,D,B):hs(g,P,D,B)}function hs(g,P,D,B){if(g>>>=0,D>>>=0,B>>>=0,p===void 0)return 6;var W=[];return u&&W.length===0?ft(g,P>>>=0,D,B):(g={ec:D,Ab:g,Hb:B,Mb:W},u?(g.Bb="spawnThread",postMessage(g,W),0):ve(g))}var br=typeof TextDecoder<"u"?new TextDecoder:void 0,Bs=(g,P=0,D=NaN)=>{var B=(P>>>=0)+D;for(D=P;g[D]&&!(D>=B);)++D;if(16<D-P&&g.buffer&&br)return br.decode(g.buffer instanceof ArrayBuffer?g.subarray(P,D):g.slice(P,D));for(B="";P<D;){var W=g[P++];if(128&W){var ce=63&g[P++];if((224&W)==192)B+=String.fromCharCode((31&W)<<6|ce);else{var Pe=63&g[P++];65536>(W=(240&W)==224?(15&W)<<12|ce<<6|Pe:(7&W)<<18|ce<<12|Pe<<6|63&g[P++])?B+=String.fromCharCode(W):(W-=65536,B+=String.fromCharCode(55296|W>>10,56320|1023&W))}}else B+=String.fromCharCode(W)}return B},Gt=(g,P)=>(g>>>=0)?Bs(V(),g,P):"";function ms(g,P,D){return u?Ae(3,1,g,P,D):0}function _s(g,P){if(u)return Ae(4,1,g,P)}var Ns=g=>{for(var P=0,D=0;D<g.length;++D){var B=g.charCodeAt(D);127>=B?P++:2047>=B?P+=2:55296<=B&&57343>=B?(P+=4,++D):P+=3}return P},fn=(g,P,D)=>{var B=V();if(P>>>=0,0<D){var W=P;D=P+D-1;for(var ce=0;ce<g.length;++ce){var Pe=g.charCodeAt(ce);if(55296<=Pe&&57343>=Pe&&(Pe=65536+((1023&Pe)<<10)|1023&g.charCodeAt(++ce)),127>=Pe){if(P>=D)break;B[P++>>>0]=Pe}else{if(2047>=Pe){if(P+1>=D)break;B[P++>>>0]=192|Pe>>6}else{if(65535>=Pe){if(P+2>=D)break;B[P++>>>0]=224|Pe>>12}else{if(P+3>=D)break;B[P++>>>0]=240|Pe>>18,B[P++>>>0]=128|Pe>>12&63}B[P++>>>0]=128|Pe>>6&63}B[P++>>>0]=128|63&Pe}}B[P>>>0]=0,g=P-W}else g=0;return g};function Be(g,P){if(u)return Ae(5,1,g,P)}function et(g,P,D){if(u)return Ae(6,1,g,P,D)}function it(g,P,D){return u?Ae(7,1,g,P,D):0}function Yt(g,P){if(u)return Ae(8,1,g,P)}function Or(g,P,D){if(u)return Ae(9,1,g,P,D)}function _r(g,P,D,B){if(u)return Ae(10,1,g,P,D,B)}function gs(g,P,D,B){if(u)return Ae(11,1,g,P,D,B)}function ys(g,P,D,B){if(u)return Ae(12,1,g,P,D,B)}function Yr(g){if(u)return Ae(13,1,g)}function vs(g,P){if(u)return Ae(14,1,g,P)}function ws(g,P,D){if(u)return Ae(15,1,g,P,D)}var Jr,or,uo=()=>Oe(""),ar=g=>{for(var P="";V()[g>>>0];)P+=Jr[V()[g++>>>0]];return P},Xs={},Ys={};function qn(g,P,D={}){return function(B,W,ce={}){var Pe=W.name;if(!B)throw new or(`type "${Pe}" must have a positive integer typeid pointer`);if(Ys.hasOwnProperty(B)){if(ce.Sb)return;throw new or(`Cannot register type '${Pe}' twice`)}Ys[B]=W,Xs.hasOwnProperty(B)&&(W=Xs[B],delete Xs[B],W.forEach(ze=>ze()))}(g,P,D)}var Mi=(g,P,D)=>{switch(P){case 1:return D?B=>I()[B>>>0]:B=>V()[B>>>0];case 2:return D?B=>ee()[B>>>1>>>0]:B=>pe()[B>>>1>>>0];case 4:return D?B=>Z()[B>>>2>>>0]:B=>de()[B>>>2>>>0];case 8:return D?B=>X[B>>>3]:B=>Y[B>>>3];default:throw new TypeError(`invalid integer width (${P}): ${g}`)}};function co(g,P,D){D>>>=0,qn(g>>>=0,{name:P=ar(P>>>0),fromWireType:B=>B,toWireType:function(B,W){if(typeof W!="bigint"&&typeof W!="number")throw W=W===null?"null":(B=typeof W)=="object"||B==="array"||B==="function"?W.toString():""+W,new TypeError(`Cannot convert "${W}" to ${this.name}`);return typeof W=="number"&&(W=BigInt(W)),W},Cb:Tr,readValueFromPointer:Mi(P,D,P.indexOf("u")==-1),Db:null})}var Tr=8;function po(g,P,D,B){qn(g>>>=0,{name:P=ar(P>>>0),fromWireType:function(W){return!!W},toWireType:function(W,ce){return ce?D:B},Cb:Tr,readValueFromPointer:function(W){return this.fromWireType(V()[W>>>0])},Db:null})}var Zr=[],lr=[];function Js(g){9<(g>>>=0)&&--lr[g+1]==0&&(lr[g]=void 0,Zr.push(g))}var Nn=g=>{if(!g)throw new or("Cannot use deleted val. handle = "+g);return lr[g]},Qn=g=>{switch(g){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let P=Zr.pop()||lr.length;return lr[P]=g,lr[P+1]=1,P}};function Fr(g){return this.fromWireType(de()[g>>>2>>>0])}var fo={name:"emscripten::val",fromWireType:g=>{var P=Nn(g);return Js(g),P},toWireType:(g,P)=>Qn(P),Cb:Tr,readValueFromPointer:Fr,Db:null};function ho(g){return qn(g>>>0,fo)}var mo=(g,P)=>{switch(P){case 4:return function(D){return this.fromWireType(Se()[D>>>2>>>0])};case 8:return function(D){return this.fromWireType(Re()[D>>>3>>>0])};default:throw new TypeError(`invalid float width (${P}): ${g}`)}};function _o(g,P,D){D>>>=0,qn(g>>>=0,{name:P=ar(P>>>0),fromWireType:B=>B,toWireType:(B,W)=>W,Cb:Tr,readValueFromPointer:mo(P,D),Db:null})}function go(g,P,D,B,W){if(g>>>=0,D>>>=0,P=ar(P>>>0),W===-1&&(W=4294967295),W=ze=>ze,B===0){var ce=32-8*D;W=ze=>ze<<ce>>>ce}var Pe=P.includes("unsigned")?function(ze,Qe){return Qe>>>0}:function(ze,Qe){return Qe};qn(g,{name:P,fromWireType:W,toWireType:Pe,Cb:Tr,readValueFromPointer:Mi(P,D,B!==0),Db:null})}function js(g,P,D){function B(ce){var Pe=de()[ce>>>2>>>0];return ce=de()[ce+4>>>2>>>0],new W(I().buffer,ce,Pe)}var W=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][P];qn(g>>>=0,{name:D=ar(D>>>0),fromWireType:B,Cb:Tr,readValueFromPointer:B},{Sb:!0})}function yo(g,P){qn(g>>>=0,{name:P=ar(P>>>0),fromWireType:function(D){for(var B,W=de()[D>>>2>>>0],ce=D+4,Pe=ce,ze=0;ze<=W;++ze){var Qe=ce+ze;ze!=W&&V()[Qe>>>0]!=0||(Pe=Gt(Pe,Qe-Pe),B===void 0?B=Pe:(B+="\0",B+=Pe),Pe=Qe+1)}return Rr(D),B},toWireType:function(D,B){B instanceof ArrayBuffer&&(B=new Uint8Array(B));var W=typeof B=="string";if(!(W||B instanceof Uint8Array||B instanceof Uint8ClampedArray||B instanceof Int8Array))throw new or("Cannot pass non-string to std::string");var ce=W?Ns(B):B.length,Pe=Po(4+ce+1),ze=Pe+4;if(de()[Pe>>>2>>>0]=ce,W)fn(B,ze,ce+1);else if(W)for(W=0;W<ce;++W){var Qe=B.charCodeAt(W);if(255<Qe)throw Rr(Pe),new or("String has UTF-16 code units that do not fit in 8 bits");V()[ze+W>>>0]=Qe}else for(W=0;W<ce;++W)V()[ze+W>>>0]=B[W];return D!==null&&D.push(Rr,Pe),Pe},Cb:Tr,readValueFromPointer:Fr,Db(D){Rr(D)}})}var xi=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,vo=(g,P)=>{for(var D=g>>1,B=D+P/2;!(D>=B)&&pe()[D>>>0];)++D;if(32<(D<<=1)-g&&xi)return xi.decode(V().slice(g,D));for(D="",B=0;!(B>=P/2);++B){var W=ee()[g+2*B>>>1>>>0];if(W==0)break;D+=String.fromCharCode(W)}return D},wo=(g,P,D)=>{if(D??(D=2147483647),2>D)return 0;var B=P;D=(D-=2)<2*g.length?D/2:g.length;for(var W=0;W<D;++W){var ce=g.charCodeAt(W);ee()[P>>>1>>>0]=ce,P+=2}return ee()[P>>>1>>>0]=0,P-B},Vs=g=>2*g.length,Mo=(g,P)=>{for(var D=0,B="";!(D>=P/4);){var W=Z()[g+4*D>>>2>>>0];if(W==0)break;++D,65536<=W?(W-=65536,B+=String.fromCharCode(55296|W>>10,56320|1023&W)):B+=String.fromCharCode(W)}return B},me=(g,P,D)=>{if(P>>>=0,D??(D=2147483647),4>D)return 0;var B=P;D=B+D-4;for(var W=0;W<g.length;++W){var ce=g.charCodeAt(W);if(55296<=ce&&57343>=ce&&(ce=65536+((1023&ce)<<10)|1023&g.charCodeAt(++W)),Z()[P>>>2>>>0]=ce,(P+=4)+4>D)break}return Z()[P>>>2>>>0]=0,P-B},A=g=>{for(var P=0,D=0;D<g.length;++D){var B=g.charCodeAt(D);55296<=B&&57343>=B&&++D,P+=4}return P};function U(g,P,D){if(g>>>=0,P>>>=0,D=ar(D>>>=0),P===2)var B=vo,W=wo,ce=Vs,Pe=ze=>pe()[ze>>>1>>>0];else P===4&&(B=Mo,W=me,ce=A,Pe=ze=>de()[ze>>>2>>>0]);qn(g,{name:D,fromWireType:ze=>{for(var Qe,nt=de()[ze>>>2>>>0],vt=ze+4,At=0;At<=nt;++At){var Ut=ze+4+At*P;At!=nt&&Pe(Ut)!=0||(vt=B(vt,Ut-vt),Qe===void 0?Qe=vt:(Qe+="\0",Qe+=vt),vt=Ut+P)}return Rr(ze),Qe},toWireType:(ze,Qe)=>{if(typeof Qe!="string")throw new or(`Cannot pass non-string to C++ string type ${D}`);var nt=ce(Qe),vt=Po(4+nt+P);return de()[vt>>>2>>>0]=nt/P,W(Qe,vt+4,nt+P),ze!==null&&ze.push(Rr,vt),vt},Cb:Tr,readValueFromPointer:Fr,Db(ze){Rr(ze)}})}function te(g,P){qn(g>>>=0,{Tb:!0,name:P=ar(P>>>0),Cb:0,fromWireType:()=>{},toWireType:()=>{}})}function le(g){So(g>>>0,!l,1,!a,131072,!1),Pn()}var fe=g=>{if(!se)try{if(g(),!(0<Te))try{u?Pa(S):Je(S)}catch(P){P instanceof R||P=="unwind"||C(0,P)}}catch(P){P instanceof R||P=="unwind"||C(0,P)}};function Ee(g){g>>>=0,typeof Atomics.jc=="function"&&(Atomics.jc(Z(),g>>>2,g).value.then(We),g+=128,Atomics.store(Z(),g>>>2,1))}var We=()=>{var g=Ci();g&&(Ee(g),fe(Sa))};function Xe(g,P){(g>>>=0)==P>>>0?setTimeout(We):u?postMessage({Gb:g,Bb:"checkMailbox"}):(g=Ht[g])&&g.postMessage({Bb:"checkMailbox"})}var Ke=[];function tt(g,P,D,B,W){for(P>>>=0,B/=2,Ke.length=B,D=W>>>0>>>3,W=0;W<B;W++)Ke[W]=X[D+2*W]?X[D+2*W+1]:Re()[D+2*W+1>>>0];return(P?je[P]:Nl[g])(...Ke)}var _t=()=>{Te=0};function It(g){g>>>=0,u?postMessage({Bb:"cleanupThread",hc:g}):$t(Ht[g])}function Lt(g){}var Jt=(g,P)=>{var D=Ys[g];if(D===void 0)throw g=jl(g),D=ar(g),Rr(g),new or(`${P} has unknown type ${D}`);return D},Vt=(g,P,D)=>{var B=[];return g=g.toWireType(B,D),B.length&&(de()[P>>>2>>>0]=Qn(B)),g};function un(g,P,D){return P>>>=0,D>>>=0,g=Nn(g>>>0),P=Jt(P,"emval::as"),Vt(P,D,g)}function tr(g,P){return P>>>=0,g=Nn(g>>>0),(P=Jt(P,"emval::as")).toWireType(null,g)}var jn=g=>{try{g()}catch(P){Oe(P)}},Vn=0,en=null,es=0,Kt=[],Sn={},Xn={},ts=0,Lr=null,Mn=[];function zr(g){return function(P){if(!se){if(Vn===0){var D=!1,B=!1;P((W=0)=>{if(!se&&(es=W,D=!0,B)){Vn=2,jn(()=>Ql(en)),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.resume(),W=!1;try{var ce=function(){var Qe=Z()[en+8>>>2>>>0];return Qe=ut[Xn[Qe]],--Te,Qe()}()}catch(Qe){ce=Qe,W=!0}var Pe=!1;if(!en){var ze=Lr;ze&&(Lr=null,(W?ze.reject:ze.resolve)(ce),Pe=!0)}if(W&&!Pe)throw ce}}),B=!0,D||(Vn=1,en=function(){var W=Po(65548),ce=W+12;de()[W>>>2>>>0]=ce,de()[W+4>>>2>>>0]=ce+65536,ce=Kt[0];var Pe=Sn[ce];return Pe===void 0&&(Pe=ts++,Sn[ce]=Pe,Xn[Pe]=ce),ce=Pe,Z()[W+8>>>2>>>0]=ce,W}(),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.pause(),jn(()=>ka(en)))}else Vn===2?(Vn=0,jn($a),Rr(en),en=null,Mn.forEach(fe)):Oe(`invalid state: ${Vn}`);return es}}(P=>{g().then(P)})}function Dn(g){return g>>>=0,zr(async()=>{var P=await Nn(g);return Qn(P)})}var tn=[];function xn(g,P,D,B){return D>>>=0,B>>>=0,(g=tn[g>>>0])(null,P=Nn(P>>>0),D,B)}var bn={},Tn=g=>{var P=bn[g];return P===void 0?ar(g):P};function bi(g,P,D,B,W){return D>>>=0,B>>>=0,W>>>=0,(g=tn[g>>>0])(P=Nn(P>>>0),P[D=Tn(D)],B,W)}var xo=()=>typeof globalThis=="object"?globalThis:Function("return this")();function Tc(g){return(g>>>=0)==0?Qn(xo()):(g=Tn(g),Qn(xo()[g]))}var Ec=g=>{var P=tn.length;return tn.push(g),P},Pc=(g,P)=>{for(var D=Array(g),B=0;B<g;++B)D[B]=Jt(de()[P+4*B>>>2>>>0],"parameter "+B);return D},Zs=(g,P)=>Object.defineProperty(P,"name",{value:g});function Sc(g,P,D){var B=(P=Pc(g,P>>>0)).shift();g--;var W=`return function (obj, func, destructorsRef, args) {
`,ce=0,Pe=[];D===0&&Pe.push("obj");for(var ze=["retType"],Qe=[B],nt=0;nt<g;++nt)Pe.push("arg"+nt),ze.push("argType"+nt),Qe.push(P[nt]),W+=`  var arg${nt} = argType${nt}.readValueFromPointer(args${ce?"+"+ce:""});
`,ce+=P[nt].Cb;return W+=`  var rv = ${D===1?"new func":"func.call"}(${Pe.join(", ")});
`,B.Tb||(ze.push("emval_returnValue"),Qe.push(Vt),W+=`  return emval_returnValue(retType, destructorsRef, rv);
`),ze.push(W+`};
`),g=function(vt){var At=Function;if(!(At instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof At} which is not a function`);var Ut=Zs(At.name||"unknownFunctionName",function(){});return Ut.prototype=At.prototype,Ut=new Ut,(vt=At.apply(Ut,vt))instanceof Object?vt:Ut}(ze)(...Qe),D=`methodCaller<(${P.map(vt=>vt.name).join(", ")}) => ${B.name}>`,Ec(Zs(D,g))}function Cc(g){return g=Tn(g>>>0),Qn(i[g])}function kc(g,P){return P>>>=0,g=Nn(g>>>0),P=Nn(P),Qn(g[P])}function $c(g){9<(g>>>=0)&&(lr[g+1]+=1)}function Ic(){return Qn([])}function El(g){g=Nn(g>>>0);for(var P=Array(g.length),D=0;D<g.length;D++)P[D]=g[D];return Qn(P)}function Ac(g){return Qn(Tn(g>>>0))}function Dc(){return Qn({})}function Pl(g){for(var P=Nn(g>>>=0);P.length;){var D=P.pop();P.pop()(D)}Js(g)}function Oc(g,P,D){P>>>=0,D>>>=0,g=Nn(g>>>0),P=Nn(P),D=Nn(D),g[P]=D}function Sl(g,P){return P>>>=0,g=(g=Jt(g>>>0,"_emval_take_value")).readValueFromPointer(P),Qn(g)}function Fc(g,P){g=-9007199254740992>g||9007199254740992<g?NaN:Number(g),P>>>=0,g=new Date(1e3*g),Z()[P>>>2>>>0]=g.getUTCSeconds(),Z()[P+4>>>2>>>0]=g.getUTCMinutes(),Z()[P+8>>>2>>>0]=g.getUTCHours(),Z()[P+12>>>2>>>0]=g.getUTCDate(),Z()[P+16>>>2>>>0]=g.getUTCMonth(),Z()[P+20>>>2>>>0]=g.getUTCFullYear()-1900,Z()[P+24>>>2>>>0]=g.getUTCDay(),g=(g.getTime()-Date.UTC(g.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,Z()[P+28>>>2>>>0]=g}var va=g=>g%4==0&&(g%100!=0||g%400==0),Lc=[0,31,60,91,121,152,182,213,244,274,305,335],Cl=[0,31,59,90,120,151,181,212,243,273,304,334];function kl(g,P){g=-9007199254740992>g||9007199254740992<g?NaN:Number(g),P>>>=0,g=new Date(1e3*g),Z()[P>>>2>>>0]=g.getSeconds(),Z()[P+4>>>2>>>0]=g.getMinutes(),Z()[P+8>>>2>>>0]=g.getHours(),Z()[P+12>>>2>>>0]=g.getDate(),Z()[P+16>>>2>>>0]=g.getMonth(),Z()[P+20>>>2>>>0]=g.getFullYear()-1900,Z()[P+24>>>2>>>0]=g.getDay();var D=(va(g.getFullYear())?Lc:Cl)[g.getMonth()]+g.getDate()-1|0;Z()[P+28>>>2>>>0]=D,Z()[P+36>>>2>>>0]=-60*g.getTimezoneOffset(),D=new Date(g.getFullYear(),6,1).getTimezoneOffset();var B=new Date(g.getFullYear(),0,1).getTimezoneOffset();g=0|(D!=B&&g.getTimezoneOffset()==Math.min(B,D)),Z()[P+32>>>2>>>0]=g}function zc(g){g>>>=0;var P=new Date(Z()[g+20>>>2>>>0]+1900,Z()[g+16>>>2>>>0],Z()[g+12>>>2>>>0],Z()[g+8>>>2>>>0],Z()[g+4>>>2>>>0],Z()[g>>>2>>>0],0),D=Z()[g+32>>>2>>>0],B=P.getTimezoneOffset(),W=new Date(P.getFullYear(),6,1).getTimezoneOffset(),ce=new Date(P.getFullYear(),0,1).getTimezoneOffset(),Pe=Math.min(ce,W);return 0>D?Z()[g+32>>>2>>>0]=+(W!=ce&&Pe==B):0<D!=(Pe==B)&&(W=Math.max(ce,W),P.setTime(P.getTime()+6e4*((0<D?Pe:W)-B))),Z()[g+24>>>2>>>0]=P.getDay(),D=(va(P.getFullYear())?Lc:Cl)[P.getMonth()]+P.getDate()-1|0,Z()[g+28>>>2>>>0]=D,Z()[g>>>2>>>0]=P.getSeconds(),Z()[g+4>>>2>>>0]=P.getMinutes(),Z()[g+8>>>2>>>0]=P.getHours(),Z()[g+12>>>2>>>0]=P.getDate(),Z()[g+16>>>2>>>0]=P.getMonth(),Z()[g+20>>>2>>>0]=P.getYear(),g=P.getTime(),BigInt(isNaN(g)?-1:g/1e3)}function bo(g,P,D,B,W,ce,Pe){return u?Ae(16,1,g,P,D,B,W,ce,Pe):-52}function $l(g,P,D,B,W,ce){if(u)return Ae(17,1,g,P,D,B,W,ce)}var Ti={},Rc=()=>performance.timeOrigin+performance.now();function Il(g,P){if(u)return Ae(18,1,g,P);if(Ti[g]&&(clearTimeout(Ti[g].id),delete Ti[g]),!P)return 0;var D=setTimeout(()=>{delete Ti[g],fe(()=>Gl(g,performance.timeOrigin+performance.now()))},P);return Ti[g]={id:D,qc:P},0}function Bc(g,P,D,B){g>>>=0,P>>>=0,D>>>=0,B>>>=0;var W=new Date().getFullYear(),ce=new Date(W,0,1).getTimezoneOffset();W=new Date(W,6,1).getTimezoneOffset();var Pe=Math.max(ce,W);de()[g>>>2>>>0]=60*Pe,Z()[P>>>2>>>0]=+(ce!=W),g=(P=ze=>{var Qe=Math.abs(ze);return`UTC${0<=ze?"-":"+"}${String(Math.floor(Qe/60)).padStart(2,"0")}${String(Qe%60).padStart(2,"0")}`})(ce),P=P(W),W<ce?(fn(g,D,17),fn(P,B,17)):(fn(g,B,17),fn(P,D,17))}var Nc=()=>Date.now();function jc(g,P,D){return 0<=g&&3>=g?(g===0?g=Date.now():g=performance.timeOrigin+performance.now(),X[D>>>0>>>3]=BigInt(Math.round(1e6*g)),0):28}var Ei=[],wa=(g,P)=>{Ei.length=0;for(var D;D=V()[g++>>>0];){var B=D!=105;P+=(B&=D!=112)&&P%8?4:0,Ei.push(D==112?de()[P>>>2>>>0]:D==106?X[P>>>3]:D==105?Z()[P>>>2>>>0]:Re()[P>>>3>>>0]),P+=B?8:4}return Ei};function Vc(g,P,D){return g>>>=0,P=wa(P>>>0,D>>>0),je[g](...P)}function Al(g,P,D){return g>>>=0,P=wa(P>>>0,D>>>0),je[g](...P)}var ei=()=>{};function Uc(g,P){return x(Gt(g>>>0,P>>>0))}var Df=()=>{throw Te+=1,"unwind"};function Wc(){return 4294901760}var Of=()=>navigator.hardwareConcurrency;function Gc(){return Oe("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function Dl(g){g>>>=0;var P=V().length;if(g<=P||4294901760<g)return!1;for(var D=1;4>=D;D*=2){var B=P*(1+.2/D);B=Math.min(B,g+100663296);e:{B=(Math.min(4294901760,65536*Math.ceil(Math.max(g,B)/65536))-b.buffer.byteLength+65535)/65536|0;try{b.grow(B),j();var W=1;break e}catch{}W=void 0}if(W)return!0}return!1}var To=()=>(Oe("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),Pi={},Ol=g=>{g.forEach(P=>{To()})};function Hc(){var g=Error().stack.toString().split(`
`);return g[0]=="Error"&&g.shift(),Ol(g),Pi.Lb=To(),Pi.cc=g,Pi.Lb}function Kc(g,P,D){if(g>>>=0,P>>>=0,Pi.Lb==g)var B=Pi.cc;else(B=Error().stack.toString().split(`
`))[0]=="Error"&&B.shift(),Ol(B);for(var W=3;B[W]&&To()!=g;)++W;for(g=0;g<D&&B[g+W];++g)Z()[P+4*g>>>2>>>0]=To();return g}var Si,Ma={},Fl=()=>{if(!Si){var g,P={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(g in Ma)Ma[g]===void 0?delete P[g]:P[g]=Ma[g];var D=[];for(g in P)D.push(`${g}=${P[g]}`);Si=D}return Si};function Ll(g,P){if(u)return Ae(19,1,g,P);g>>>=0,P>>>=0;var D=0;return Fl().forEach((B,W)=>{var ce=P+D;for(W=de()[g+4*W>>>2>>>0]=ce,ce=0;ce<B.length;++ce)I()[W++>>>0]=B.charCodeAt(ce);I()[W>>>0]=0,D+=B.length+1}),0}function xa(g,P){if(u)return Ae(20,1,g,P);g>>>=0,P>>>=0;var D=Fl();de()[g>>>2>>>0]=D.length;var B=0;return D.forEach(W=>B+=W.length+1),de()[P>>>2>>>0]=B,0}function zl(g){return u?Ae(21,1,g):52}function Rl(g,P,D,B){return u?Ae(22,1,g,P,D,B):52}function ba(g,P,D,B){return u?Ae(23,1,g,P,D,B):70}var qc=[null,[],[]];function Bl(g,P,D,B){if(u)return Ae(24,1,g,P,D,B);P>>>=0,D>>>=0,B>>>=0;for(var W=0,ce=0;ce<D;ce++){var Pe=de()[P>>>2>>>0],ze=de()[P+4>>>2>>>0];P+=8;for(var Qe=0;Qe<ze;Qe++){var nt=V()[Pe+Qe>>>0],vt=qc[g];nt===0||nt===10?((g===1?M:x)(Bs(vt)),vt.length=0):vt.push(nt)}W+=ze}return de()[B>>>2>>>0]=W,0}u||function(){for(var g=i.numThreads-1;g--;)Ft();ue.unshift(()=>{we++,function(P){u?P():Promise.all(qe.map(ht)).then(P)}(()=>De())})}();for(var Ta=Array(256),Eo=0;256>Eo;++Eo)Ta[Eo]=String.fromCharCode(Eo);Jr=Ta,or=i.BindingError=class extends Error{constructor(g){super(g),this.name="BindingError"}},i.InternalError=class extends Error{constructor(g){super(g),this.name="InternalError"}},lr.push(0,1,void 0,1,null,1,!0,1,!1,1),i.count_emval_handles=()=>lr.length/2-5-Zr.length;var ut,Nl=[$e,Ve,ft,ms,_s,Be,et,it,Yt,Or,_r,gs,ys,Yr,vs,ws,bo,$l,Il,Ll,xa,zl,Rl,ba,Bl];(async function(){function g(B,W){return ut=B.exports,ut=function(){var ce=ut,Pe={};for(let[ze,Qe]of Object.entries(ce))Pe[ze]=typeof Qe=="function"?(...nt)=>{Kt.push(ze);try{return Qe(...nt)}finally{se||(Kt.pop(),en&&Vn===1&&Kt.length===0&&(Vn=0,Te+=1,jn(ql),typeof Fibers<"u"&&Fibers.rc()))}}:Qe;return Pe}(),ut=function(){var ce=ut,Pe=Qe=>nt=>Qe(nt)>>>0,ze=Qe=>()=>Qe()>>>0;return(ce=Object.assign({},ce)).Da=Pe(ce.Da),ce.fb=ze(ce.fb),ce.hb=Pe(ce.hb),ce.tb=Pe(ce.tb),ce.ub=ze(ce.ub),ce.__cxa_get_exception_ptr=Pe(ce.__cxa_get_exception_ptr),ce}(),Tt.push(ut.ib),T=W,De(),ut}we++;var P=Le();if(i.instantiateWasm)return new Promise(B=>{i.instantiateWasm(P,(W,ce)=>{g(W,ce),B(W.exports)})});if(u)return new Promise(B=>{ye=W=>{var ce=new WebAssembly.Instance(W,Le());B(g(ce,W))}});be??(be=i.locateFile?i.locateFile?i.locateFile("ort-wasm-simd-threaded.jsep.wasm",_):_+"ort-wasm-simd-threaded.jsep.wasm":new URL(""+new URL("ort-wasm-simd-threaded.jsep-B0T3yYHD.wasm",import.meta.url).href,import.meta.url).href);try{var D=await async function(B){var W=be;if(!oe&&typeof WebAssembly.instantiateStreaming=="function"&&!F(W))try{var ce=fetch(W,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(ce,B)}catch(Pe){x(`wasm streaming compile failed: ${Pe}`),x("falling back to ArrayBuffer instantiation")}return async function(Pe,ze){try{var Qe=await async function(nt){if(!oe)try{var vt=await f(nt);return new Uint8Array(vt)}catch{}if(nt==be&&oe)nt=new Uint8Array(oe);else{if(!m)throw"both async and sync fetching of the wasm failed";nt=m(nt)}return nt}(Pe);return await WebAssembly.instantiate(Qe,ze)}catch(nt){x(`failed to asynchronously prepare wasm: ${nt}`),Oe(nt)}}(W,B)}(P);return g(D.instance,D.module)}catch(B){return s(B),Promise.reject(B)}})();var jl=g=>(jl=ut.Da)(g),Vl=()=>(Vl=ut.Ea)();i._OrtInit=(g,P)=>(i._OrtInit=ut.Fa)(g,P),i._OrtGetLastError=(g,P)=>(i._OrtGetLastError=ut.Ga)(g,P),i._OrtCreateSessionOptions=(g,P,D,B,W,ce,Pe,ze,Qe,nt)=>(i._OrtCreateSessionOptions=ut.Ha)(g,P,D,B,W,ce,Pe,ze,Qe,nt),i._OrtAppendExecutionProvider=(g,P,D,B,W)=>(i._OrtAppendExecutionProvider=ut.Ia)(g,P,D,B,W),i._OrtAddFreeDimensionOverride=(g,P,D)=>(i._OrtAddFreeDimensionOverride=ut.Ja)(g,P,D),i._OrtAddSessionConfigEntry=(g,P,D)=>(i._OrtAddSessionConfigEntry=ut.Ka)(g,P,D),i._OrtReleaseSessionOptions=g=>(i._OrtReleaseSessionOptions=ut.La)(g),i._OrtCreateSession=(g,P,D)=>(i._OrtCreateSession=ut.Ma)(g,P,D),i._OrtReleaseSession=g=>(i._OrtReleaseSession=ut.Na)(g),i._OrtGetInputOutputCount=(g,P,D)=>(i._OrtGetInputOutputCount=ut.Oa)(g,P,D),i._OrtGetInputOutputMetadata=(g,P,D,B)=>(i._OrtGetInputOutputMetadata=ut.Pa)(g,P,D,B),i._OrtFree=g=>(i._OrtFree=ut.Qa)(g),i._OrtCreateTensor=(g,P,D,B,W,ce)=>(i._OrtCreateTensor=ut.Ra)(g,P,D,B,W,ce),i._OrtGetTensorData=(g,P,D,B,W)=>(i._OrtGetTensorData=ut.Sa)(g,P,D,B,W),i._OrtReleaseTensor=g=>(i._OrtReleaseTensor=ut.Ta)(g),i._OrtCreateRunOptions=(g,P,D,B)=>(i._OrtCreateRunOptions=ut.Ua)(g,P,D,B),i._OrtAddRunConfigEntry=(g,P,D)=>(i._OrtAddRunConfigEntry=ut.Va)(g,P,D),i._OrtReleaseRunOptions=g=>(i._OrtReleaseRunOptions=ut.Wa)(g),i._OrtCreateBinding=g=>(i._OrtCreateBinding=ut.Xa)(g),i._OrtBindInput=(g,P,D)=>(i._OrtBindInput=ut.Ya)(g,P,D),i._OrtBindOutput=(g,P,D,B)=>(i._OrtBindOutput=ut.Za)(g,P,D,B),i._OrtClearBoundOutputs=g=>(i._OrtClearBoundOutputs=ut._a)(g),i._OrtReleaseBinding=g=>(i._OrtReleaseBinding=ut.$a)(g),i._OrtRunWithBinding=(g,P,D,B,W)=>(i._OrtRunWithBinding=ut.ab)(g,P,D,B,W),i._OrtRun=(g,P,D,B,W,ce,Pe,ze)=>(i._OrtRun=ut.bb)(g,P,D,B,W,ce,Pe,ze),i._OrtEndProfiling=g=>(i._OrtEndProfiling=ut.cb)(g),i._JsepOutput=(g,P,D)=>(i._JsepOutput=ut.db)(g,P,D),i._JsepGetNodeName=g=>(i._JsepGetNodeName=ut.eb)(g);var Ci=()=>(Ci=ut.fb)(),Rr=i._free=g=>(Rr=i._free=ut.gb)(g),Po=i._malloc=g=>(Po=i._malloc=ut.hb)(g),So=(g,P,D,B,W,ce)=>(So=ut.kb)(g,P,D,B,W,ce),Ul=()=>(Ul=ut.lb)(),Wl=(g,P,D,B,W)=>(Wl=ut.mb)(g,P,D,B,W),Ea=g=>(Ea=ut.nb)(g),Pa=g=>(Pa=ut.ob)(g),Gl=(g,P)=>(Gl=ut.pb)(g,P),Sa=()=>(Sa=ut.qb)(),Hl=(g,P)=>(Hl=ut.rb)(g,P),Co=g=>(Co=ut.sb)(g),ko=g=>(ko=ut.tb)(g),Ca=()=>(Ca=ut.ub)(),Kl=i.dynCall_ii=(g,P)=>(Kl=i.dynCall_ii=ut.vb)(g,P),ka=g=>(ka=ut.wb)(g),ql=()=>(ql=ut.xb)(),Ql=g=>(Ql=ut.yb)(g),$a=()=>($a=ut.zb)();return i.stackSave=()=>Ca(),i.stackRestore=g=>Co(g),i.stackAlloc=g=>ko(g),i.setValue=function(g,P,D="i8"){switch(D.endsWith("*")&&(D="*"),D){case"i1":case"i8":I()[g>>>0]=P;break;case"i16":ee()[g>>>1>>>0]=P;break;case"i32":Z()[g>>>2>>>0]=P;break;case"i64":X[g>>>3]=BigInt(P);break;case"float":Se()[g>>>2>>>0]=P;break;case"double":Re()[g>>>3>>>0]=P;break;case"*":de()[g>>>2>>>0]=P;break;default:Oe(`invalid type for setValue: ${D}`)}},i.getValue=function(g,P="i8"){switch(P.endsWith("*")&&(P="*"),P){case"i1":case"i8":return I()[g>>>0];case"i16":return ee()[g>>>1>>>0];case"i32":return Z()[g>>>2>>>0];case"i64":return X[g>>>3];case"float":return Se()[g>>>2>>>0];case"double":return Re()[g>>>3>>>0];case"*":return de()[g>>>2>>>0];default:Oe(`invalid type for getValue: ${P}`)}},i.UTF8ToString=Gt,i.stringToUTF8=fn,i.lengthBytesUTF8=Ns,function g(){if(0<we)Ce=g;else if(u)r(i),he();else{for(;0<ue.length;)ue.shift()(i);0<we?Ce=g:(i.calledRun=!0,se||(he(),r(i)))}}(),i.PTR_SIZE=4,o}),fA=Fm,wE=(t=(e=globalThis.self)==null?void 0:e.name)==null?void 0:t.startsWith("em-pthread"),wE&&Fm()}),Lm,Bg,ME,Nr,hA,jd,xE,bE,zm,TE,Rm,mA,Bm,_A,Ey=Ue(()=>{Ty(),Lm=typeof location>"u"?void 0:location.origin,Bg=import.meta.url>"file:"&&import.meta.url<"file;",ME=()=>{{if(Bg){let e=URL;return new URL(new e("ort.bundle.min.mjs",import.meta.url).href,Lm).href}return import.meta.url}},Nr=ME(),hA=()=>{if(Nr&&!Nr.startsWith("blob:"))return Nr.substring(0,Nr.lastIndexOf("/")+1)},jd=(e,t)=>{try{let n=t??Nr;return(n?new URL(e,n):new URL(e)).origin===Lm}catch{return!1}},xE=(e,t)=>{let n=t??Nr;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},bE=(e,t)=>`${t??"./"}${e}`,zm=async e=>{let t=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},TE=async e=>(await import(e)).default,Rm=(YV(),uc(cA)).default,mA=async()=>{if(!Nr)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(jd(Nr))return[void 0,Rm()];let e=await zm(Nr);return[e,Rm(e)]},Bm=(JV(),uc(pA)).default,_A=async(e,t,n)=>{if(!e&&!t&&Bm&&Nr&&jd(Nr))return[void 0,Bm];{let r="ort-wasm-simd-threaded.jsep.mjs",s=e??xE(r,t),i=n&&s&&!jd(s,t),o=i?await zm(s):s??bE(r,t);return[i?o:void 0,await TE(o)]}}}),Nm,Vd,uu,jm,EE,PE,SE,Py,Xt,ga=Ue(()=>{Ey(),Vd=!1,uu=!1,jm=!1,EE=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},PE=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},SE=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},Py=async e=>{if(Vd)return Promise.resolve();if(uu)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(jm)throw new Error("previous call to 'initializeWebAssembly()' failed.");uu=!0;let t=e.initTimeout,n=e.numThreads;if(e.simd!==!1){if(e.simd==="relaxed"){if(!SE())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!PE())throw new Error("WebAssembly SIMD is not supported in the current environment.")}let r=EE();n>1&&!r&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let s=e.wasmPaths,i=typeof s=="string"?s:void 0,o=s==null?void 0:s.mjs,a=(o==null?void 0:o.href)??o,l=s==null?void 0:s.wasm,u=(l==null?void 0:l.href)??l,p=e.wasmBinary,[c,d]=await _A(a,i,n>1),f=!1,m=[];if(t>0&&m.push(new Promise(y=>{setTimeout(()=>{f=!0,y()},t)})),m.push(new Promise((y,C)=>{let _={numThreads:n};if(p)_.wasmBinary=p;else if(u||i)_.locateFile=h=>u??i+h;else if(a&&a.indexOf("blob:")!==0)_.locateFile=h=>new URL(h,a).href;else if(c){let h=hA();h&&(_.locateFile=w=>h+w)}d(_).then(h=>{uu=!1,Vd=!0,Nm=h,y(),c&&URL.revokeObjectURL(c)},h=>{uu=!1,jm=!0,C(h)})})),await Promise.race(m),f)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Xt=()=>{if(Vd&&Nm)return Nm;throw new Error("WebAssembly is not initialized yet.")}}),Is,nf,Wt,Sy=Ue(()=>{ga(),Is=(e,t)=>{let n=Xt(),r=n.lengthBytesUTF8(e)+1,s=n._malloc(r);return n.stringToUTF8(e,s,r),t.push(s),s},nf=(e,t,n,r)=>{if(typeof e=="object"&&e!==null){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach(([s,i])=>{let o=t?t+s:s;if(typeof i=="object")nf(i,o+".",n,r);else if(typeof i=="string"||typeof i=="number")r(o,i.toString());else if(typeof i=="boolean")r(o,i?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},Wt=e=>{let t=Xt(),n=t.stackSave();try{let r=t.PTR_SIZE,s=t.stackAlloc(2*r);t._OrtGetLastError(s,s+r);let i=Number(t.getValue(s,r===4?"i32":"i64")),o=t.getValue(s+r,"*"),a=o?t.UTF8ToString(o):"";throw new Error(`${e} ERROR_CODE: ${i}, ERROR_MESSAGE: ${a}`)}finally{t.stackRestore(n)}}}),gA,ZV=Ue(()=>{ga(),Sy(),gA=e=>{let t=Xt(),n=0,r=[],s=e||{};try{if((e==null?void 0:e.logSeverityLevel)===void 0)s.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if((e==null?void 0:e.logVerbosityLevel)===void 0)s.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);(e==null?void 0:e.terminate)===void 0&&(s.terminate=!1);let i=0;return(e==null?void 0:e.tag)!==void 0&&(i=Is(e.tag,r)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,i),n===0&&Wt("Can't create run options."),(e==null?void 0:e.extra)!==void 0&&nf(e.extra,"",new WeakSet,(o,a)=>{let l=Is(o,r),u=Is(a,r);t._OrtAddRunConfigEntry(n,l,u)!==0&&Wt(`Can't set a run config entry: ${o} - ${a}.`)}),[n,r]}catch(i){throw n!==0&&t._OrtReleaseRunOptions(n),r.forEach(o=>t._free(o)),i}}}),CE,kE,$E,cu,IE,yA,eU=Ue(()=>{ga(),Sy(),CE=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},kE=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},$E=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(e.enableMemPattern=!1)},cu=(e,t,n,r)=>{let s=Is(t,r),i=Is(n,r);Xt()._OrtAddSessionConfigEntry(e,s,i)!==0&&Wt(`Can't set a session config entry: ${t} - ${n}.`)},IE=async(e,t,n)=>{for(let r of t){let s=typeof r=="string"?r:r.name,i=[];switch(s){case"webnn":if(s="WEBNN",typeof r!="string"){let p=r==null?void 0:r.deviceType;p&&cu(e,"deviceType",p,n)}break;case"webgpu":if(s="JS",typeof r!="string"){let p=r;if(p!=null&&p.preferredLayout){if(p.preferredLayout!=="NCHW"&&p.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${p.preferredLayout}`);cu(e,"preferredLayout",p.preferredLayout,n)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${s}`)}let o=Is(s,n),a=i.length,l=0,u=0;if(a>0){l=Xt()._malloc(a*Xt().PTR_SIZE),n.push(l),u=Xt()._malloc(a*Xt().PTR_SIZE),n.push(u);for(let p=0;p<a;p++)Xt().setValue(l+p*Xt().PTR_SIZE,i[p][0],"*"),Xt().setValue(u+p*Xt().PTR_SIZE,i[p][1],"*")}await Xt()._OrtAppendExecutionProvider(e,o,l,u,a)!==0&&Wt(`Can't append execution provider: ${s}.`)}},yA=async e=>{let t=Xt(),n=0,r=[],s=e||{};$E(s);try{let i=CE(s.graphOptimizationLevel??"all"),o=kE(s.executionMode??"sequential"),a=typeof s.logId=="string"?Is(s.logId,r):0,l=s.logSeverityLevel??2;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log serverity level is not valid: ${l}`);let u=s.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let p=typeof s.optimizedModelFilePath=="string"?Is(s.optimizedModelFilePath,r):0;if(n=t._OrtCreateSessionOptions(i,!!s.enableCpuMemArena,!!s.enableMemPattern,o,!!s.enableProfiling,0,a,l,u,p),n===0&&Wt("Can't create session options."),s.executionProviders&&await IE(n,s.executionProviders,r),s.enableGraphCapture!==void 0){if(typeof s.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${s.enableGraphCapture}`);cu(n,"enableGraphCapture",s.enableGraphCapture.toString(),r)}if(s.freeDimensionOverrides)for(let[c,d]of Object.entries(s.freeDimensionOverrides)){if(typeof c!="string")throw new Error(`free dimension override name must be a string: ${c}`);if(typeof d!="number"||!Number.isInteger(d)||d<0)throw new Error(`free dimension override value must be a non-negative integer: ${d}`);let f=Is(c,r);t._OrtAddFreeDimensionOverride(n,f,d)!==0&&Wt(`Can't set a free dimension override: ${c} - ${d}.`)}return s.extra!==void 0&&nf(s.extra,"",new WeakSet,(c,d)=>{cu(n,c,d,r)}),[n,r]}catch(i){throw n!==0&&t._OrtReleaseSessionOptions(n)!==0&&Wt("Can't release session options."),r.forEach(o=>t._free(o)),i}}}),Ra,oi,Ko,Cy,rf,ky,$y,Ng,mt=Ue(()=>{Ra=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},oi=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},Ko=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],r=typeof t=="number"?t:t.reduce((s,i)=>s*i,1);return n>0?Math.ceil(r*n):void 0},Cy=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},rf=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},ky=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",$y=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",Ng=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}}),Iy,vA=Ue(()=>{Ty(),Iy=async e=>{if(typeof e=="string"){let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),r=n?parseInt(n,10):0;if(r<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let s=t.body.getReader(),i;try{i=new ArrayBuffer(r)}catch(a){if(a instanceof RangeError){let l=Math.ceil(r/65536);i=new WebAssembly.Memory({initial:l,maximum:l}).buffer}else throw a}let o=0;for(;;){let{done:a,value:l}=await s.read();if(a)break;let u=l.byteLength;new Uint8Array(i,o,u).set(l),o+=u}return new Uint8Array(i,0,r)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),AE,DE,OE,FE,Ay,LE,Dt,wi=Ue(()=>{mt(),AE=["V","I","W","E","F"],DE=(e,t)=>{console.log(`[${AE[e]},${new Date().toISOString()}]${t}`)},Ay=(e,t)=>{OE=e,FE=t},LE=(e,t)=>{let n=rf(e),r=rf(OE);n>=r&&DE(n,typeof t=="function"?t():t)},Dt=(...e)=>{FE&&LE(...e)}}),zE,yl,Me,sf,wA,MA,xA,xt=Ue(()=>{zE=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},yl=class{static calcShape(e,t,n=!1){let r=e.length,s=t.length;if(r===0)return t;if(s===0)return e;let i=Math.max(e.length,t.length),o=new Array(i);if(n){if(r<2||s<2)return;let a=zE.calcMatMulShape([e[r-2],e[r-1]],[t[s-2],t[s-1]]);if(a===void 0)return;[o[i-2],o[i-1]]=a}for(let a=n?3:1;a<=i;a++){let l=r-a<0?1:e[r-a],u=s-a<0?1:t[s-a];if(l!==u&&l>1&&u>1)return;let p=Math.max(l,u);if(l&&u)o[i-a]=Math.max(l,u);else{if(p>1)return;o[i-a]=0}}return o}static isValidBroadcast(e,t){let n=e.length,r=t.length;if(n>r)return!1;for(let s=1;s<=n;s++)if(e[n-s]!==1&&e[n-s]!==t[r-s])return!1;return!0}},Me=class yp{static size(t){return yp.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,n=4){let r=t.length;if(r===0)return[];let s=new Array(r),i=r-1;for(;i>=0;){if(t[i]%n===0){s[i]=t[i]/n;break}if(n%t[i]!==0)throw new Error("cannot convert shape");s[i]=1,n/=t[i],i--}for(i--;i>=0;i--)s[i]=t[i];return s}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return yp.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return yp.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(t,n,r){let s=1;for(let i=n;i<r;i++){if(t[i]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");s*=Number(t[i])}return s}static computeStrides(t){let n=t.length;if(n===0)return[];if(n===1)return[1];let r=new Array(n);r[n-1]=1,r[n-2]=t[n-1];for(let s=n-3;s>=0;--s)r[s]=r[s+1]*t[s+1];return r}static normalizeAxis(t,n){if(t<-n&&t>=n)throw new Error("unsupported axis for this operation.");return t<0?t+n:t}static normalizeAxes(t,n){return t.map(r=>this.normalizeAxis(r,n??t.length))}static sortBasedOnPerm(t,n){return n?n.map(r=>t[r]):t.slice().reverse()}static padShape(t,n){let r=t.length;return t.map((s,i)=>s+n[i]+n[i+r])}static areEqual(t,n){return t.length!==n.length?!1:t.every((r,s)=>r===n[s])}},sf=class Tu{static adjustPoolAttributes(t,n,r,s,i,o){if(!t&&r.length!==n.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let a=0;a<n.length-2;a++)a>=r.length?r.push(n[a+2]):r[a]=n[a+2];for(let a=0;a<r.length;a++)if(a<s.length){if(s[a]<0)throw new Error("strides should be greater than or equal to 1")}else s.push(1);for(let a=0;a<r.length;a++)if(a<i.length){if(i[a]<0)throw new Error("dilations should be greater than or equal to 1")}else i.push(1);for(let a=0;a<r.length*2;a++)if(a<o.length){if(o[a]<0)throw new Error("pad should be greater than or equal to 1")}else o.push(0);for(let a=0;a<r.length;a++){if(r[a]<=0)throw new Error("kernel shapes need to be greater than 0");if(o[a]>=r[a]||o[a+r.length]>=r[a])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,r,s,i,o,a){if(a){if(i.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(s.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let l=0;l<t.length-2;l++)Tu.adjustPadAndReturnShape(t[l+(o?1:2)],n[l],r[l],s[l],i,l,l+t.length-2,a)}}static computePoolOutputShape(t,n,r,s,i,o,a){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let l=[n[0],n[1]];return Tu.computeShapeHelper(t,n,l,r,s,i,o,a),l}static computeConvOutputShape(t,n,r,s,i,o,a){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let l=[t[0],n[0]];return Tu.computeShapeHelper(!1,t,l,r,s,i,o,a),l}static computeShapeHelper(t,n,r,s,i,o,a,l){if(t)for(let u=0;u<n.length-2;u++)r.push(1);else for(let u=0;u<n.length-2;u++)r.push(Tu.adjustPadAndReturnShape(n[u+2],s[u],i[u],o[u],a,u,u+n.length-2,l))}static adjustPadAndReturnShape(t,n,r,s,i,o,a,l){let u=r*(s-1)+1;if(l&&l!=="NOTSET")switch(l){case"VALID":return i[o]=0,i[a]=0,Math.floor((t-u)/n+1);case"SAME_LOWER":case"SAME_UPPER":if(r!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let p=((t+n-1)/n-1)*n+s-t;return i[o]=Math.floor(l==="SAME_LOWER"?(p+1)/2:p/2),i[a]=p-i[o],Math.floor((t+p-s)/n+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+i[o]+i[a]-u)/n+1)}},wA=class{static getShapeOfGemmResult(e,t,n,r,s){if(e.length!==2||n.length!==2)throw new Error("shape need to be of size 2");let i,o,a;t?(i=e[1],o=e[0]):(i=e[0],o=e[1]);let l=-1;if(r?(a=n[0],l=1):(a=n[1],l=0),n[l]!==o)throw new Error("dimension mismatch");if(i<=0||a<=0||o<=0)throw new Error("invalid shape specified");if(s&&!yl.isValidBroadcast(s,[i,a]))throw new Error("gemm: invalid bias shape for broadcast");return[i,a,o]}},MA=-34028234663852886e22,xA=34028234663852886e22}),Dy,bA=Ue(()=>{mt(),Dy=(e,t)=>new(Cy(t))(e)}),jg,Vm,RE,Um,BE,Wm,Gm,Hm,NE,TA,tU=Ue(()=>{wi(),jg=(e,t=!0)=>{if(e.byteLength%8!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 8 (BigInt).");let n=e.byteLength/8,r=new BigInt64Array(e.buffer,e.byteOffset,n),s=new Int32Array(n);for(let i=0;i<n;i++){let o=r[i];if(o>2147483647n||o<-2147483648n)throw new Error(`Overflow occurred when converting BigInt to Int32 at index ${i}: ${o}`);s[i]=Number(o)}return t?new Uint8Array(s.buffer):s},Vm=(e,t=!0)=>{if(e.byteLength%4!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (Int32).");let n=e.byteLength/4,r=new Int32Array(e.buffer,e.byteOffset,n),s=BigInt64Array.from(r,BigInt);return t?new Uint8Array(s.buffer):s},RE=1,Um=()=>RE++,BE=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),Wm=(e,t)=>{let n=BE.get(e);if(!n)throw new Error("Unsupported data type.");return t.length>0?Math.ceil(t.reduce((r,s)=>r*s)*n/8):0},Gm=class{constructor(e){this.shouldConvertInt64toInt32=!1,this.isInt64ToInt32Converted=!1;let{sessionId:t,context:n,tensor:r,dataType:s,shape:i,shouldConvertInt64toInt32:o=!1}=e;this.sessionId=t,this.mlContext=n,this.mlTensor=r,this.dataType=s,this.tensorShape=i,this.shouldConvertInt64toInt32=o}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return Wm(this.dataType,this.tensorShape)}destroy(){Dt("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e,t){if(e){let n=await this.mlContext.readTensor(this.mlTensor),r=Vm(new Uint8Array(n));if(t){(t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength)).set(r);return}else return r.buffer}else return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(e,t,n){return this.mlContext===e&&this.dataType===t&&this.tensorShape.length===n.length&&this.tensorShape.every((r,s)=>r===n[s])}setIsInt64ToInt32Converted(e){this.isInt64ToInt32Converted=e}},Hm=class{constructor(e,t){this.tensorManager=e,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,t,n,r){let s=t,i=this.tensorManager.getMLContext(e),o=s==="int64"&&!i.opSupportLimits().input.dataTypes.includes("int64");if(o&&(s="int32",Dt("verbose",()=>"[WebNN] TensorIdTracker.ensureTensor: convert dataType from int64 to int32")),this.wrapper){if(this.wrapper.canReuseTensor(i,s,n))return this.wrapper.tensor;if(r){if(this.wrapper.byteLength!==Wm(s,n))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let a=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,s,n,a,!0,!0,o),r&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){let t=e;if(this.wrapper)if(this.wrapper.shouldConvertInt64toInt32&&(t=jg(e,!0),this.wrapper.setIsInt64ToInt32Converted(!0)),t.byteLength===this.wrapper.byteLength){this.wrapper.write(t);return}else Dt("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor();this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(e){var t,n,r;if(this.activeUpload){let s=(t=this.wrapper)!=null&&t.isInt64ToInt32Converted?Vm(this.activeUpload):this.activeUpload;if(e){e instanceof ArrayBuffer?new Uint8Array(e).set(s):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(s);return}else return s.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read((n=this.wrapper)==null?void 0:n.shouldConvertInt64toInt32,e):this.wrapper.read((r=this.wrapper)==null?void 0:r.shouldConvertInt64toInt32)}},NE=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(e){let t=this.backend.getMLContext(e);if(!t)throw new Error("MLContext not found for session.");return t}reserveTensorId(){let e=Um();return this.tensorTrackersById.set(e,new Hm(this)),e}releaseTensorId(e){let t=this.tensorTrackersById.get(e);t&&(this.tensorTrackersById.delete(e),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(e,t,n,r,s){Dt("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${n}, shape: ${r}, copyOld: ${s}}`);let i=this.tensorTrackersById.get(t);if(!i)throw new Error("Tensor not found.");return i.ensureTensor(e,n,r,s)}upload(e,t){let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");n.upload(t)}async download(e,t){Dt("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${t==null?void 0:t.byteLength}}`);let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");return n.download(t)}releaseTensorsForSession(e){for(let t of this.freeTensors)t.sessionId===e&&t.destroy();this.freeTensors=this.freeTensors.filter(t=>t.sessionId!==e)}registerTensor(e,t,n,r){let s=this.getMLContext(e),i=Um(),o=new Gm({sessionId:e,context:s,tensor:t,dataType:n,shape:r});return this.tensorTrackersById.set(i,new Hm(this,o)),this.externalTensors.add(o),i}async getCachedTensor(e,t,n,r,s,i,o=!1){let a=this.getMLContext(e);for(let[u,p]of this.freeTensors.entries())if(p.canReuseTensor(a,t,n)){Dt("verbose",()=>`[WebNN] Reusing tensor {dataType: ${t}, shape: ${n}}`);let c=this.freeTensors.splice(u,1)[0];return c.sessionId=e,c}Dt("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${t}, shape: ${n}}`);let l=await a.createTensor({dataType:t,shape:n,dimensions:n,usage:r,writable:s,readable:i});return new Gm({sessionId:e,context:a,tensor:l,dataType:t,shape:n,shouldConvertInt64toInt32:o})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},TA=(...e)=>new NE(...e)}),Ud,jE,EA,nU=Ue(()=>{mt(),ga(),bA(),tU(),wi(),Ud=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),jE=(e,t)=>{if(e===t)return!0;if(e===void 0||t===void 0)return!1;let n=Object.keys(e).sort(),r=Object.keys(t).sort();return n.length===r.length&&n.every((s,i)=>s===r[i]&&e[s]===t[s])},EA=class{constructor(e){this.tensorManager=TA(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.temporaryGraphInputs=[],this.temporarySessionTensorIds=new Map,Ay(e.logLevel,!!e.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(e){Dt("verbose",()=>`[WebNN] onRunStart {sessionId: ${e}}`),this.activeSessionId=e}onRunEnd(e){Dt("verbose",()=>`[WebNN] onRunEnd {sessionId: ${e}}`);let t=this.temporarySessionTensorIds.get(e);if(t){for(let n of t)Dt("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${n}}`),this.tensorManager.releaseTensorId(n);this.temporarySessionTensorIds.delete(e),this.activeSessionId=void 0}}async createMLContext(e){if(e instanceof GPUDevice){let n=this.mlContextCache.findIndex(r=>r.gpuDevice===e);if(n!==-1)return this.mlContextCache[n].mlContext;{let r=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:r}),r}}else if(e===void 0){let n=this.mlContextCache.findIndex(r=>r.options===void 0&&r.gpuDevice===void 0);if(n!==-1)return this.mlContextCache[n].mlContext;{let r=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:r}),r}}let t=this.mlContextCache.findIndex(n=>jE(n.options,e));if(t!==-1)return this.mlContextCache[t].mlContext;{let n=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:n}),n}}registerMLContext(e,t){this.mlContextBySessionId.set(e,t);let n=this.sessionIdsByMLContext.get(t);n||(n=new Set,this.sessionIdsByMLContext.set(t,n)),n.add(e),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(e,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(e){this.sessionGraphInputs.delete(e);let t=this.mlContextBySessionId.get(e);if(!t)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let n=this.sessionIdsByMLContext.get(t);if(n.delete(e),n.size===0){this.sessionIdsByMLContext.delete(t);let r=this.mlContextCache.findIndex(s=>s.mlContext===t);r!==-1&&this.mlContextCache.splice(r,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){Dt("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,t,n,r,s){let i=Ud.get(n);if(!i)throw new Error(`Unsupported ONNX data type: ${n}`);return this.tensorManager.ensureTensor(e??this.currentSessionId,t,i,r,s)}async createTemporaryTensor(e,t,n){Dt("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${t}, shape: ${n}}`);let r=Ud.get(t);if(!r)throw new Error(`Unsupported ONNX data type: ${t}`);let s=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(e,s,r,n,!1);let i=this.temporarySessionTensorIds.get(e);return i?i.push(s):this.temporarySessionTensorIds.set(e,[s]),s}uploadTensor(e,t){if(!Xt().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");Dt("verbose",()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${t.byteLength}}`),this.tensorManager.upload(e,t)}async downloadTensor(e,t){return this.tensorManager.download(e,t)}createMLTensorDownloader(e,t){return async()=>{let n=await this.tensorManager.download(e);return Dy(n,t)}}registerMLTensor(e,t,n,r){let s=Ud.get(n);if(!s)throw new Error(`Unsupported ONNX data type: ${n}`);let i=this.tensorManager.registerTensor(e,t,s,r);return Dt("verbose",()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${s}, dimensions: ${r}} -> {tensorId: ${i}}`),i}registerMLConstant(e,t,n,r,s,i,o=!1){if(!i)throw new Error("External mounted files are not available.");let a=e;e.startsWith("./")&&(a=e.substring(2));let l=i.get(a);if(!l)throw new Error(`File with name ${a} not found in preloaded files.`);if(t+n>l.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let u=l.slice(t,t+n).buffer,p;switch(s.dataType){case"float32":p=new Float32Array(u);break;case"float16":p=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(u):new Uint16Array(u);break;case"int32":p=new Int32Array(u);break;case"uint32":p=new Uint32Array(u);break;case"int64":o?(p=jg(new Uint8Array(u),!1),s.dataType="int32"):p=new BigInt64Array(u);break;case"uint64":p=new BigUint64Array(u);break;case"int8":p=new Int8Array(u);break;case"int4":case"uint4":case"uint8":p=new Uint8Array(u);break;default:throw new Error(`Unsupported data type: ${s.dataType} in creating WebNN Constant from external data.`)}return Dt("verbose",()=>`[WebNN] registerMLConstant {dataType: ${s.dataType}, shape: ${s.shape}}} ${o?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),r.constant(s,p)}registerGraphInput(e){this.temporaryGraphInputs.push(e)}isGraphInput(e,t){let n=this.sessionGraphInputs.get(e);return n?n.includes(t):!1}isInt64Supported(e){var t;return!!((t=this.mlContextBySessionId.get(e))!=null&&t.opSupportLimits().input.dataTypes.includes("int64"))}flush(){}}}),Oy=Ue(()=>{}),Km,Wd,Gd,VE,UE,qm,Vg,WE,PA,rU=Ue(()=>{wi(),Oy(),Km=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Wd=[],Gd=e=>Math.ceil(Number(e)/16)*16,VE=e=>{for(let t=0;t<Wd.length;t++){let n=Wd[t];if(e<=n)return n}return Math.ceil(e/16)*16},UE=1,qm=()=>UE++,Vg=async(e,t,n,r)=>{let s=Gd(n),i=e.device.createBuffer({size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let o=e.getCommandEncoder();e.endComputePass(),o.copyBufferToBuffer(t,0,i,0,s),e.flush(),await i.mapAsync(GPUMapMode.READ);let a=i.getMappedRange();if(r){let l=r();return l.set(new Uint8Array(a,0,n)),l}else return new Uint8Array(a.slice(0,n))}finally{i.destroy()}},WE=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[t]of Km)Wd.push(t),this.freeBuffers.set(t,[]),this.freeUniformBuffers.set(t,[]);this.sessionCount=0}upload(e,t){let n=t.buffer,r=t.byteOffset,s=t.byteLength,i=Gd(s),o=this.storageCache.get(e);if(!o)throw new Error("gpu data for uploading does not exist");if(Number(o.originalSize)!==s)throw new Error(`inconsistent data size. gpu data size=${o.originalSize}, data size=${s}`);let a=this.backend.device.createBuffer({mappedAtCreation:!0,size:i,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=a.getMappedRange();new Uint8Array(l).set(new Uint8Array(n,r,s)),a.unmap();let u=this.backend.device.createCommandEncoder();u.copyBufferToBuffer(a,0,o.gpuData.buffer,0,i),this.backend.device.queue.submit([u.finish()]),a.destroy(),Dt("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${e})`)}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=Gd(n.originalSize),i=this.backend.getCommandEncoder();this.backend.endComputePass(),i.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,s)}registerExternalBuffer(e,t,n){let r;if(n){if(r=n[0],e===n[1])return Dt("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, buffer is the same, skip.`),r;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else r=qm();return this.storageCache.set(r,{gpuData:{id:r,type:0,buffer:e},originalSize:t}),Dt("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, registered.`),r}unregisterExternalBuffer(e){e!==void 0&&(this.storageCache.delete(e),Dt("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n=VE(e),r,s=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,i=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||i){let a=(s?this.freeBuffers:this.freeUniformBuffers).get(n);a?a.length>0?r=a.pop():r=this.backend.device.createBuffer({size:n,usage:t}):r=this.backend.device.createBuffer({size:n,usage:t})}else r=this.backend.device.createBuffer({size:n,usage:t});let o={id:qm(),type:0,buffer:r};return this.storageCache.set(o.id,{gpuData:o,originalSize:Number(e)}),Dt("verbose",()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${o.id}`),o}get(e){var t;return(t=this.storageCache.get(e))==null?void 0:t.gpuData}release(e){let t=typeof e=="bigint"?Number(e):e,n=this.storageCache.get(t);if(!n){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return Dt("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(e,t){let n=this.storageCache.get(Number(e));if(!n)throw new Error("data does not exist");await Vg(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let e of this.buffersPending){let t=Km.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(e.size)||[];t===void 0||n.length>=t?e.destroy():n.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(e.size)||[];t===void 0||n.length>=t?e.destroy():n.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let t of this.buffersPending)e.push(t);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.freeUniformBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(e){let t=this.capturedPendingBuffers.get(e);t&&(t.forEach(n=>{n.destroy()}),this.capturedPendingBuffers.delete(e)),this.sessionCount-=1,this.sessionCount===0&&(Dt("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(n=>{n.gpuData.buffer.destroy()}),this.storageCache=new Map)}},PA=(...e)=>new WE(...e)}),GE,jt,wn=Ue(()=>{GE=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},jt=e=>new GE(e)}),vl,Hd,Kn,fr,lt,pn,Ug,nl,ro,at,du,ke,rt,SA,Fy,HE,CA,bt=Ue(()=>{mt(),xt(),vl=64,Hd=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},Kn=(e,t=1)=>{let n=Hd(e,t);return typeof n=="string"?n:n[0]},fr=(e,t=1)=>{let n=Hd(e,t);return typeof n=="string"?n:n[1]},lt=(...e)=>{let t=[];return e.forEach(n=>{n.length!==0&&t.push({type:12,data:n},{type:12,data:Me.computeStrides(n)})}),t},pn=e=>e%4===0?4:e%2===0?2:1,Ug=(e="f32",t,n="0")=>!t||t===1?`${e}(${n})`:`vec${t}<${e}>(${n})`,nl=(e,t,n)=>e==="f32"?n:t===1?`f32(${n})`:`vec${t}<f32>(${n})`,ro=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,at=(e,t,n,r)=>e.startsWith("uniforms.")&&n>4?typeof t=="string"?r==="f16"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:r==="f16"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,du=(e,t,n,r,s)=>{let i=typeof n=="number",o=i?n:n.length,a=[...new Array(o).keys()],l=o<2?"u32":o<=4?`vec${o}<u32>`:`array<u32, ${o}>`,u=Hd(t,s),p=typeof u=="string"?u:u[1],c=typeof u=="string"?u:u[0],d={indices:l,value:p,storage:c,tensor:t},f=F=>typeof F=="string"?F:`${F}u`,m={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},y=i?"uniforms.":"",C=`${y}${e}_shape`,_=`${y}${e}_strides`,h="";for(let F=0;F<o-1;F++)h+=`
    let dim${F} = current / ${at(_,F,o)};
    let rest${F} = current % ${at(_,F,o)};
    indices[${F}] = dim${F};
    current = rest${F};
    `;h+=`indices[${o-1}] = current;`;let w=o<2?"":`
  fn o2i_${e}(offset: u32) -> ${d.indices} {
    var indices: ${d.indices};
    var current = offset;
    ${h}
    return indices;
  }`,M=F=>(m.offsetToIndices=!0,o<2?F:`o2i_${e}(${F})`),x=[];if(o>=2)for(let F=o-1;F>=0;F--)x.push(`${at(_,F,o)} * (indices[${F}])`);let b=o<2?"":`
  fn i2o_${e}(indices: ${d.indices}) -> u32 {
    return ${x.join("+")};
  }`,T=F=>(m.indicesToOffset=!0,o<2?F:`i2o_${e}(${F})`),S=(...F)=>o===0?"0u":`${d.indices}(${F.map(f).join(",")})`,$=(F,I)=>o<2?`${F}`:`${at(F,I,o)}`,O=(F,I,V)=>o<2?`${F}=${V};`:`${at(F,I,o)}=${V};`,G={},H=(F,I)=>{m.broadcastedIndicesToOffset=!0;let V=`${I.name}broadcastedIndicesTo${e}Offset`;if(V in G)return`${V}(${F})`;let ee=[];for(let pe=o-1;pe>=0;pe--){let Z=I.indicesGet("outputIndices",pe+I.rank-o);ee.push(`${$(_,pe)} * (${Z} % ${$(C,pe)})`)}return G[V]=`fn ${V}(outputIndices: ${I.type.indices}) -> u32 {
             return ${ee.length>0?ee.join("+"):"0u"};
           }`,`${V}(${F})`},N=(F,I)=>(()=>{if(d.storage===d.value)return`${e}[${F}]=${I};`;if(d.storage==="vec2<u32>"&&d.value==="i32")return`${e}[${F}]=vec2<u32>(u32(${I}), select(0u, 0xFFFFFFFFu, ${I} < 0));`;if(d.storage==="vec2<u32>"&&d.value==="u32")return`${e}[${F}]=vec2<u32>(u32(${I}), 0u);`;if(d.storage==="u32"&&d.value==="vec4<bool>")return`${e}[${F}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${I}));`;throw new Error(`not supported combination of storage type ${d.storage} and value type ${d.value} yet`)})(),J=F=>(()=>{if(d.storage===d.value)return`${e}[${F}]`;if(d.storage==="vec2<u32>"&&d.value==="i32")return`i32(${e}[${F}].x)`;if(d.storage==="vec2<u32>"&&d.value==="u32")return`u32(${e}[${F}].x)`;if(d.storage==="u32"&&d.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${F}] & 0xFFu), bool(${e}[${F}] & 0xFF00u), bool(${e}[${F}] & 0xFF0000u), bool(${e}[${F}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${d.storage} and value type ${d.value} yet`)})(),q=o<2?"":`
  fn get_${e}ByIndices(indices: ${d.indices}) -> ${p} {
    return ${J(`i2o_${e}(indices)`)};
  }`,X=o<2?"":(()=>{let F=a.map(V=>`d${V}: u32`).join(", "),I=a.map(V=>`d${V}`).join(", ");return`
  fn get_${e}(${F}) -> ${p} {
    return get_${e}ByIndices(${S(I)});
  }`})(),Y=(...F)=>{if(F.length!==o)throw new Error(`indices length must be ${o}`);let I=F.map(f).join(",");return o===0?J("0u"):o===1?J(I[0]):(m.get=!0,m.getByIndices=!0,m.indicesToOffset=!0,`get_${e}(${I})`)},K=F=>o<2?J(F):(m.getByIndices=!0,m.indicesToOffset=!0,`get_${e}ByIndices(${F})`),oe=o<2?"":`
  fn set_${e}ByIndices(indices: ${d.indices}, value: ${p}) {
    ${N(`i2o_${e}(indices)`,"value")}
  }`,se=o<2?"":(()=>{let F=a.map(V=>`d${V}: u32`).join(", "),I=a.map(V=>`d${V}`).join(", ");return`
  fn set_${e}(${F}, value: ${p}) {
    set_${e}ByIndices(${S(I)}, value);
  }`})();return{impl:()=>{let F=[],I=!1;return m.offsetToIndices&&(F.push(w),I=!0),m.indicesToOffset&&(F.push(b),I=!0),m.broadcastedIndicesToOffset&&(Object.values(G).forEach(V=>F.push(V)),I=!0),m.set&&(F.push(se),I=!0),m.setByIndices&&(F.push(oe),I=!0),m.get&&(F.push(X),I=!0),m.getByIndices&&(F.push(q),I=!0),!i&&I&&F.unshift(`const ${C} = ${d.indices}(${n.join(",")});`,`const ${_} = ${d.indices}(${Me.computeStrides(n).join(",")});`),F.join(`
`)},type:d,offsetToIndices:M,indicesToOffset:T,broadcastedIndicesToOffset:H,indices:S,indicesGet:$,indicesSet:O,set:(...F)=>{if(F.length!==o+1)throw new Error(`indices length must be ${o}`);let I=F[o];if(typeof I!="string")throw new Error("value must be string");let V=F.slice(0,o).map(f).join(",");return o===0?N("0u",I):o===1?N(V[0],I):(m.set=!0,m.setByIndices=!0,m.indicesToOffset=!0,`set_${e}(${V}, ${I})`)},setByOffset:N,setByIndices:(F,I)=>o<2?N(F,I):(m.setByIndices=!0,m.indicesToOffset=!0,`set_${e}ByIndices(${F}, ${I});`),get:Y,getByOffset:J,getByIndices:K,usage:r,name:e,strides:_,shape:C,rank:o}},ke=(e,t,n,r=1)=>du(e,t,n,"input",r),rt=(e,t,n,r=1)=>du(e,t,n,"output",r),SA=(e,t,n)=>du(e,t,n,"atomicOutput",1),Fy=(e,t,n,r=1)=>du(e,t,n,"internal",r),HE=class{constructor(e,t){this.normalizedDispatchGroup=e,this.limits=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${typeof e=="number"?`${e}u`:e}) { return; }`}mainStart(e=vl){let t=typeof e=="number"?e:e[0],n=typeof e=="number"?1:e[1],r=typeof e=="number"?1:e[2];if(t>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||r>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${t}, ${n}, ${r}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(t*n*r>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${t}, ${n}, ${r}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,i=s?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,o=s?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${t*n*r}u + local_idx;`;return`@compute @workgroup_size(${t}, ${n}, ${r})
  fn main(${i}) {
    ${o}
  `}appendVariableUniforms(e){e.rank!==0&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,t){if(e.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let n=e.usage==="input"?"read":"read_write",r=e.usage==="atomicOutput"?"atomic<i32>":e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${r}>;`}declareVariables(...e){return e.map(t=>this.declareVariable(t,this.variableIndex++)).join(`
`)}registerInternalVariable(e){if(e.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach(t=>this.registerInternalVariable(t)),this}registerUniform(e,t,n=1){return this.uniforms.push({name:e,type:t,length:n}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let e=[];for(let{name:t,type:n,length:r}of this.uniforms)if(r&&r>4)n==="f16"?e.push(`@align(16) ${t}:array<mat2x4<${n}>, ${Math.ceil(r/8)}>`):e.push(`${t}:array<vec4<${n}>, ${Math.ceil(r/4)}>`);else{let s=r==null||r===1?n:`vec${r}<${n}>`;e.push(`${t}:${s}`)}return`
      struct Uniforms { ${e.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(e=>e.impl()).join(`
`)+this.internalVariables.map(e=>e.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let e=t=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(t)];return this.uniforms.map(t=>[e(t.type),t.length??1])}},CA=(e,t)=>new HE(e,t)}),KE,Qm,qE,QE,XE,YE,Hr,kA,$A,lo=Ue(()=>{mt(),xt(),wn(),bt(),KE=(e,t)=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.");if(t.length!==0&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},Qm=(e,t)=>t.length!==0?t:[...new Array(e).keys()].reverse(),qE=(e,t)=>Me.sortBasedOnPerm(e,Qm(e.length,t)),QE=(e,t,n,r)=>{let s=`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`;for(let i=0;i<t;++i)s+=`a[${e[i]}]=i[${i}];`;return s+="return a;}"},XE=(e,t)=>{let n=[],r=[];for(let s=0;s<e.length;++s)e[s]!==1&&n.push(e[s]),e[t[s]]!==1&&r.push(t[s]);return{newShape:n,newPerm:r}},YE=(e,t)=>{let n=0;for(let r=0;r<e.length;++r)if(t[e[r]]!==1){if(e[r]<n)return!1;n=e[r]}return!0},Hr=(e,t)=>{let n=e.dataType,r=e.dims.length,s=Qm(r,t),i=qE(e.dims,s),o=e.dims,a=i,l=r<2||YE(s,e.dims),u;if(l)return u=m=>{let y=ke("input",n,o,4),C=rt("output",n,a,4);return`
  ${m.registerUniform("output_size","u32").declareVariables(y,C)}
  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let m=Me.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(m/64/4)},programUniforms:[{type:12,data:Math.ceil(m/4)}]}},getShaderSource:u};let{newShape:p,newPerm:c}=XE(e.dims,s),d=Me.areEqual(c,[2,3,1]),f=Me.areEqual(c,[3,1,2]);if(p.length===2||d||f){o=d?[p[0],p[1]*p[2]]:f?[p[0]*p[1],p[2]]:p,a=[o[1],o[0]];let m=16;return u=y=>{let C=ke("a",n,o.length),_=rt("output",n,a.length);return`
  ${y.registerUniform("output_size","u32").declareVariables(C,_)}
  var<workgroup> tile : array<array<${_.type.value}, ${m+1}>, ${m}>;
  ${y.mainStart([m,m,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${m} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${m}u + local_id.x;
    let input_row = workgroup_id_x * ${m}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${C.getByIndices(`${C.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${m}u + local_id.x;
    let output_row = workgroup_id_y * ${m}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${_.setByIndices(`${_.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let y=Me.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(a[1]/m),y:Math.ceil(a[0]/m)},programUniforms:[{type:12,data:y},...lt(o,a)]}},getShaderSource:u}}return u=m=>{let y=ke("a",n,o.length),C=rt("output",n,a.length);return`
  ${m.registerUniform("output_size","u32").declareVariables(y,C)}

  ${QE(s,r,y,C)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${C.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${C.setByOffset("global_idx",y.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:()=>{let m=Me.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:12,data:m},...lt(o,a)]}},getShaderSource:u}},kA=(e,t)=>{KE(e.inputs,t.perm),e.compute(Hr(e.inputs[0],t.perm))},$A=e=>jt({perm:e.perm})}),JE,ZE,eP,tP,nP,rP,sP,iP,oP,aP,bs,IA,AA,DA,OA,FA,LA,zA,RA,BA,NA,sU=Ue(()=>{mt(),xt(),bt(),Ly(),lo(),JE={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},ZE={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},eP={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},tP={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},nP=(e,t)=>{let n=[];for(let r=t-e;r<t;++r)n.push(r);return n},rP=(e,t)=>{let n=[],r=e.length;for(let i=0;i<r;i++)t.indexOf(i)===-1&&n.push(e[i]);let s=t.map(i=>e[i]);return[n,s]},sP=(e,t)=>{let n=e.length+t.length,r=[],s=0;for(let i=0;i<n;i++)t.indexOf(i)===-1?r.push(e[s++]):r.push(1);return r},iP=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},oP=(e,t)=>{let n=[];if(!iP(e,t)){for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);e.forEach(r=>n.push(r))}return n},aP=(e,t,n,r,s,i,o)=>{let a=n[0].dims,l=Me.size(i),u=Me.size(o),p=ke("_A",n[0].dataType,a),c=rt("output",s,i),d=64;l===1&&(d=256);let f=`
          var<workgroup> aBestValues : array<f32, ${d}>;
       `,m=y=>`
        ${y.registerUniform("reduceSize","u32").declareVariables(p,c)}
        ${f}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${y.mainStart(d)}

          let outputIndex = global_idx / ${d};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${eP[r]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${d}) {
           let candidate = f32(${p.getByOffset("offset + k")});
           bestValue = ${JE[r]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${d}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${ZE[r]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${c.setByOffset("outputIndex",`${r==="mean"?`${c.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${c.type.storage}(${tP[r]})`}`)};
         }
        }`;return{name:e,shaderCache:{hint:`${t};${d}`,inputDependencies:["type"]},getShaderSource:m,getRunData:()=>({outputs:[{dims:i,dataType:s}],dispatchGroup:{x:l},programUniforms:[{type:12,data:u}]})}},bs=(e,t,n,r)=>{let s=e.inputs.length===1?n:Wg(e.inputs,n),i=s.axes;i.length===0&&!s.noopWithEmptyAxes&&(i=e.inputs[0].dims.map((f,m)=>m));let o=Me.normalizeAxes(i,e.inputs[0].dims.length),a=o,l=e.inputs[0],u=oP(a,e.inputs[0].dims.length);u.length>0&&(l=e.compute(Hr(e.inputs[0],u),{inputs:[0],outputs:[-1]})[0],a=nP(a.length,l.dims.length));let[p,c]=rP(l.dims,a),d=p;s.keepDims&&(d=sP(p,o)),e.compute(aP(t,s.cacheKey,[l],r,e.inputs[0].dataType,d,c),{inputs:[l]})},IA=(e,t)=>{bs(e,"ReduceMeanShared",t,"mean")},AA=(e,t)=>{bs(e,"ReduceL1Shared",t,"l1")},DA=(e,t)=>{bs(e,"ReduceL2Shared",t,"l2")},OA=(e,t)=>{bs(e,"ReduceLogSumExpShared",t,"logSumExp")},FA=(e,t)=>{bs(e,"ReduceMaxShared",t,"max")},LA=(e,t)=>{bs(e,"ReduceMinShared",t,"min")},zA=(e,t)=>{bs(e,"ReduceProdShared",t,"prod")},RA=(e,t)=>{bs(e,"ReduceSumShared",t,"sum")},BA=(e,t)=>{bs(e,"ReduceSumSquareShared",t,"sumSquare")},NA=(e,t)=>{bs(e,"ReduceLogSumShared",t,"logSum")}}),Ts,lP,of,Wg,Es,uP,cP,dP,pP,fP,hP,mP,_P,gP,yP,Ps,jA,VA,UA,WA,GA,HA,KA,qA,QA,XA,Ly=Ue(()=>{mt(),xt(),wn(),bt(),sU(),Ts=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},lP=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],of=(e,t,n,r,s,i,o=!1,a=!1)=>{let l=[],u=n[0].dims,p=u.length,c=Me.normalizeAxes(s,p),d=!a&&c.length===0;u.forEach((y,C)=>{d||c.indexOf(C)>=0?o&&l.push(1):l.push(y)});let f=l.length,m=Me.size(l);return{name:e,shaderCache:t,getShaderSource:y=>{let C=[],_=ke("_A",n[0].dataType,p),h=rt("output",i,f),w=r(_,h,c),M=w[2];for(let x=0,b=0;x<p;x++)d||c.indexOf(x)>=0?(o&&b++,M=`for(var j${x}: u32 = 0; j${x} < ${u[x]}; j${x}++) {
                  ${w[2].includes("last_index")?`let last_index = j${x};`:""}
                  ${_.indicesSet("input_indices",x,`j${x}`)}
                  ${M}
                }`):(C.push(`${_.indicesSet("input_indices",x,h.indicesGet("output_indices",b))};`),b++);return`

        ${y.registerUniform("output_size","u32").declareVariables(_,h)}

        ${y.mainStart()}
          ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${_.type.indices};
          let output_indices = ${h.offsetToIndices("global_idx")};

          ${C.join(`
`)}
          ${w[0]}       // init ops for reduce max/min
          ${w[1]}
          ${M}
          ${w[3]}
          ${w.length===4?h.setByOffset("global_idx","value"):w.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:l,dataType:i}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:12,data:m},...lt(u,l)]})}},Wg=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(r=>n.push(Number(r))),jt({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},Es=(e,t,n,r)=>{let s=e.inputs,i=s.length===1?n:Wg(s,n);e.compute(of(t,{hint:i.cacheKey,inputDependencies:["rank"]},[s[0]],i.noopWithEmptyAxes&&i.axes.length===0?lP:r,i.axes,s[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},uP=(e,t)=>{Ts(e.inputs),Es(e,"ReduceLogSum",t,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,"value = log(value);"])},cP=(e,t)=>{Ts(e.inputs),Es(e,"ReduceL1",t,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += abs(${n.getByIndices("input_indices")});`,""])},dP=(e,t)=>{Ts(e.inputs),Es(e,"ReduceL2",t,(n,r)=>[`var t = ${r.type.value}(0); var value = ${r.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},pP=(e,t)=>{Ts(e.inputs),Es(e,"ReduceLogSumExp",t,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += exp(${n.getByIndices("input_indices")});`,"value = log(value);"])},fP=(e,t)=>{Ts(e.inputs),Es(e,"ReduceMax",t,(n,r,s)=>{let i=[];for(let o=0;o<n.rank;o++)(s.indexOf(o)>=0||s.length===0)&&i.push(n.indicesSet("input_indices",o,0));return[`${i.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = max(value, ${n.getByIndices("input_indices")});`,""]})},hP=(e,t)=>{Ts(e.inputs),Es(e,"ReduceMean",t,(n,r,s)=>{let i=1;for(let o=0;o<n.rank;o++)(s.indexOf(o)>=0||s.length===0)&&(i*=e.inputs[0].dims[o]);return["var sum = f32(0);","",`sum += f32(${n.getByIndices("input_indices")});`,`let value = ${r.type.value}(sum / ${i});`]})},mP=(e,t)=>{Ts(e.inputs),Es(e,"ReduceMin",t,(n,r,s)=>{let i=[];for(let o=0;o<n.rank;o++)(s.indexOf(o)>=0||s.length===0)&&i.push(`input_indices[${o}] = 0;`);return[`${i.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = min(value, ${n.getByIndices("input_indices")});`,""]})},_P=(e,t)=>{Ts(e.inputs),Es(e,"ReduceProd",t,(n,r)=>[`var value = ${r.type.storage}(1);`,"",`value *= ${n.getByIndices("input_indices")};`,""])},gP=(e,t)=>{Ts(e.inputs),Es(e,"ReduceSum",t,(n,r)=>[`var value = ${r.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,""])},yP=(e,t)=>{Ts(e.inputs),Es(e,"ReduceSumSquare",t,(n,r)=>[`var t = ${r.type.value}(0); var value = ${r.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += t * t;`,""])},Ps=(e,t,n)=>{if(t.length===0)return n;let r=1,s=1;for(let i=0;i<t.length;i++)t.indexOf(i)===-1?r*=e[i]:s*=e[i];return s<32&&r>1024},jA=(e,t)=>{Ps(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?hP(e,t):IA(e,t)},VA=(e,t)=>{Ps(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?cP(e,t):AA(e,t)},UA=(e,t)=>{Ps(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?dP(e,t):DA(e,t)},WA=(e,t)=>{Ps(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?pP(e,t):OA(e,t)},GA=(e,t)=>{Ps(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?fP(e,t):FA(e,t)},HA=(e,t)=>{Ps(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?mP(e,t):LA(e,t)},KA=(e,t)=>{Ps(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?_P(e,t):zA(e,t)},qA=(e,t)=>{Ps(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?gP(e,t):RA(e,t)},QA=(e,t)=>{Ps(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?yP(e,t):BA(e,t)},XA=(e,t)=>{Ps(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?uP(e,t):NA(e,t)}}),Xm,YA,JA,Gg,iU=Ue(()=>{mt(),wn(),Ly(),Xm=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},YA=(e,t)=>{Xm(e.inputs);let n=(r,s,i)=>{let o=[];for(let a=0;a<r.rank;a++)(i.indexOf(a)>=0||i.length===0)&&o.push(`input_indices[${a}] = 0;`);return[`${o.join(`
`)}`,`var value = ${r.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${r.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {
         value = ${r.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",s.setByOffset("global_idx","best_index")]};e.compute(of("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},JA=(e,t)=>{Xm(e.inputs);let n=(r,s,i)=>{let o=[];for(let a=0;a<r.rank;a++)(i.indexOf(a)>=0||i.length===0)&&o.push(`input_indices[${a}] = 0;`);return[`${o.join(`
`)}`,`var value = ${r.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${r.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {
         value = ${r.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",s.setByOffset("global_idx","best_index")]};e.compute(of("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},Gg=e=>jt(e)}),vP,Kd,wP,MP,xP,dc,bP,ZA,zy=Ue(()=>{mt(),xt(),Oy(),bt(),vP=(e,t)=>{let n=e[0],r=e[1],s=e[2],i=e[3],o=e[4],a=e[5];if(o&&a)throw new Error("Attention cannot have both past and attention_bias");if(n.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let l=n.dims[0],u=n.dims[1],p=n.dims[2];if(s.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(r.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(r.dims[0]!==p)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(s.dims[0]!==r.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let c=s.dims[0]/3,d=c,f=d;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let w of t.qkvHiddenSizes)if(w%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");c=t.qkvHiddenSizes[0],d=t.qkvHiddenSizes[1],f=t.qkvHiddenSizes[2]}let m=u;if(c!==d)throw new Error("qkv_hidden_sizes first element should be same as the second");if(s.dims[0]!==c+d+f)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let y=0;if(o){if(d!==f)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(o.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(o.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(o.dims[1]!==l)throw new Error('Input "past" second dimension must be batch_size');if(o.dims[2]!==t.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(o.dims[4]!==d/t.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(y=o.dims[3])}let C=m+y,_=-1,h=0;if(i)throw new Error("Mask not supported");if(o)throw new Error("past is not supported");if(a){if(a.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(a.dims[0]!==l||a.dims[1]!==t.numHeads||a.dims[2]!==u||a.dims[3]!==C)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:l,sequenceLength:u,pastSequenceLength:y,kvSequenceLength:m,totalSequenceLength:C,maxSequenceLength:_,inputHiddenSize:p,hiddenSize:c,vHiddenSize:f,headSize:Math.floor(c/t.numHeads),vHeadSize:Math.floor(f/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:h,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Kd=(e,t,n)=>t&&e?`
      let total_sequence_length_input = u32(${t.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${e==null?void 0:e.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,wP=(e,t,n,r,s,i,o,a)=>{let l=pn(o?1:i),u=64,p=i/l;p<u&&(u=32);let c=Math.ceil(i/l/u),d=[{type:12,data:t},{type:12,data:n},{type:12,data:r},{type:12,data:s},{type:12,data:p},{type:12,data:c}],f=Kn(e.dataType,l),m=fr(1,l),y=["type"];o&&y.push("type"),a&&y.push("type");let C=_=>{let h=rt("x",e.dataType,e.dims,l),w=[h],M=o?ke("seq_lens",o.dataType,o.dims):void 0;M&&w.push(M);let x=a?ke("total_sequence_length_input",a.dataType,a.dims):void 0;x&&w.push(x);let b=fr(e.dataType),T=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${u}>;
  var<workgroup> thread_sum: array<f32, ${u}>;
  ${_.registerUniforms(T).declareVariables(...w)}
  ${_.mainStart([u,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${Kd(M,x,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${u}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${o?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${m}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${m}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(l){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${l}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${u}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${m}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${m}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${l}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${u}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${h.type.value}(${b}(1.0) / ${b}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${m}(x[offset + i]);
        x[offset + i] = ${h.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${o?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${h.type.value}(${b}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${u};${f};${l}`,inputDependencies:y},getShaderSource:C,getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:s,z:t*n},programUniforms:d})}},MP=(e,t,n,r,s,i,o,a,l)=>{let u=o+i.kvSequenceLength,p=[i.batchSize,i.numHeads,i.sequenceLength,u],c=e>1&&r,d=i.kvNumHeads?i.kvNumHeads:i.numHeads,f=c?[i.batchSize,d,u,i.headSize]:void 0,m=i.nReps?i.nReps:1,y=i.scale===0?1/Math.sqrt(i.headSize):i.scale,C=pn(i.headSize),_=i.headSize/C,h=12,w={x:Math.ceil(u/h),y:Math.ceil(i.sequenceLength/h),z:i.batchSize*i.numHeads},M=[{type:12,data:i.sequenceLength},{type:12,data:_},{type:12,data:u},{type:12,data:i.numHeads},{type:12,data:i.headSize},{type:1,data:y},{type:12,data:o},{type:12,data:i.kvSequenceLength},{type:12,data:m}],x=c&&r&&Me.size(r.dims)>0,b=["type","type"];x&&b.push("type"),s&&b.push("type"),a&&b.push("type"),l&&b.push("type");let T=[{dims:p,dataType:t.dataType,gpuDataType:0}];c&&T.push({dims:f,dataType:t.dataType,gpuDataType:0});let S=$=>{let O=ke("q",t.dataType,t.dims,C),G=ke("key",n.dataType,n.dims,C),H=[O,G];if(x){let oe=ke("past_key",r.dataType,r.dims,C);H.push(oe)}s&&H.push(ke("attention_bias",s.dataType,s.dims));let N=a?ke("seq_lens",a.dataType,a.dims):void 0;N&&H.push(N);let J=l?ke("total_sequence_length_input",l.dataType,l.dims):void 0;J&&H.push(J);let q=rt("output",t.dataType,p),X=[q];c&&X.push(rt("present_key",t.dataType,f,C));let Y=fr(1,C),K=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${h}u;

  var<workgroup> tileQ: array<${O.type.storage}, ${h*h}>;
  var<workgroup> tileK: array<${O.type.storage}, ${h*h}>;
  ${$.registerUniforms(K).declareVariables(...H,...X)}
  ${$.mainStart([h,h,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${m===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${m===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${Kd(N,J,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${x&&c?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${c?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${Y}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${x&&c?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${c?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${Y}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(C){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${C}`)}})()};
        output[outputIdx] = ${q.type.value} (sum * uniforms.alpha) + ${s?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${C};${s!==void 0};${r!==void 0};${e}`,inputDependencies:b},getRunData:()=>({outputs:T,dispatchGroup:w,programUniforms:M}),getShaderSource:S}},xP=(e,t,n,r,s,i,o=void 0,a=void 0)=>{let l=i+s.kvSequenceLength,u=s.nReps?s.nReps:1,p=s.vHiddenSize*u,c=e>1&&r,d=s.kvNumHeads?s.kvNumHeads:s.numHeads,f=c?[s.batchSize,d,l,s.headSize]:void 0,m=[s.batchSize,s.sequenceLength,p],y=12,C={x:Math.ceil(s.vHeadSize/y),y:Math.ceil(s.sequenceLength/y),z:s.batchSize*s.numHeads},_=[{type:12,data:s.sequenceLength},{type:12,data:l},{type:12,data:s.vHeadSize},{type:12,data:s.numHeads},{type:12,data:s.headSize},{type:12,data:p},{type:12,data:i},{type:12,data:s.kvSequenceLength},{type:12,data:u}],h=c&&r&&Me.size(r.dims)>0,w=["type","type"];h&&w.push("type"),o&&w.push("type"),a&&w.push("type");let M=[{dims:m,dataType:t.dataType,gpuDataType:0}];c&&M.push({dims:f,dataType:t.dataType,gpuDataType:0});let x=b=>{let T=ke("probs",t.dataType,t.dims),S=ke("v",n.dataType,n.dims),$=[T,S];h&&$.push(ke("past_value",r.dataType,r.dims));let O=o?ke("seq_lens",o.dataType,o.dims):void 0;o&&$.push(O);let G=a?ke("total_sequence_length_input",a.dataType,a.dims):void 0;a&&$.push(G);let H=[rt("output",t.dataType,m)];c&&H.push(rt("present_value",t.dataType,f));let N=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${y}u;
  var<workgroup> tileQ: array<${T.type.value}, ${y*y}>;
  var<workgroup> tileV: array<${T.type.value}, ${y*y}>;
  ${b.registerUniforms(N).declareVariables(...$,...H)}
  ${b.mainStart([y,y,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${u===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${u===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${Kd(O,G,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${h&&c?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${c?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${T.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${h&&c?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${c?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${r!==void 0};${e}`,inputDependencies:w},getRunData:()=>({outputs:M,dispatchGroup:C,programUniforms:_}),getShaderSource:x}},dc=(e,t,n,r,s,i,o,a,l,u,p=void 0,c=void 0)=>{let d=Math.min(e.outputCount,1+(o?1:0)+(a?1:0)),f=d>1?u.pastSequenceLength:0,m=f+u.kvSequenceLength,y=l&&Me.size(l.dims)>0?l:void 0,C=[t,n];d>1&&o&&Me.size(o.dims)>0&&C.push(o),y&&C.push(y),p&&C.push(p),c&&C.push(c);let _=e.compute(MP(d,t,n,o,y,u,f,p,c),{inputs:C,outputs:d>1?[-1,1]:[-1]})[0];e.compute(wP(_,u.batchSize,u.numHeads,f,u.sequenceLength,m,p,c),{inputs:p&&c?[_,p,c]:[_],outputs:[]});let h=[_,r];d>1&&a&&Me.size(a.dims)>0&&h.push(a),p&&h.push(p),c&&h.push(c),e.compute(xP(d,_,r,a,u,f,p,c),{inputs:h,outputs:d>1?[0,2]:[0]})},bP=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],r=t.sequenceLength,s=t.inputHiddenSize,i=t.headSize,o=12,a={x:Math.ceil(t.headSize/o),y:Math.ceil(t.sequenceLength/o),z:t.batchSize*t.numHeads},l=[e.inputs[0],e.inputs[1],e.inputs[2]],u=[{type:12,data:r},{type:12,data:s},{type:12,data:i},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],p=c=>{let d=rt("output_q",l[0].dataType,n),f=rt("output_k",l[0].dataType,n),m=rt("output_v",l[0].dataType,n),y=ke("input",l[0].dataType,l[0].dims),C=ke("weight",l[1].dataType,l[1].dims),_=ke("bias",l[2].dataType,l[2].dims),h=y.type.storage,w=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${o}u;
  var<workgroup> tileInput: array<${h}, ${o*o}>;
  var<workgroup> tileWeightQ: array<${h}, ${o*o}>;
  var<workgroup> tileWeightK: array<${h}, ${o*o}>;
  var<workgroup> tileWeightV: array<${h}, ${o*o}>;
  ${c.registerUniforms(w).declareVariables(y,C,_,d,f,m)}
  ${c.mainStart([o,o,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${h}(0);
    var valueK = ${h}(0);
    var valueV = ${h}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:a,programUniforms:u}),getShaderSource:p},{inputs:l,outputs:[-1,-1,-1]})},ZA=(e,t)=>{let n=vP(e.inputs,t),[r,s,i]=bP(e,n);return dc(e,r,s,i,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n)}}),TP,EP,PP,eD,oU=Ue(()=>{Rs(),mt(),xt(),wn(),bt(),TP=(e,t)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let n=(r,s,i)=>{let o=s.length;if(o!==r.length)throw new Error(`${i}: num dimensions != ${o}`);s.forEach((a,l)=>{if(a!==r[l])throw new Error(`${i}: dim[${l}] do not match`)})};if(e[0].dims.length>1){let r=t.format==="NHWC"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,r,"Invalid input scale"),n(e[2].dims,r,"Invalid input B"),n(e[3].dims,r,"Invalid input mean"),n(e[4].dims,r,"Invalid input var")}else n(e[1].dims,[1],"Invalid input scale"),n(e[2].dims,[1],"Invalid input B"),n(e[3].dims,[1],"Invalid input mean"),n(e[4].dims,[1],"Invalid input var")},EP=(e,t)=>{let{epsilon:n,spatial:r,format:s}=t,i=e[0].dims,o=r?pn(i[i.length-1]):1,a=s==="NHWC"&&i.length>1?o:1,l=Me.size(i)/o,u=r,p=u?i.length:i,c=ke("x",e[0].dataType,e[0].dims,o),d=ke("scale",e[1].dataType,e[1].dims,a),f=ke("bias",e[2].dataType,e[2].dims,a),m=ke("inputMean",e[3].dataType,e[3].dims,a),y=ke("inputVar",e[4].dataType,e[4].dims,a),C=rt("y",e[0].dataType,p,o),_=()=>{let w="";if(r)w=`let cOffset = ${i.length===1?"0u":s==="NHWC"?`outputIndices[${i.length-1}] / ${o}`:"outputIndices[1]"};`;else if(s==="NCHW")w=`
            ${C.indicesSet("outputIndices","0","0")}
            let cOffset = ${C.indicesToOffset("outputIndices")};`;else{w=`var cIndices = ${d.type.indices}(0);
                       cIndices[0] = outputIndices[${i.length-1}];`;for(let M=1;M<d.rank;M++)w+=`cIndices[${M}] = outputIndices[${M}];`;w+=`let cOffset = ${d.indicesToOffset("cIndices")};`}return w},h=w=>`
  const epsilon = ${n};
  ${w.registerUniform("outputSize","u32").declareVariables(c,d,f,m,y,C)}
  ${w.mainStart()}
  ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${C.offsetToIndices(`global_idx * ${o}`)};
    ${_()}
    let scale = ${d.getByOffset("cOffset")};
    let bias = ${f.getByOffset("cOffset")};
    let inputMean = ${m.getByOffset("cOffset")};
    let inputVar = ${y.getByOffset("cOffset")};
    let x = ${c.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${C.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${r}_${o}`,inputDependencies:u?["rank","type","type","type","type"]:void 0},getShaderSource:h,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u?[{type:12,data:l},...lt(i)]:[{type:12,data:l}]})}},PP=e=>jt(e),eD=(e,t)=>{let{inputs:n,outputCount:r}=e,s=PP({...t,outputCount:r});if(Zt.webgpu.validateInputContent&&TP(n,s),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(EP(n,s))}}),SP,CP,tD,aU=Ue(()=>{xt(),bt(),SP=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},CP=e=>{let t=e[0].dims,n=e[0].dims[2],r=Me.size(t)/4,s=e[0].dataType,i=ke("input",s,t,4),o=ke("bias",s,[n],4),a=ke("residual",s,t,4),l=rt("output",s,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:u=>`
  const channels = ${n}u / 4;
  ${u.declareVariables(i,o,a,l)}

  ${u.mainStart()}
    ${u.guardAgainstOutOfBoundsWorkgroupSizes(r)}
    let value = ${i.getByOffset("global_idx")}
      + ${o.getByOffset("global_idx % channels")} + ${a.getByOffset("global_idx")};
    ${l.setByOffset("global_idx","value")}
  }`}},tD=e=>{SP(e.inputs),e.compute(CP(e.inputs))}}),kP,Rt,nD,rD,sD,iD,oD,aD,lD,uD,cD,$P,dD,pD,fD,hD,Eu,mD,vp,_D,gD,yD,vD,wD,MD,xD,bD,TD,ED,PD,SD,CD,kD,$D,ID,Ym,AD,Hg,Kg,DD,OD,FD,IP,AP,LD,Ry=Ue(()=>{mt(),xt(),wn(),bt(),kP=(e,t,n,r,s,i,o)=>{let a=Math.ceil(t/4),l="";typeof s=="string"?l=`${s}(a)`:l=s("a");let u=ke("inputData",n,[a],4),p=rt("outputData",r,[a],4),c=[{name:"vec_size",type:"u32"}];return o&&c.push(...o),`
      ${e.registerUniforms(c).declareVariables(u,p)}

  ${i??""}

  ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${u.getByOffset("global_idx")};
    ${p.setByOffset("global_idx",l)}
  }`},Rt=(e,t,n,r,s,i=e.dataType,o,a)=>{let l=[{type:12,data:Math.ceil(Me.size(e.dims)/4)}];return o&&l.push(...o),{name:t,shaderCache:{hint:s,inputDependencies:["type"]},getShaderSource:u=>kP(u,Me.size(e.dims),e.dataType,i,n,r,a),getRunData:u=>({outputs:[{dims:e.dims,dataType:i}],dispatchGroup:{x:Math.ceil(Me.size(u[0].dims)/64/4)},programUniforms:l})}},nD=e=>{e.compute(Rt(e.inputs[0],"Abs","abs"))},rD=e=>{e.compute(Rt(e.inputs[0],"Acos","acos"))},sD=e=>{e.compute(Rt(e.inputs[0],"Acosh","acosh"))},iD=e=>{e.compute(Rt(e.inputs[0],"Asin","asin"))},oD=e=>{e.compute(Rt(e.inputs[0],"Asinh","asinh"))},aD=e=>{e.compute(Rt(e.inputs[0],"Atan","atan"))},lD=e=>{e.compute(Rt(e.inputs[0],"Atanh","atanh"))},uD=e=>jt(e),cD=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(Rt(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},$P=e=>{let t,n,r=e.length>=2&&e[1].data!==0,s=e.length>=3&&e[2].data!==0;switch(e[0].dataType){case 1:t=r?e[1].getFloat32Array()[0]:-34028234663852886e22,n=s?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=r?e[1].getUint16Array()[0]:64511,n=s?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return jt({min:t,max:n})},dD=(e,t)=>{let n=t||$P(e.inputs),r=fr(e.inputs[0].dataType);e.compute(Rt(e.inputs[0],"Clip",s=>`clamp(${s}, vec4<${r}>(uniforms.min), vec4<${r}>(uniforms.max))`,void 0,n.cacheKey,void 0,[{type:e.inputs[0].dataType,data:n.min},{type:e.inputs[0].dataType,data:n.max}],[{name:"min",type:r},{name:"max",type:r}]),{inputs:[0]})},pD=e=>{e.compute(Rt(e.inputs[0],"Ceil","ceil"))},fD=e=>{e.compute(Rt(e.inputs[0],"Cos","cos"))},hD=e=>{e.compute(Rt(e.inputs[0],"Cosh","cosh"))},Eu=e=>jt(e),mD=(e,t)=>{let n=fr(e.inputs[0].dataType);e.compute(Rt(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`
  const elu_alpha_ = ${n}(${t.alpha});

  fn elu_f32(a: ${n}) -> ${n} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,t.cacheKey))},vp=(e="f32")=>`
const r0: ${e} = 0.3275911;
const r1: ${e} = 0.254829592;
const r2: ${e} = -0.284496736;
const r3: ${e} = 1.421413741;
const r4: ${e} = -1.453152027;
const r5: ${e} = 1.061405429;

fn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,_D=e=>{let t=fr(e.inputs[0].dataType);e.compute(Rt(e.inputs[0],"Erf",n=>`erf_vf32(${n})`,vp(t)))},gD=e=>{e.compute(Rt(e.inputs[0],"Exp","exp"))},yD=e=>{e.compute(Rt(e.inputs[0],"Floor","floor"))},vD=e=>{let t=fr(e.inputs[0].dataType);e.compute(Rt(e.inputs[0],"Gelu",n=>`0.5 * ${n} * (1.0 + erf_vf32(${n} * 0.7071067811865475))`,vp(t)))},wD=(e,t)=>{let n=fr(e.inputs[0].dataType);e.compute(Rt(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},MD=e=>{e.compute(Rt(e.inputs[0],"Not",t=>`!${t}`))},xD=e=>{e.compute(Rt(e.inputs[0],"Neg",t=>`-${t}`))},bD=e=>{e.compute(Rt(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},TD=e=>{let t=fr(e.inputs[0].dataType);e.compute(Rt(e.inputs[0],"Relu",n=>`select(vec4<${t}>(0.0), ${n}, ${n} > vec4<${t}>(0.0))`))},ED=e=>{e.compute(Rt(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},PD=e=>jt(e),SD=(e,t)=>{let n=fr(e.inputs[0].dataType);e.compute(Rt(e.inputs[0],"HardSigmoid",r=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${r} + vec4<${n}>(${t.beta})))`,void 0,t.cacheKey))},CD=e=>{e.compute(Rt(e.inputs[0],"Sin","sin"))},kD=e=>{e.compute(Rt(e.inputs[0],"Sinh","sinh"))},$D=e=>{e.compute(Rt(e.inputs[0],"Sqrt","sqrt"))},ID=e=>{e.compute(Rt(e.inputs[0],"Tan","tan"))},Ym=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,AD=e=>{e.compute(Rt(e.inputs[0],"Tanh",Ym))},Hg=(e="f32")=>`
const fast_gelu_a: ${e} = 0.5;
const fast_gelu_b: ${e} = 0.7978845608028654;
const fast_gelu_c: ${e} = 0.035677408136300125;

fn tanh_v(v: vec4<${e}>) -> vec4<${e}> {
  return ${Ym("v")};
}
`,Kg=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,DD=e=>{let t=fr(e.inputs[0].dataType);e.compute(Rt(e.inputs[0],"FastGelu",Kg,Hg(t),void 0,e.inputs[0].dataType))},OD=(e,t)=>{let n=fr(e.inputs[0].dataType);return e.compute(Rt(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<${n}>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},FD=e=>{e.compute(Rt(e.inputs[0],"Log","log"))},IP=(e,t)=>`
const alpha = vec4<${e}>(${t});
const one = ${e}(1.0);
const zero = ${e}(0.0);

fn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {
  let v = x *alpha;
  var x1 : vec4<${e}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,AP=e=>`quick_gelu_impl(${e})`,LD=(e,t)=>{let n=fr(e.inputs[0].dataType);e.compute(Rt(e.inputs[0],"QuickGelu",AP,IP(n,t.alpha),t.cacheKey,e.inputs[0].dataType))}}),DP,OP,zD,lU=Ue(()=>{xt(),bt(),Ry(),DP=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},OP=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=ke("input",e[0].dataType,e[0].dims,4),r=ke("bias",e[0].dataType,[e[0].dims[2]],4),s=rt("output",e[0].dataType,t,4),i=Me.size(t)/4,o=Kn(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:a=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${e[0].dims[2]/4/2}u;

  ${a.declareVariables(n,r,s)}

  ${vp(o)}

  ${a.mainStart()}
    ${a.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${s.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},zD=e=>{DP(e.inputs),e.compute(OP(e.inputs))}}),FP,LP,Ss,RD,BD,ND,jD,VD,UD,WD,GD,HD,KD,uU=Ue(()=>{mt(),xt(),bt(),FP=(e,t,n,r,s,i,o,a,l,u,p,c)=>{let d,f;typeof a=="string"?d=f=(h,w)=>`${a}((${h}),(${w}))`:typeof a=="function"?d=f=a:(d=a.scalar,f=a.vector);let m=rt("outputData",p,r.length,4),y=ke("aData",l,t.length,4),C=ke("bData",u,n.length,4),_;if(s)if(i){let h=Me.size(t)===1,w=Me.size(n)===1,M=t.length>0&&t[t.length-1]%4===0,x=n.length>0&&n[n.length-1]%4===0;h||w?_=m.setByOffset("global_idx",f(h?`${y.type.value}(${y.getByOffset("0")}.x)`:y.getByOffset("global_idx"),w?`${C.type.value}(${C.getByOffset("0")}.x)`:C.getByOffset("global_idx"))):_=`
            let outputIndices = ${m.offsetToIndices("global_idx * 4u")};
            let offsetA = ${y.broadcastedIndicesToOffset("outputIndices",m)};
            let offsetB = ${C.broadcastedIndicesToOffset("outputIndices",m)};
            ${m.setByOffset("global_idx",f(o||M?y.getByOffset("offsetA / 4u"):`${y.type.value}(${y.getByOffset("offsetA / 4u")}[offsetA % 4u])`,o||x?C.getByOffset("offsetB / 4u"):`${C.type.value}(${C.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else _=m.setByOffset("global_idx",f(y.getByOffset("global_idx"),C.getByOffset("global_idx")));else{if(!i)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let h=(w,M,x="")=>{let b=`aData[indexA${M}][componentA${M}]`,T=`bData[indexB${M}][componentB${M}]`;return`
            let outputIndices${M} = ${m.offsetToIndices(`global_idx * 4u + ${M}u`)};
            let offsetA${M} = ${y.broadcastedIndicesToOffset(`outputIndices${M}`,m)};
            let offsetB${M} = ${C.broadcastedIndicesToOffset(`outputIndices${M}`,m)};
            let indexA${M} = offsetA${M} / 4u;
            let indexB${M} = offsetB${M} / 4u;
            let componentA${M} = offsetA${M} % 4u;
            let componentB${M} = offsetB${M} % 4u;
            ${w}[${M}] = ${x}(${d(b,T)});
          `};p===9?_=`
            var data = vec4<u32>(0);
            ${h("data",0,"u32")}
            ${h("data",1,"u32")}
            ${h("data",2,"u32")}
            ${h("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:_=`
            ${h("outputData[global_idx]",0)}
            ${h("outputData[global_idx]",1)}
            ${h("outputData[global_idx]",2)}
            ${h("outputData[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(y,C,m)}

        ${c??""}

        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${_}
      }`},LP=(e,t,n,r,s,i,o=n.dataType)=>{let a=n.dims.map(y=>Number(y)??1),l=r.dims.map(y=>Number(y)??1),u=!Me.areEqual(a,l),p=a,c=Me.size(a),d=!1,f=!1,m=[u];if(u){let y=yl.calcShape(a,l,!1);if(!y)throw new Error("Can't perform binary op on the given tensors");p=y.slice(),c=Me.size(p);let C=Me.size(a)===1,_=Me.size(l)===1,h=a.length>0&&a[a.length-1]%4===0,w=l.length>0&&l[l.length-1]%4===0;m.push(C),m.push(_),m.push(h),m.push(w);let M=1;for(let x=1;x<p.length;x++){let b=a[a.length-x],T=l[l.length-x];if(b===T)M*=b;else break}M%4===0?(f=!0,d=!0):(C||_||h||w)&&(d=!0)}else d=!0;return m.push(d),{name:e,shaderCache:{hint:t+m.map(y=>y.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:y=>FP(y,a,l,p,d,u,f,s,n.dataType,r.dataType,o,i),getRunData:()=>({outputs:[{dims:p,dataType:o}],dispatchGroup:{x:Math.ceil(c/64/4)},programUniforms:[{type:12,data:Math.ceil(Me.size(p)/4)},...lt(a,l,p)]})}},Ss=(e,t,n,r,s,i)=>{e.compute(LP(t,s??"",e.inputs[0],e.inputs[1],n,r,i))},RD=e=>{Ss(e,"Add",(t,n)=>`${t}+${n}`)},BD=e=>{Ss(e,"Div",(t,n)=>`${t}/${n}`)},ND=e=>{Ss(e,"Equal",{scalar:(t,n)=>`u32(${t}==${n})`,vector:(t,n)=>`vec4<u32>(${t}==${n})`},void 0,void 0,9)},jD=e=>{Ss(e,"Mul",(t,n)=>`${t}*${n}`)},VD=e=>{let t=ke("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;Ss(e,"Pow",{scalar:(n,r)=>`pow_custom(${n},${r})`,vector:(n,r)=>`pow_vector_custom(${n},${r})`},`
    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {
      if (b == ${t}(0.0)) {
        return ${t}(1.0);
      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {
        return ${t}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {
      // TODO: implement vectorized pow
      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},UD=e=>{Ss(e,"Sub",(t,n)=>`${t}-${n}`)},WD=e=>{Ss(e,"Greater",{scalar:(t,n)=>`u32(${t}>${n})`,vector:(t,n)=>`vec4<u32>(${t}>${n})`},void 0,void 0,9)},GD=e=>{Ss(e,"Less",{scalar:(t,n)=>`u32(${t}<${n})`,vector:(t,n)=>`vec4<u32>(${t}<${n})`},void 0,void 0,9)},HD=e=>{Ss(e,"GreaterOrEqual",{scalar:(t,n)=>`u32(${t}>=${n})`,vector:(t,n)=>`vec4<u32>(${t}>=${n})`},void 0,void 0,9)},KD=e=>{Ss(e,"LessOrEqual",{scalar:(t,n)=>`u32(${t}<=${n})`,vector:(t,n)=>`vec4<u32>(${t}<=${n})`},void 0,void 0,9)}}),zP,RP,BP,NP,qD,QD,cU=Ue(()=>{mt(),xt(),wn(),bt(),zP=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let n=0,r=e[n],s=r.dataType,i=r.dims.length;e.forEach((o,a)=>{if(a!==n){if(o.dataType!==s)throw new Error("input tensors should be one type");if(o.dims.length!==i)throw new Error("input tensors should have the same shape");o.dims.forEach((l,u)=>{if(u!==t&&l!==r.dims[u])throw new Error("non concat dimensions must match")})}})},RP=(e,t)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${e}u>(${t});
    for (var i: u32 = 0u; i < ${e}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${e}u;
  }`,BP=(e,t)=>{let n=e.length,r=[];for(let s=0;s<n;++s){let i=t.setByOffset("global_idx",e[s].getByIndices("indices"));n===1?r.push(i):s===0?r.push(`if (inputIndex == ${s}u) { ${i} }`):s===n-1?r.push(`else { ${i} }`):r.push(`else if (inputIndex == ${s}) { ${i} }`)}return r.join(`
`)},NP=(e,t,n,r)=>{let s=Me.size(n),i=new Array(e.length),o=new Array(e.length),a=0,l=[],u=[],p=[{type:12,data:s}];for(let y=0;y<e.length;++y)a+=e[y].dims[t],i[y]=a,u.push(e[y].dims.length),o[y]=ke(`input${y}`,r,u[y]),l.push("rank"),p.push({type:12,data:i[y]});for(let y=0;y<e.length;++y)p.push(...lt(e[y].dims));p.push(...lt(n));let c=rt("output",r,n.length),d=c.indicesGet("indices",t),f=Array.from(Array(i.length).keys()).map(y=>`uniforms.sizeInConcatAxis${y}`).join(","),m=y=>`

  ${(()=>{y.registerUniform("outputSize","u32");for(let C=0;C<e.length;C++)y.registerUniform(`sizeInConcatAxis${C}`,"u32");return y.declareVariables(...o,c)})()}

  ${RP(i.length,f)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${c.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${d});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${i.length}u>(${f});
      ${d} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${BP(o,c)}
  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:p}),getShaderSource:m}},qD=(e,t)=>{let n=e.inputs,r=n[0].dims,s=Me.normalizeAxis(t.axis,r.length);zP(n,s);let i=r.slice();i[s]=n.reduce((a,l)=>a+(l.dims.length>s?l.dims[s]:0),0);let o=n.filter(a=>Me.size(a.dims)>0);e.compute(NP(o,s,i,n[0].dataType),{inputs:o})},QD=e=>jt({axis:e.axis})}),la,ua,ca,By,ya=Ue(()=>{mt(),xt(),la=(e,t,n="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${n}(uniforms.clip_min)), ${t}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},ua=(e,t)=>{e.activation==="Clip"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation==="HardSigmoid"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation==="LeakyRelu"&&t.push({type:1,data:e.alpha})},ca=(e,t)=>{e.activation==="Clip"?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):e.activation==="HardSigmoid"?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):e.activation==="LeakyRelu"&&t.push({name:"alpha",type:"f32"})},By=e=>{let t=(e==null?void 0:e.activation)||"";if(t==="HardSigmoid"){let[n,r]=(e==null?void 0:e.activation_params)||[.2,.5];return{activation:t,alpha:n,beta:r}}else if(t==="Clip"){let[n,r]=(e==null?void 0:e.activation_params)||[MA,xA];return{activation:t,clipMax:r,clipMin:n}}else if(t==="LeakyRelu"){let[n]=(e==null?void 0:e.activation_params)||[.01];return{activation:t,alpha:n}}return{activation:t}}}),Jn,XD,Ny=Ue(()=>{Jn=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},XD=e=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      `}),YD,dU=Ue(()=>{YD=e=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));
}
`}),Nu,jy,Vy=Ue(()=>{mt(),xt(),bt(),ya(),Nu=(e,t,n,r,s)=>{let i=r-n;return`
      ${Array.from({length:n}).map((o,a)=>`
      if (${at(t.shape,a,t.rank)} != 1) {
        ${t.indicesSet(e,a,at(s,a+i,r))}
      } else {
        ${t.indicesSet(e,a,0)}
      }`).join("")}
`},jy=(e,t,n,r,s=!1,i)=>{let o=e[0].dims,a=e[1].dims,l=o[o.length-2],u=a[a.length-1],p=o[o.length-1],c=pn(u),d=pn(p),f=pn(l),m=Me.size(n)/c/f,y=e.length>2,C=r?r.slice(0,-2):n.slice(0,-2),_=[Me.size(C),l,u],h=[{type:12,data:m},{type:12,data:l},{type:12,data:u},{type:12,data:p}];ua(t,h),h.push(...lt(C,o,a)),y&&h.push(...lt(e[2].dims)),h.push(...lt(_));let w=M=>{let x=Fy("batch_dims",e[0].dataType,C.length),b=ke("a",e[0].dataType,o.length,d),T=ke("b",e[1].dataType,a.length,c),S=rt("output",e[0].dataType,_.length,c),$=Kn(S.type.tensor),O=la(t,S.type.value,$),G=[b,T],H="";if(y){let q=s?c:1;G.push(ke("bias",e[2].dataType,e[2].dims.length,q)),H=`${s?`value += bias[col / ${q}];`:`value += ${S.type.value}(bias[row + i]);`}`}let N=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];ca(t,N);let J=()=>{let q=`var a_data: ${b.type.value};`;for(let X=0;X<d;X++)q+=`
              let b_data${X} = b[(b_offset + (k + ${X}) * uniforms.N + col) / ${c}];`;for(let X=0;X<f;X++){q+=`a_data = a[(a_offset + (row + ${X}) * uniforms.K + k) / ${d}];`;for(let Y=0;Y<d;Y++)q+=`
            values[${X}] = fma(${T.type.value}(a_data${d===1?"":`[${Y}]`}), b_data${Y}, values[${X}]);
`}return q};return`
  ${M.registerUniforms(N).registerInternalVariables(x).declareVariables(...G,S)}
  ${M.mainStart()}
    ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${c})) * ${c};
    var index1 = global_idx / (uniforms.N / ${c});
    let stride1 = uniforms.M / ${f};
    let row = (index1 % stride1) * ${f};
    let batch = index1 / stride1;

    ${n.length===2?"":`let batch_indices = ${x.offsetToIndices("batch")};`}

    var a_indices: ${b.type.indices};
    ${Nu("a_indices",b,b.rank-2,x.rank,"batch_indices")}
    ${b.indicesSet("a_indices",b.rank-2,0)}
    ${b.indicesSet("a_indices",b.rank-1,0)}
    let a_offset = ${b.indicesToOffset("a_indices")};

    var b_indices: ${T.type.indices};
    ${Nu("b_indices",T,T.rank-2,x.rank,"batch_indices")}
    ${T.indicesSet("b_indices",T.rank-2,0)}
    ${T.indicesSet("b_indices",T.rank-1,0)}
    let b_offset = ${T.indicesToOffset("b_indices")};
    var values: array<${S.type.value}, ${f}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${d}) {
      ${J()}
    }
    for (var i = 0u; i < ${f}u; i++) {
      var value = values[i];
      ${H}
      ${O}
      let cur_indices = ${S.type.indices}(batch, row + i, col);
      let offset = ${S.indicesToOffset("cur_indices")};
      ${S.setByOffset(`offset / ${c}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${c};${d};${f};${s}`,inputDependencies:y?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:h}),getShaderSource:w}}}),jP,VP,qg,Jm,UP,Qg,WP,af,Uy=Ue(()=>{mt(),xt(),bt(),ya(),Vy(),Ny(),jP=(e,t)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${t?", batchIndices":""});
        `,VP=(e,t)=>e?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,qg=(e,t,n="f32",r,s=!1,i=32,o=!1,a=32)=>{let l=t[1]*e[1],u=t[0]*e[0],p=s?l:i,c=s?i:l,d=p/t[0],f=i/t[1];if(!((s&&d===4&&e[1]===4||!s&&(d===3||d===4))&&p%t[0]===0&&i%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${s} is true, innerElementSize ${d} and workPerThread[1] ${e[1]} must be 4.
      Otherwise, innerElementSize ${d} must be 3 or 4.
  tileAWidth ${p} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${d}<${n}>, ${p/d}>, ${c}>;
var<workgroup> mm_Bsub: array<array<vec4<${n}>, ${u/e[0]}>, ${i}>;

const rowPerThread = ${e[1]};
const colPerThread = ${e[0]};
const innerElementSize = ${d};
const tileInner = ${i};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${o?"0":"i32(globalId.z)"};
  ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${l};

  let num_tiles = ${o?`${Math.ceil(a/i)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${o?`i32(globalId.z) * ${a}`:"0"};

  var acc: array<vec4<${n}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${f};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${jP(s,r)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${d===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${VP(s,d)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Jm=(e,t)=>e?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${t?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${t?", batchIndices":""});
            `,UP=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",Qg=(e,t,n="f32",r,s=!1,i=32,o=!1,a=32,l=!1)=>{let u=e[1]*t[1],p=e[0]*t[0],c=s?u:i,d=s?i:u;if(!(d%t[1]===0&&c%t[0]===0&&i%t[1]===0))throw new Error(`tileAHight ${d} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`);let f=d/t[1],m=c/t[0],y=i/t[1],C=l?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${u};
    let globalColStart = i32(workgroupId.x) * ${p};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${d}; inputRow = inputRow + ${t[1]}) {
        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {
          ${Jm(s,r)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {
            for (var inputCol = localCol; inputCol < ${p}; inputCol = inputCol + ${t[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${r?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${n}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${s?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${t[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${t[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${u};

let tileRowA = i32(localId.y) * ${f};
let tileColA = i32(localId.x) * ${m};
let tileRowB = i32(localId.y) * ${y};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${m}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Jm(s,r)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${r?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${n}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${UP(s)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${n}, ${c}>, ${d}>;
  var<workgroup> mm_Bsub : array<array<${n}, ${p}>, ${i}>;
  const rowPerThread = ${e[1]};
  const colPerThread = ${e[0]};
  const tileInner = ${i};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${o?"0":"i32(globalId.z)"};
    ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${o?`${Math.ceil(a/i)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${o?`i32(globalId.z) * ${a}`:"0"};

    var acc : array<array<${n}, colPerThread>, rowPerThread>;
    ${C}
  }
`},WP=(e,t,n,r,s=!1)=>{let[i,o,a,l]=r,u=Kn(r[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Jn(e,u)} {
      var value = ${Jn(e,u)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${o.type.indices};
        ${Nu("aIndices",o,o.rank-2,i.rank,"batchIndices")}
        ${o.indicesSet("aIndices",o.rank-2,"u32(row)")}
        ${o.indicesSet("aIndices",o.rank-1,"u32(colIn)")}
        value = ${o.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Jn(e,u)} {
      var value = ${Jn(e,u)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${a.type.indices};
        ${Nu("bIndices",a,a.rank-2,i.rank,"batchIndices")}
        ${a.indicesSet("bIndices",a.rank-2,"u32(row)")}
        ${a.indicesSet("bIndices",a.rank-1,"u32(colIn)")}
        value = ${a.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Jn(e,u)}) {
      let col = colIn * ${e};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${t?`value = value + ${s?"bias[colIn]":`${Jn(e,u)}(bias[row])`};`:""}
        ${n}
        ${l.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},af=(e,t,n,r,s=!1,i)=>{let o=e[0].dims,a=e[1].dims,l=o.slice(0,-2),u=a.slice(0,-2),p=r?r.slice(0,-2):n.slice(0,-2),c=Me.size(p),d=o[o.length-2],f=o[o.length-1],m=a[a.length-1],y=f%4===0&&m%4===0,C=d<=8?[4,1,1]:[4,4,1],_=[8,8,1],h=[Math.ceil(m/_[0]/C[0]),Math.ceil(d/_[1]/C[1]),Math.ceil(c/_[2]/C[2])],w=y?4:1,M=[...l,d,f/w],x=M.length,b=[...u,f,m/w],T=b.length,S=[c,d,m/w],$=[{type:6,data:d},{type:6,data:m},{type:6,data:f}];ua(t,$),$.push(...lt(p,M,b));let O=["rank","rank"],G=e.length>2;G&&($.push(...lt(e[2].dims)),O.push("rank")),$.push(...lt(S));let H=N=>{let J=p.length,q=Fy("batchDims",e[0].dataType,J,1),X=Kn(e[0].dataType),Y=ke("a",e[0].dataType,x,w),K=ke("b",e[1].dataType,T,w),oe=rt("result",e[0].dataType,S.length,w),se=[Y,K];if(G){let pe=s?w:1;se.push(ke("bias",e[2].dataType,e[2].dims.length,pe))}let F=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];ca(t,F);let I=Kn(oe.type.tensor),V=la(t,oe.type.value,I),ee=WP(w,G,V,[q,Y,K,oe],s);return`
  ${N.registerUniforms(F).registerInternalVariables(q).declareVariables(...se,oe)}
  ${ee}
  ${y?qg(C,_,X,q):Qg(C,_,X,q)}
                   `};return{name:"MatMul",shaderCache:{hint:`${C};${t.activation};${y};${s}`,inputDependencies:O},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:e[0].dataType}],dispatchGroup:{x:h[0],y:h[1],z:h[2]},programUniforms:$}),getShaderSource:H}}}),GP,JD,pU=Ue(()=>{mt(),wi(),bt(),ya(),Ny(),dU(),Uy(),GP=(e,t,n,r,s=!1,i,o=4,a=4,l=4,u="f32")=>{let p=$=>{switch($){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${u}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${$} is not supported.`)}},c=$=>{switch($){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${$} is not supported.`)}},d=e?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,f=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,m=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",y=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",C=e?"row":"col",_=e?"col":"row",h=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${C} / outWidth;
    let outCol = ${C} % outWidth;

    let WRow = ${_} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${_} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${_} % inChannels;
    var resData = ${Jn(o,u)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${m} && xCol >= 0 && xCol < ${y}) {
      ${d}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${p(o)}
    }
    return resData;`,w=e?t&&r?`
    let col = colIn * ${o};
    ${h}`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${h}
    }
    return ${Jn(o,u)}(0.0);`:r&&n?`
    let col = colIn * ${o};
    ${h}`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${h}
    }
    return ${Jn(o,u)}(0.0);`,M=e?r&&n?c(a):`
    let col = colIn * ${a};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${c(a)}
    }
    return ${Jn(a,u)}(0.0);`:`
    let col = colIn * ${a};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${c(a)}
    }
    return ${Jn(a,u)}(0.0);`,x=Jn(l,u),b=Jn(e?o:a,u),T=Jn(e?a:o,u),S=la(i,x,u);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${b} {
      ${e?w:M}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${T} {
      ${e?M:w}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${x}) {
      let col = colIn * ${l};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${f}
      ${XD(s)}
      ${S}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},JD=(e,t,n,r,s,i,o,a,l)=>{let u=t.format==="NHWC",p=u?e[0].dims[3]:e[0].dims[1],c=n[0],d=u?n[2]:n[3],f=u?n[1]:n[2],m=u?n[3]:n[1],y=u&&(p%4===0||p%3===0)&&m%4===0,C=u?m:d*f,_=u?d*f:m,h=[8,8,1],w=r<=8?[4,1,1]:[4,4,1],M=[Math.ceil(C/h[0]/w[0]),Math.ceil(_/h[1]/w[1]),Math.ceil(c/h[2]/w[2])];Dt("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${M}`);let x=y?u&&p%4!==0?3:4:1,b=h[1]*w[1],T=h[0]*w[0],S=Math.max(h[0]*x,h[1]),$=r%b===0,O=s%T===0,G=i%S===0,H=y?[x,4,4]:[1,1,1],N=[{type:6,data:r},{type:6,data:s},{type:6,data:i},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];ua(t,N),N.push(...lt(e[0].dims,e[1].dims));let J=["rank","rank"];o&&(N.push(...lt(e[2].dims)),J.push("rank")),N.push(...lt(n));let q=X=>{let Y=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];ca(t,Y);let K=y?4:1,oe=Kn(e[0].dataType),se=`
      fn setOutputAtIndex(flatIndex : i32, value : ${y?`vec4<${oe}>`:oe}) {
        result[flatIndex] = ${y?`vec4<${oe}>`:oe}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${y?`vec4<${oe}>`:oe}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${y?"/ 4":""}, value);
      }`,F=ke("x",e[0].dataType,e[0].dims.length,x===3?1:x),I=ke("w",e[1].dataType,e[1].dims.length,K),V=[F,I],ee=rt("result",e[0].dataType,n.length,K);if(o){let pe=ke("bias",e[2].dataType,e[2].dims.length,K);V.push(pe),se+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${y?`vec4<${oe}>`:oe} {
          return bias[coords.${u?"w":"y"}${y?"/ 4":""}];
        }`}return`
        ${YD("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${X.registerUniforms(Y).declareVariables(...V,ee)}
        ${se}
        ${GP(u,$,O,G,o,t,H[0],H[1],H[2],oe)}
        ${y?qg(w,h,oe,void 0,!u,S):Qg(w,h,oe,void 0,!u,S,!1,void 0,a)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${x};${y};${$};${O};${G};${b};${T};${S}`,inputDependencies:J},getRunData:()=>({outputs:[{dims:l?l(n):n,dataType:e[0].dataType}],dispatchGroup:{x:M[0],y:M[1],z:M[2]},programUniforms:N}),getShaderSource:q}}}),HP,Zm,pu,KP,e_,qP,ZD,eO,fU=Ue(()=>{mt(),wi(),xt(),bt(),ya(),Ny(),HP=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t},Zm=e=>typeof e=="number"?[e,e,e]:e,pu=(e,t)=>t<=1?e:e+(e-1)*(t-1),KP=(e,t,n,r=1)=>{let s=pu(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)},e_=(e,t,n,r,s)=>{s==null&&(s=KP(e,t[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=Math.trunc((e[o]-t[o]+2*s)/r[o]+1));return i},qP=(e,t,n,r,s,i,o,a,l,u)=>{let p,c,d,f;if(e==="VALID"&&(e=0),typeof e=="number"){p={top:e,bottom:e,left:e,right:e,front:e,back:e};let m=e_([t,n,r,1],[a,l,u],1,[s,i,o],e);c=m[0],d=m[1],f=m[2]}else if(Array.isArray(e)){if(!e.every((y,C,_)=>y===_[0]))throw Error(`Unsupported padding parameter: ${e}`);p={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let m=e_([t,n,r,1],[a,l,u],1,[s,i,o],e[0]);c=m[0],d=m[1],f=m[2]}else if(e==="SAME_UPPER"){c=Math.ceil(t/s),d=Math.ceil(n/i),f=Math.ceil(r/o);let m=(c-1)*s+a-t,y=(d-1)*i+l-n,C=(f-1)*o+u-r,_=Math.floor(m/2),h=m-_,w=Math.floor(y/2),M=y-w,x=Math.floor(C/2),b=C-x;p={top:w,bottom:M,left:x,right:b,front:_,back:h}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:p,outDepth:c,outHeight:d,outWidth:f}},ZD=(e,t,n,r,s,i=!1,o="channelsLast")=>{let a,l,u,p,c;if(o==="channelsLast")[a,l,u,p,c]=e;else if(o==="channelsFirst")[a,c,l,u,p]=e;else throw new Error(`Unknown dataFormat ${o}`);let[d,,f,m,y]=t,[C,_,h]=Zm(n),[w,M,x]=Zm(r),b=pu(f,w),T=pu(m,M),S=pu(y,x),{padInfo:$,outDepth:O,outHeight:G,outWidth:H}=qP(s,l,u,p,C,_,h,b,T,S),N=i?d*c:d,J=[0,0,0,0,0];return o==="channelsFirst"?J=[a,N,O,G,H]:o==="channelsLast"&&(J=[a,O,G,H,N]),{batchSize:a,dataFormat:o,inDepth:l,inHeight:u,inWidth:p,inChannels:c,outDepth:O,outHeight:G,outWidth:H,outChannels:N,padInfo:$,strideDepth:C,strideHeight:_,strideWidth:h,filterDepth:f,filterHeight:m,filterWidth:y,effectiveFilterDepth:b,effectiveFilterHeight:T,effectiveFilterWidth:S,dilationDepth:w,dilationHeight:M,dilationWidth:x,inShape:e,outShape:J,filterShape:t}},eO=(e,t,n,r,s,i)=>{let o=i==="channelsLast";o?e[0].dims[3]:e[0].dims[1];let a=[64,1,1],l={x:n.map((C,_)=>_)},u=[Math.ceil(HP(l.x.map(C=>n[C]))/a[0]),1,1];Dt("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${u}`);let p=1,c=Me.size(n),d=[{type:12,data:c},{type:12,data:r},{type:12,data:s},{type:12,data:t.strides},{type:12,data:t.dilations}];ua(t,d),d.push(...lt(e[0].dims,e[1].dims));let f=["rank","rank"],m=e.length===3;m&&(d.push(...lt(e[2].dims)),f.push("rank")),d.push(...lt(n));let y=C=>{let _=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:r.length},{name:"pads",type:"u32",length:s.length},{name:"strides",type:"u32",length:t.strides.length},{name:"dilations",type:"u32",length:t.dilations.length}];ca(t,_);let h=1,w=Kn(e[0].dataType),M=ke("x",e[0].dataType,e[0].dims.length,p),x=ke("W",e[1].dataType,e[1].dims.length,h),b=[M,x],T=rt("result",e[0].dataType,n.length,h),S="";if(m){let G=ke("bias",e[2].dataType,e[2].dims.length,h);b.push(G),S+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${w} {
          return bias[${o?at("coords",4,5):at("coords",1,5)}];
        }`}let $=Jn(p,w),O=la(t,$,w);return`
            ${S}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${M.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${x.getByIndices("aIndices")};
            }
          ${C.registerUniforms(_).declareVariables(...b,T)}
          ${C.mainStart()}
          ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${T.offsetToIndices("global_idx")};
              let batch = ${at("coords",0,M.rank)};
              let d2 = ${o?at("coords",M.rank-1,M.rank):at("coords",1,M.rank)};
              let xFRCCorner = vec3<u32>(${o?at("coords",1,M.rank):at("coords",2,M.rank)},
              ${o?at("coords",2,M.rank):at("coords",3,M.rank)},
              ${o?at("coords",3,M.rank):at("coords",4,M.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${o?at("uniforms.x_shape",1,M.rank):at("uniforms.x_shape",2,M.rank)};
              let xShapeZ = ${o?at("uniforms.x_shape",2,M.rank):at("uniforms.x_shape",3,M.rank)};
              let xShapeW = ${o?at("uniforms.x_shape",3,M.rank):at("uniforms.x_shape",4,M.rank)};
              let xShapeU = ${o?at("uniforms.x_shape",4,M.rank):at("uniforms.x_shape",1,M.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${o?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${o?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${o?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${o?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${m?"value = value + getBiasByOutputCoords(coords)":""};
              ${O}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${t.cacheKey};${o};${p};${m}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:u[0],y:u[1],z:u[2]},programUniforms:d}),getShaderSource:y}}}),tO,nO,hU=Ue(()=>{mt(),xt(),bt(),ya(),tO=(e,t,n,r)=>{let s=e.length>2,i=s?"value += b[output_channel];":"",o=e[0].dims,a=e[1].dims,l=t.format==="NHWC",u=l?n[3]:n[1],p=u/t.group,c=l&&p>=4?pn(u):1,d=Me.size(n)/c,f=[{type:12,data:d},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:p}];ua(t,f),f.push(...lt(o,[a[0],a[1],a[2],a[3]/c]));let m=s?["rank","rank","rank"]:["rank","rank"];f.push(...lt([n[0],n[1],n[2],n[3]/c]));let y=C=>{let _=rt("output",e[0].dataType,n.length,c),h=Kn(_.type.tensor),w=la(t,_.type.value,h),M=ke("x",e[0].dataType,o.length),x=ke("w",e[1].dataType,a.length,c),b=[M,x];s&&b.push(ke("b",e[2].dataType,e[2].dims,c));let T=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];ca(t,T);let S=l?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${M.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${x.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${M.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${x.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${C.registerUniforms(T).declareVariables(...b,_)}

  ${C.mainStart()}
    ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${_.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${l?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${c} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];

    var value: ${_.type.value} = ${_.type.value}(0);
    ${S}
    ${i}
    ${w}
    ${_.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${t.cacheKey}_${c}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:f}),getShaderSource:y}},nO=(e,t,n,r)=>{let s=e.length>2,i=pn(n[3]),o=pn(n[2]),a=Me.size(n)/i/o,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/i],u=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/i],p=[n[0],n[1],n[2],n[3]/i],c=[{type:12,data:a},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];ua(t,c),c.push(...lt(l,u,p));let d=(o-1)*t.strides[1]+u[1],f=m=>{let y=rt("output",e[0].dataType,p.length,i),C=Kn(y.type.tensor),_=la(t,y.type.value,C),h=ke("x",e[0].dataType,l.length,i),w=ke("w",e[1].dataType,u.length,i),M=[h,w];s&&M.push(ke("b",e[2].dataType,e[2].dims,i));let x=s?"value += b[output_channel];":"",b=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return ca(t,b),`
  ${m.registerUniforms(b).declareVariables(...M,y)}
  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${o}u;
    let col = (index1 % width1) * ${o}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${h.type.value}, ${d}>;
    var values: array<${y.type.value}, ${o}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${u[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${d}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${h.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${h.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${u[1]}; w_width++) {
          let w_val = ${w.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${o}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${o}u; i++) {
      var value = values[i];
      ${x}
      ${_}
      ${y.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${i};${o};${d};${u[0]};${u[1]}`,inputDependencies:s?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:c}),getShaderSource:f}}}),QP,qd,XP,Qd,Xg,t_,YP,JP,Yg,mU=Ue(()=>{xt(),pU(),fU(),Uy(),hU(),ya(),Vy(),lo(),QP=(e,t,n,r,s,i)=>{let o=e[0],a=e.slice(i?1:2,i?3:4),l=a.length,u=t[0],p=t.slice(2).map((d,f)=>d+(d-1)*(n[f]-1)),c=a.map((d,f)=>d+r[f]+r[f+l]).map((d,f)=>Math.floor((d-p[f]+s[f])/s[f]));return c.splice(0,0,o),c.splice(i?3:1,0,u),c},qd=[2,3,1,0],XP=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let n=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],r=e[1].dims[1]*t.group;if(n!==r)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Qd=(e,t)=>{let n=e.kernelShape.slice();n.length<t[1].dims.length-2&&n.push(...Array(t[1].dims.length-2-n.length).fill(0));for(let i=2;i<t[1].dims.length;++i)n[i-2]===0&&(n[i-2]=t[1].dims[i]);let r=e.pads.slice();sf.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,e.format==="NHWC",e.autoPad);let s=Object.assign({},e);return Object.assign(s,{kernelShape:n,pads:r}),s},Xg=e=>{let t=By(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],s=e.dilations,i=e.group,o=e.kernel_shape,a=e.pads,l=e.strides,u=e.w_is_const();return{autoPad:r,format:n,dilations:s,group:i,kernelShape:o,pads:a,strides:l,wIsConst:u,...t,cacheKey:`${e.format};${t.activation};`}},t_=(e,t,n,r)=>{let s=n.format==="NHWC",i=QP(t[0].dims,t[1].dims,n.dilations,n.pads,n.strides,s);if(n.group!==1){let b=[t[0]];if(s){let T=e.kernelCustomData.wT??e.compute(Hr(t[1],qd),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=T),b.push(T)}else b.push(t[1]);t.length===3&&b.push(t[2]),!e.adapterInfo.isArchitecture("ampere")&&s&&t[1].dims[0]===n.group&&t[1].dims[1]===1&&n.dilations[0]===1&&n.dilations[1]===1?e.compute(nO(b,n,i,r),{inputs:b}):e.compute(tO(b,n,i,r),{inputs:b});return}let o=t.length===3,a=t[0].dims[s?1:2],l=t[0].dims[s?2:3],u=t[0].dims[s?3:1],p=t[1].dims[2],c=t[1].dims[3],d=i[s?1:2],f=i[s?2:3],m=i[s?3:1],y=s&&p===a&&c===l&&n.pads[0]===0&&n.pads[1]===0;if(y||p===1&&c===1&&n.dilations[0]===1&&n.dilations[1]===1&&n.strides[0]===1&&n.strides[1]===1&&n.pads[0]===0&&n.pads[1]===0){let b=i[0],T,S,$,O=[];if(s){let N=e.kernelCustomData.wT??e.compute(Hr(t[1],qd),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=N),y){let J=a*l*u;T=t[0].reshape([1,b,J]),S=N.reshape([1,J,m]),$=[1,b,m]}else T=t[0].reshape([b,a*l,u]),S=N.reshape([1,u,m]),$=[b,d*f,m];O.push(T),O.push(S)}else T=t[0].reshape([b,u,a*l]),S=t[1].reshape([1,m,u]),$=[b,m,d*f],O.push(S),O.push(T);o&&O.push(t[2]);let G=$[2],H=O[0].dims[O[0].dims.length-1];G<8&&H<8?e.compute(jy(O,n,i,$,s,r),{inputs:O}):e.compute(af(O,n,i,$,s,r),{inputs:O});return}let C=!0,_=e.kernelCustomData.wT??e.compute(Hr(t[1],qd),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=_);let h=[t[0],_];o&&h.push(t[2]);let w=s?d*f:m,M=s?m:d*f,x=p*c*u;e.compute(JD(h,n,i,w,M,x,o,C,r),{inputs:h})},YP=(e,t)=>{let n=t.format==="NHWC",r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&r.push(e.inputs[2]);let s=[0,t.pads[0],0,t.pads[1]],i=[1].concat(t.strides),o=[1].concat(t.dilations),a=[1].concat(t.kernelShape),l=Qd({...t,pads:s,strides:i,dilations:o,kernelShape:a},r);t_(e,r,l,u=>n?[u[0],u[2],u[3]]:[u[0],u[1],u[3]])},JP=(e,t,n)=>{let r=n.format==="NHWC"?"channelsLast":"channelsFirst",s=Qd(n,t),i=n.autoPad==="NOTSET"?n.pads:n.autoPad,o=ZD(t[0].dims,t[1].dims,n.strides,n.dilations,i,!1,r);e.compute(eO(t,s,o.outShape,[o.filterDepth,o.filterHeight,o.filterWidth],[o.padInfo.front,o.padInfo.top,o.padInfo.left],r))},Yg=(e,t)=>{if(XP(e.inputs,t),e.inputs[0].dims.length===3)YP(e,t);else if(e.inputs[0].dims.length===5)JP(e,e.inputs,t);else{let n=Qd(t,e.inputs);t_(e,e.inputs,n)}}}),rO,_U=Ue(()=>{mt(),wi(),xt(),bt(),rO=(e,t,n)=>{let r=e.length>2,s=t.outputShape,i=t.format==="NHWC",o=t.group,a=e[1].dims,l=a[2]/o,u=a[3],p=i?pn(l):1,c=i&&u===1&&l>=4,d=c?Math.floor(l/4)*4:Math.floor(l/p)*p,f=l-d,m=i?pn(u):1,y=i?u===1?p:m:1,C=Me.size(s)/m,_=[Math.ceil(C/64),1,1];Dt("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${_}`);let h=["rank","rank"],w=[t.strides[0],t.strides[1]],M=[t.kernelShape[i?1:2],t.kernelShape[i?2:3]],x=[t.dilations[0],t.dilations[1]],b=[M[0]+(t.dilations[0]<=1?0:(t.kernelShape[i?1:2]-1)*(t.dilations[0]-1)),M[1]+(t.dilations[1]<=1?0:(t.kernelShape[i?2:3]-1)*(t.dilations[1]-1))],T=[b[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),b[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],S=[{type:12,data:C},{type:12,data:w},{type:12,data:M},{type:12,data:x},{type:12,data:b},{type:6,data:T},{type:12,data:d},{type:12,data:l},{type:12,data:u},...lt(e[0].dims,e[1].dims)];r&&(S.push(...lt(e[2].dims)),h.push("rank")),S.push(...lt(s));let $=O=>{let G=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:w.length},{name:"filter_dims",type:"u32",length:M.length},{name:"dilations",type:"u32",length:M.length},{name:"effective_filter_dims",type:"u32",length:b.length},{name:"pads",type:"i32",length:T.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],H=Kn(e[0].dataType),N=i?1:2,J=i?2:3,q=i?3:1,X=ke("W",e[1].dataType,e[1].dims.length,y),Y=ke("Dy",e[0].dataType,e[0].dims.length,p),K=[Y,X];r&&K.push(ke("bias",e[2].dataType,[s[q]].length,m));let oe=rt("result",e[0].dataType,s.length,m),se=()=>{let V="";if(c)p===4?V+=`
        let xValue = ${Y.getByOffset("x_offset")};
        let wValue = ${X.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`:p===2?V+=`
          dotProd = dotProd + dot(vec4<${H}>(${Y.getByOffset("x_offset")}, ${Y.getByOffset("x_offset + 1u")}), vec4<${H}>(${X.getByOffset("w_offset")}, ${X.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`:p===1&&(V+=`
          dotProd = dotProd + dot(vec4<${H}>(${Y.getByOffset("x_offset")}, ${Y.getByOffset("x_offset + 1u")}, ${Y.getByOffset("x_offset + 2u")}, ${Y.getByOffset("x_offset + 3u")}), vec4<${H}>(${X.getByOffset("w_offset")}, ${X.getByOffset("w_offset + 1u")}, ${X.getByOffset("w_offset + 2u")}, ${X.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`);else if(V+=`
                  let xValue = ${i?Y.getByOffset(`${Y.indicesToOffset(`${Y.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${p}`):Y.get("batch","inputChannel","idyR","idyC")};
        `,p===1)V+=`
          let w_offset = ${X.indicesToOffset(`${X.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${X.getByOffset(`w_offset / ${y}`)};
          dotProd = dotProd + xValue * wValue;`;else for(let ee=0;ee<p;ee++)V+=`
            let wValue${ee} = ${X.getByOffset(`${X.indicesToOffset(`${X.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${ee}, wOutChannel)`)} / ${y}`)};
            dotProd = dotProd + xValue[${ee}] * wValue${ee};`;return V},F=()=>{if(f===0)return"";if(!c)throw new Error(`packInputAs4 ${c} is not true.`);let V="";if(p===1){V+="dotProd = dotProd";for(let ee=0;ee<f;ee++)V+=`
            + ${Y.getByOffset(`x_offset + ${ee}`)} * ${X.getByOffset(`w_offset + ${ee}`)}`;V+=";"}else if(p===2){if(f!==2)throw new Error(`Invalid inputChannelsRemainder ${f}.`);V+=`
          let xValue = ${Y.getByOffset("x_offset")};
          let wValue = ${X.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`}return V},I=`
            let outputIndices = ${oe.offsetToIndices(`global_idx * ${m}`)};
            let batch = ${oe.indicesGet("outputIndices",0)};
            let d1 = ${oe.indicesGet("outputIndices",q)};
            let r = ${oe.indicesGet("outputIndices",N)};
            let c = ${oe.indicesGet("outputIndices",J)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${oe.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${H}(dyRCorner) + ${H}(wR)) / ${H}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${H}(uniforms.Dy_shape[${N}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${H}(dyCCorner) + ${H}(wC)) / ${H}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${H}(uniforms.Dy_shape[${J}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${c?`
                var x_offset = ${Y.indicesToOffset(`${Y.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${p};
                var w_offset = ${X.indicesToOffset(`${X.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${y};
                  `:""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${c?4:p}) {
                  ${se()}
                  inputChannel = inputChannel + ${c?4:p};
                }
                ${F()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${r?` + bias[d1 / ${m}]`:""};
            ${oe.setByOffset("global_idx","value")};
          `;return`
    ${O.registerUniforms(G).declareVariables(...K,oe)}
      ${O.mainStart()}
      ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${I}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};${p}${y}${m}${c}${f}`,inputDependencies:h},getRunData:()=>({dispatchGroup:{x:_[0],y:_[1],z:_[2]},outputs:[{dims:n?n(s):s,dataType:e[0].dataType}],programUniforms:S}),getShaderSource:$}}}),ZP,e2,t2,n_,sO,n2,r_,r2,iO,gU=Ue(()=>{_U(),ya(),lo(),ZP=(e,t,n,r,s,i)=>(e-1)*t+n+(r-1)*s+1-i,e2=(e,t,n,r,s)=>{let i=Math.floor(e/2);t==="SAME_UPPER"?(n[r]=i,n[s]=e-i):t==="SAME_LOWER"&&(n[r]=e-i,n[s]=i)},t2=(e,t,n,r,s,i,o,a,l,u)=>{let p=e.length-2,c=u.length===0;l.length<p&&l.push(...Array(p-l.length).fill(0));let d=e[0],f=t[a?3:1]*s;for(let m=0,y=e.length-p-(a?1:0);m<p;++m,++y){let C=e[y],_=c?C*o[m]:u[m],h=ZP(C,o[m],i[m],t[y],n[m],_);e2(h,r,i,m,m+p),c&&u.push(o[m]*(C-1)+l[m]+(t[y]-1)*n[m]+1-i[m]-i[m+p])}u.splice(0,0,d),u.splice(a?3:1,0,f)},n_=(e,t)=>{let n=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((c,d)=>c*d,1)===0){n.length=0;for(let c=2;c<t[1].dims.length;++c)n.push(t[1].dims[c])}let r=e.format==="NHWC";n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);let s=e.pads.slice(),i=e.outputShape.slice(),o=e.outputPadding.slice(),a=t[0].dims,l=e.dilations.slice();if(l.reduce((c,d)=>c+d,0)===0){let c=t[0].dims.length-2;l=new Array(c).fill(1)}let u=e.strides.slice();if(u.reduce((c,d)=>c+d,0)===0){let c=t[0].dims.length-2;u=new Array(c).fill(1)}t2(a,n,l,e.autoPad,e.group,s,u,r,o,i);let p=Object.assign({},e);return Object.assign(p,{kernelShape:n,pads:s,outputPadding:o,outputShape:i,dilations:l,strides:u}),p},sO=e=>{let t=By(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],s=e.dilations,i=e.group,o=e.kernelShape,a=e.pads,l=e.strides,u=e.wIsConst(),p=e.outputPadding,c=e.outputShape;return{autoPad:r,format:n,dilations:s,group:i,kernelShape:o,outputPadding:p,outputShape:c,pads:a,strides:l,wIsConst:u,...t,cacheKey:`${e.format};${t.activation};`}},n2=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let n=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],r=e[1].dims[0];if(n!==r)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let s=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==s))throw new Error("invalid bias");let i=e[0].dims.length-2;if(t.dilations.reduce((o,a)=>o+a,0)>0&&t.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(t.strides.reduce((o,a)=>o+a,0)>0&&t.strides.length!==i)throw new Error(`strides should be ${i}D`);if(t.pads.reduce((o,a)=>o+a,0)>0&&t.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(t.outputPadding.length!==i&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${i}D`);if(t.kernelShape.reduce((o,a)=>o+a,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},r_=(e,t,n,r)=>{let s=e.kernelCustomData.wT??e.compute(Hr(t[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=s);let i=[t[0],s];t.length===3&&i.push(t[2]),e.compute(rO(i,n,r),{inputs:i})},r2=(e,t)=>{let n=t.format==="NHWC",r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&r.push(e.inputs[2]);let s=t.kernelShape;(s.length===0||s[0]===0)&&(s=[e.inputs[1].dims[2]]);let i=t.dilations;(i.length===0||i[0]===0)&&(i=[1]);let o=t.strides;(o.length===0||o[0]===0)&&(o=[1]);let a=t.pads;a.length===0&&(a=[0,0]),a=[0,a[0],0,a[1]],o=[1].concat(o),i=[1].concat(i),s=[1].concat(s);let l=t.outputPadding;l=[0].concat(l);let u=n_({...t,pads:a,strides:o,dilations:i,kernelShape:s,outputPadding:l},r);r_(e,r,u,p=>n?[p[0],p[2],p[3]]:[p[0],p[1],p[3]])},iO=(e,t)=>{if(n2(e.inputs,t),e.inputs[0].dims.length===3)r2(e,t);else{let n=n_(t,e.inputs);r_(e,e.inputs,n)}}}),s2,oO,aO,yU=Ue(()=>{mt(),xt(),wn(),bt(),s2=(e,t,n,r)=>{let s=Me.size(t),i=t.length,o=ke("input",e,i),a=rt("output",e,i),l=n.dataType===6?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),u=Me.normalizeAxis(l,i),p=c=>{let d=` i32(${o.indicesGet("inputIndices","uniforms.axis")}) `,f=at("uniforms.input_shape","uniforms.axis",i),m=r.reverse?d+(r.exclusive?" + 1":""):"0",y=r.reverse?f:d+(r.exclusive?"":" + 1");return`
                ${c.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(o,a)}
                ${c.mainStart()}
                  ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${a.offsetToIndices("global_idx")};
                  var sum = ${a.type.value}(0);
                  let first : i32 = ${m};
                  let last : i32 = ${y};
                  for (var i : i32 = first; i < last; i++) {
                    ${o.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${o.getByIndices("inputIndices")};
                  }
                  ${a.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:r.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},{type:12,data:u},...lt(t,t)]}),getShaderSource:p}},oO=(e,t)=>{let n=e.inputs[0].dims,r=e.inputs[0].dataType,s=e.inputs[1];e.compute(s2(r,n,s,t),{inputs:[0]})},aO=e=>{let t=e.exclusive===1,n=e.reverse===1;return jt({exclusive:t,reverse:n})}}),i2,o2,a2,lO,uO,vU=Ue(()=>{mt(),xt(),wn(),bt(),i2=e=>{if(!e||e.length!==1)throw new Error("DepthToSpace requires 1 input.");if(e[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},o2=(e,t,n,r)=>{let s=[];s.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`);for(let i=0;i<t;++i)s.push(n.indicesSet("a",e[i],`i[${i}]`));return s.push("return a;}"),s.join(`
`)},a2=(e,t)=>{let n,r,s,i,o,a,l=t.format==="NHWC",u=t.blocksize,p=t.mode==="DCR";l?([n,r,s,i]=e.dims,o=p?[n,r,s,u,u,i/u**2]:[n,r,s,i/u**2,u,u],a=p?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,r,s,i]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],o=p?[n,u,u,i/u**2,r,s]:[n,i/u**2,u,u,r,s],a=p?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let c=e.reshape(o),d=c.dims.length,f=e.dataType,m=ke("a",f,d),y=rt("output",f,d),C=_=>`
  ${_.registerUniform("output_size","u32").declareVariables(m,y)}

  ${o2(a,d,m,y)}

  ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${y.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${y.setByOffset("global_idx",m.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:_=>{let h=l?[n,r*u,s*u,i/u**2]:[n,i/u**2,r*u,s*u],w=Me.size(h),M=c.dims,x=Me.sortBasedOnPerm(M,a);return{outputs:[{dims:h,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:[{type:12,data:w},...lt(M,x)]}},getShaderSource:C}},lO=(e,t)=>{i2(e.inputs),e.compute(a2(e.inputs[0],t))},uO=e=>jt({blocksize:e.blocksize,mode:e.mode,format:e.format})}),Xd,fu,s_,l2,u2,c2,d2,i_,p2,cO,dO,wU=Ue(()=>{mt(),xt(),wn(),bt(),Xd="[a-zA-Z]|\\.\\.\\.",fu="("+Xd+")+",s_="^"+fu+"$",l2="("+fu+",)*"+fu,u2="^"+l2+"$",c2=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);n===void 0?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},d2=class{constructor(e,t){var s;this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,r]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(u2)))throw new Error("Invalid LHS term");if(n.split(",").forEach((i,o)=>{let a=e[o].dims.slice();if(!i.match(RegExp(s_)))throw new Error("Invalid LHS term");let l=this.processTerm(i,!0,a,o);this.lhs.push(l)}),r==="")r+=[...this.symbolToInfo.entries()].filter(([i,o])=>o.count===1||i==="...").map(([i])=>i).join("");else if(!r.match(RegExp(fu)))throw new Error("Invalid RHS");(s=r.match(RegExp(Xd,"g")))==null||s.forEach(i=>{if(i==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let o=this.symbolToInfo.get(i);if(o===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(o.dimValue)}}),this.rhs=this.processTerm(r,!1,this.outputDims)}addSymbol(e,t,n){let r=this.symbolToInfo.get(e);if(r!==void 0){if(r.dimValue!==t&&r.count!==1)throw new Error("Dimension mismatch");r.count++,r.inputIndices.push(n)}else r={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,r)}processTerm(e,t,n,r=-1){let s=n.length,i=!1,o=[],a=0;if(!e.match(RegExp(s_))&&!t&&e!=="")throw new Error("Invalid LHS term");let l=e.match(RegExp(Xd,"g")),u=new c2(r);return l==null||l.forEach((p,c)=>{if(p==="..."){if(i)throw new Error("Only one ellipsis is allowed per input term");i=!0;let d=s-l.length+1;if(d<0)throw new Error("Ellipsis out of bounds");if(o=n.slice(a,a+d),this.hasEllipsis){if(this.ellipsisDims.length!==o.length||this.ellipsisDims.toString()!==o.toString())throw new Error("Ellipsis dimensions mismatch")}else if(t)this.hasEllipsis=!0,this.ellipsisDims=o;else throw new Error("Ellipsis must be specified in the LHS");for(let f=0;f<o.length;f++){let m=String.fromCharCode(48+f);u.addSymbol(m,c+f),this.addSymbol(m,n[a++],r)}}else u.addSymbol(p,c+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(p,n[a++],r)}),u}},i_=e=>e+"_max",p2=(e,t,n,r)=>{let s=e.map(u=>u.length).map((u,p)=>ke(`input${p}`,t,u)),i=Me.size(r),o=rt("output",t,r.length),a=[...n.symbolToInfo.keys()].filter(u=>!n.rhs.symbolToIndices.has(u)),l=u=>{let p=[],c="var prod = 1.0;",d="var sum = 0.0;",f="sum += prod;",m=[],y=[],C=[],_=[],h=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach((M,x)=>{var b;if(n.rhs.symbolToIndices.has(x)){let T=(b=n.rhs.symbolToIndices.get(x))==null?void 0:b[0];T!==void 0&&n.lhs.forEach((S,$)=>{if(M.inputIndices.includes($)){let O=S.symbolToIndices.get(x);if(O===void 0)throw new Error("Invalid symbol error");O.forEach(G=>{p.push(`${s[$].indicesSet(`input${$}Indices`,G,o.indicesGet("outputIndices",T))}`)})}})}else n.lhs.forEach((T,S)=>{if(M.inputIndices.includes(S)){let $=T.symbolToIndices.get(x);if($===void 0)throw new Error("Invalid symbol error");$.forEach(O=>{m.push(`${s[S].indicesSet(`input${S}Indices`,O,`${x}`)}`)}),_.push(`prod *= ${s[S].getByIndices(`input${S}Indices`)};`)}}),y.push(`for(var ${x}: u32 = 0; ${x} < uniforms.${i_(x)}; ${x}++) {`),C.push("}")});let w=h?[...p,`let sum = ${s.map((M,x)=>M.getByIndices(`input${x}Indices`)).join(" * ")};`]:[...p,d,...y,...m,c,..._,f,...C];return`
            ${u.registerUniforms(a.map(M=>({name:`${i_(M)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...s,o)}

            ${u.mainStart()}
            ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${o.offsetToIndices("global_idx")};
            ${s.map((M,x)=>`var input${x}Indices: ${s[x].type.indices};`).join(`
`)}
            ${w.join(`
`)};
            ${o.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let u=a.filter(c=>n.symbolToInfo.has(c)).map(c=>{var d;return{type:12,data:((d=n.symbolToInfo.get(c))==null?void 0:d.dimValue)||0}});u.push({type:12,data:i});let p=e.map((c,d)=>[...lt(c)]).reduce((c,d)=>c.concat(d),u);return p.push(...lt(r)),{outputs:[{dims:r,dataType:t}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:p}},getShaderSource:l}},cO=(e,t)=>{let n=new d2(e.inputs,t.equation),r=n.outputDims,s=e.inputs.map((i,o)=>i.dims);e.compute(p2(s,e.inputs[0].dataType,n,r))},dO=e=>{let t=e.equation.replace(/\s+/g,"");return jt({equation:t})}}),f2,o_,h2,m2,pO,MU=Ue(()=>{mt(),xt(),bt(),f2=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=n.length<t.length?0:n.length-t.length,s=t.length<n.length?0:t.length-n.length;for(;r<n.length&&s<t.length;++r,++s)if(n[r]!==t[s]&&n[r]!==1&&t[s]!==1)throw new Error("Expand requires shape to be broadcastable to input")},o_=(e,t)=>{let n=e.length-t.length,r=[];for(let s=0;s<n;++s)r.push(e[s]);for(let s=0;s<t.length;++s)r.push(t[s]===1?e[s+n]:t[s]);return r},h2=(e,t)=>e.length>t.length?o_(e,t):o_(t,e),m2=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=h2(t,n),s=e[0].dataType,i=s===9||Me.size(t)===1,o=s===9||t.length>0&&t[t.length-1]%4===0?4:1,a=i||r.length>0&&r[r.length-1]%4===0?4:1,l=Math.ceil(Me.size(r)/a),u=c=>{let d=ke("input",s,t.length,o),f=rt("output",s,r.length,a),m;if(s===9){let y=(C,_,h="")=>`
          let outputIndices${_} = ${f.offsetToIndices(`outputOffset + ${_}u`)};
          let offset${_} = ${d.broadcastedIndicesToOffset(`outputIndices${_}`,f)};
          let index${_} = offset${_} / 4u;
          let component${_} = offset${_} % 4u;
          ${C}[${_}] = ${h}(${d.getByOffset(`index${_}`)}[component${_}]);
        `;m=`
        let outputOffset = global_idx * ${a};
        var data = vec4<u32>(0);
        ${y("data",0,"u32")}
        ${y("data",1,"u32")}
        ${y("data",2,"u32")}
        ${y("data",3,"u32")}
        ${f.setByOffset("global_idx","data")}
      }`}else m=`
        let outputIndices = ${f.offsetToIndices(`global_idx * ${a}`)};
        let inputOffset = ${d.broadcastedIndicesToOffset("outputIndices",f)};
        let data = ${f.type.value}(${d.getByOffset(`inputOffset / ${o}`)});
        ${f.setByOffset("global_idx","data")}
      }`;return`
    ${c.registerUniform("vec_size","u32").declareVariables(d,f)}
    ${c.mainStart()}
    ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${m}`},p=[{type:12,data:l},...lt(t,r)];return{name:"Expand",shaderCache:{hint:`${r.length};${o}${a}`,inputDependencies:["rank"]},getShaderSource:u,getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p})}},pO=e=>{f2(e.inputs),e.compute(m2(e.inputs),{inputs:[0]})}}),_2,fO,xU=Ue(()=>{mt(),xt(),bt(),Ry(),_2=e=>{let t=e[0].dataType,n=Me.size(e[0].dims),r=Me.size(e[1].dims),s=r%4===0,i=o=>{let a=ke("x",t,[1],4),l=ke("bias",t,[1],4),u=rt("y",t,[1],4),p=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],c=f=>`
      let bias${f}_offset: u32 = (global_idx * 4 + ${f}) % uniforms.bias_size;
      let bias${f} = ${l.getByOffset(`bias${f}_offset / 4`)}[bias${f}_offset % 4];`,d=s?`
      let bias = ${l.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${c(0)}${c(1)}${c(2)}${c(3)}
      let bias = ${a.type.value}(bias0, bias1, bias2, bias3);`;return`${o.registerUniforms(p).declareVariables(a,l,u)}

    ${Hg(fr(t))}

    ${o.mainStart(vl)}
      ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${a.getByOffset("global_idx")};
      ${d}
      let x_in = x + bias;
      ${u.setByOffset("global_idx",Kg("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${s}`,inputDependencies:["type","type"]},getShaderSource:i,getRunData:o=>({outputs:[{dims:o[0].dims,dataType:o[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:r}],dispatchGroup:{x:Math.ceil(n/vl/4)}})}},fO=e=>{e.inputs.length<2||Me.size(e.inputs[1].dims)===0?DD(e):e.compute(_2(e.inputs))}}),g2,y2,hO,mO,bU=Ue(()=>{mt(),xt(),wn(),bt(),g2=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},y2=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n.length,i=Me.normalizeAxis(t.axis,s),o=n.slice(0);o.splice(i,1,...r);let a=n[i],l=e[0].dataType===9?4:1,u=Math.ceil(Me.size(o)/l),p=[{type:12,data:u},{type:6,data:a},{type:12,data:i},...lt(e[0].dims,e[1].dims,o)],c=d=>{let f=ke("data",e[0].dataType,e[0].dims.length,l),m=ke("inputIndices",e[1].dataType,e[1].dims.length),y=rt("output",e[0].dataType,o.length,l),C=h=>{let w=r.length,M=`var indicesIndices${h}  = ${m.type.indices}(0);`;for(let x=0;x<w;x++)M+=`${w>1?`indicesIndices${h}[${x}]`:`indicesIndices${h}`} = ${o.length>1?`outputIndices${h}[uniforms.axis + ${x}]`:`outputIndices${h}`};`;M+=`
          var idx${h} = ${m.getByIndices(`indicesIndices${h}`)};
          if (idx${h} < 0) {
            idx${h} = idx${h} + uniforms.axisDimLimit;
          }
          var dataIndices${h} : ${f.type.indices};
        `;for(let x=0,b=0;x<s;x++)x===i?(M+=`${s>1?`dataIndices${h}[${x}]`:`dataIndices${h}`} = u32(idx${h});`,b+=w):(M+=`${s>1?`dataIndices${h}[${x}]`:`dataIndices${h}`} = ${o.length>1?`outputIndices${h}[${b}]`:`outputIndices${h}`};`,b++);return M},_;if(e[0].dataType===9){let h=(w,M,x="")=>`
          let outputIndices${M} = ${y.offsetToIndices(`outputOffset + ${M}u`)};
          ${C(M)};
          let offset${M} = ${f.indicesToOffset(`dataIndices${M}`)};
          let index${M} = offset${M} / 4u;
          let component${M} = offset${M} % 4u;
          ${w}[${M}] = ${x}(${f.getByOffset(`index${M}`)}[component${M}]);
        `;_=`
        let outputOffset = global_idx * ${l};
        var value = vec4<u32>(0);
        ${h("value",0,"u32")}
        ${h("value",1,"u32")}
        ${h("value",2,"u32")}
        ${h("value",3,"u32")}
        ${y.setByOffset("global_idx","value")}
      `}else _=`
      let outputIndices = ${y.offsetToIndices("global_idx")};
      ${C("")};
      let value = ${f.getByIndices("dataIndices")};
      ${y.setByOffset("global_idx","value")};
      `;return`
      ${d.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(f,m,y)}
      ${d.mainStart()}
        ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${_}
      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:p}),getShaderSource:c}},hO=e=>jt({axis:e.axis}),mO=(e,t)=>{let n=e.inputs;g2(n),e.compute(y2(e.inputs,t))}}),v2,_O,gO,TU=Ue(()=>{mt(),xt(),bt(),v2=(e,t,n,r,s,i,o,a,l)=>{let u=[{type:12,data:i},{type:12,data:r},{type:12,data:s},{type:12,data:n},{type:12,data:o},{type:12,data:a},{type:12,data:l}],p=[i];u.push(...lt(t.dims,p));let c=d=>{let f=ke("indices_data",t.dataType,t.dims.length),m=rt("input_slice_offsets_data",12,1,1),y=[f,m],C=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:s.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${d.registerUniforms(C).declareVariables(...y)}
  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${s.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${n.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return e.compute({name:"computeSliceOffsets",shaderCache:{hint:`${s.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:p,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:u}),getShaderSource:c},{inputs:[t],outputs:[-1]})[0]},_O=(e,t)=>{let n=e.inputs,r=n[0].dims,s=n[0].dataType,i=n[1].dims,o=i[i.length-1],a=Me.sizeToDimension(i,i.length-1),l=Me.sizeFromDimension(r,t.batchDims+o),u=Me.sizeToDimension(r,t.batchDims),p=Me.sizeFromDimension(r,t.batchDims),c=a/u,d=new Array(o),f=l;for(let M=0;M<o;++M)d[o-1-M]=f,f*=r[t.batchDims+o-1-M];let m=v2(e,n[1],d,t.batchDims,r,a,c,p,o),y=t.batchDims+o;if(y>r.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let C=i.slice(0,-1).concat(r.slice(y)),_=Me.size(C),h=[{type:12,data:_},{type:12,data:l},...lt(n[0].dims,m.dims,C)],w=M=>{let x=ke("data",n[0].dataType,n[0].dims.length),b=ke("slice_offsets",12,m.dims.length),T=rt("output",n[0].dataType,C.length);return`
          ${M.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(x,b,T)}
            ${M.mainStart()}
            ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};e.compute({name:"GatherND",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:C,dataType:s}],dispatchGroup:{x:Math.ceil(_/64)},programUniforms:h}),getShaderSource:w},{inputs:[n[0],m]})},gO=e=>({batchDims:e.batch_dims,cacheKey:""})}),w2,M2,yO,vO,EU=Ue(()=>{mt(),xt(),wn(),bt(),w2=(e,t)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=Me.normalizeAxis(t.quantizeAxis,e[0].dims.length),r=t.blockSize,s=e[0],i=e[2],o=e.length===4?e[3]:void 0;if(i.dims.length!==s.dims.length||!s.dims.map((a,l)=>l===n?Math.ceil(a/r)===i.dims[l]:a===i.dims[l]).reduce((a,l)=>a&&l,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(o){if(o.dataType!==s.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(o.dims.length!==i.dims.length||!o.dims.map((a,l)=>a===i.dims[l]).reduce((a,l)=>a&&l,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},M2=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n.length,i=Me.normalizeAxis(t.gatherAxis,s),o=Me.normalizeAxis(t.quantizeAxis,s),a=n.slice(0);a.splice(i,1,...r);let l=Me.size(a),u=e[2].dataType,p=e[0].dataType===22,c=[{type:12,data:l},{type:12,data:o},{type:12,data:i},{type:12,data:t.blockSize},...lt(...e.map((f,m)=>f.dims),a)],d=f=>{let m=ke("data",e[0].dataType,e[0].dims.length),y=ke("inputIndices",e[1].dataType,e[1].dims.length),C=ke("scales",e[2].dataType,e[2].dims.length),_=e.length>3?ke("zeroPoint",e[3].dataType,e[3].dims.length):void 0,h=rt("output",u,a.length),w=[m,y,C];_&&w.push(_);let M=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${f.registerUniforms(M).declareVariables(...w,h)}
        ${f.mainStart()}
        let output_indices = ${h.offsetToIndices("global_idx")};
        var indices_indices = ${y.type.indices}(0);
        ${r.length>1?`
          for (var i: u32 = 0; i < ${r.length}; i++) {
            let index = ${h.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${y.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${h.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${m.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${h.indicesGet("output_indices","i")};
          ${m.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${y.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${n[i]};
        }
        ${m.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${a.length}; i++) {
          let index = ${h.indicesGet("output_indices",`i + ${r.length} - 1`)};
          ${m.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${m.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${m.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${p?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${C.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${C.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${C.getByIndices("scale_indices")};
        ${_?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${_.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${_.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${p?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${fr(u)}(quantized_data - zero_point) * scale;
        ${h.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${t.cacheKey};${e.filter((f,m)=>m!==1).map(f=>f.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:e.length},(f,m)=>"rank")},getRunData:()=>({outputs:[{dims:a,dataType:u}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:c}),getShaderSource:d}},yO=(e,t)=>{let n=e.inputs;w2(n,t),e.compute(M2(e.inputs,t))},vO=e=>jt({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})}),x2,b2,wO,MO,PU=Ue(()=>{mt(),xt(),wn(),bt(),x2=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},b2=(e,t)=>{let n=e[0].dims,r=e[0].dataType,s=n.length,i=e[1].dims,o=e[1].dataType,a=Me.normalizeAxis(t.axis,s),l=n[a],u=i.slice(0),p=Me.size(u),c=ke("input",r,s),d=ke("indicesInput",o,i.length),f=rt("output",r,u.length),m=[{type:12,data:p},{type:6,data:l},{type:12,data:a}];return m.push(...lt(n,i,u)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:m}),getShaderSource:y=>`
      ${y.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(c,d,f)}
      ${y.mainStart()}
      ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${f.offsetToIndices("global_idx")};

      var idx = ${d.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${c.type.indices}(outputIndices);
      ${c.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${c.getByIndices("inputIndices")};

      ${f.setByOffset("global_idx","value")};
  }`}},wO=e=>jt({axis:e.axis}),MO=(e,t)=>{let n=e.inputs;x2(n),e.compute(b2(e.inputs,t))}}),T2,E2,xO,bO,SU=Ue(()=>{mt(),xt(),bt(),T2=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},E2=(e,t)=>{let n=e[0].dims.slice(),r=e[1].dims.slice(),[s,i,o]=wA.getShapeOfGemmResult(n,t.transA,r,t.transB,e.length===3?e[2].dims:void 0),a=[s,i];if(!a)throw new Error("Can't use gemm on the given tensors");let l=16,u=Math.ceil(i/l),p=Math.ceil(s/l),c=!0,d=Me.size(a),f=[{type:12,data:c?u:d},{type:12,data:s},{type:12,data:i},{type:12,data:o},{type:1,data:t.alpha},{type:1,data:t.beta}],m=["type","type"];e.length===3&&(f.push(...lt(e[2].dims)),m.push("rank")),f.push(...lt(a));let y=_=>{let h="";t.transA&&t.transB?h="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":t.transA&&!t.transB?h="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!t.transA&&t.transB?h="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!t.transA&&!t.transB&&(h="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let w=t.alpha===1?"":"value *= uniforms.alpha;",M=ke("a",e[0].dataType,e[0].dims),x=ke("b",e[1].dataType,e[1].dims),b=M.type.value,T=null,S=[M,x];e.length===3&&(T=ke("c",e[2].dataType,e[2].dims.length),S.push(T));let $=rt("output",e[0].dataType,a.length);S.push($);let O=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${_.registerUniforms(O).declareVariables(...S)}

  ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${b}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${h}
    }

    ${w}
    ${T!=null?`let cOffset = ${T.broadcastedIndicesToOffset("vec2(m, n)",$)}; value += ${b}(uniforms.beta) * ${T.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},C=_=>{let h=ke("a",e[0].dataType,e[0].dims),w=ke("b",e[1].dataType,e[1].dims),M=null,x=[h,w];e.length===3&&(M=ke("c",e[2].dataType,e[2].dims.length),x.push(M));let b=rt("output",e[0].dataType,a.length);x.push(b);let T=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],S="",$="";t.transA&&t.transB?($=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${h.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${w.type.value}(0);
      }
      `,S="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):t.transA&&!t.transB?($=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${h.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${w.type.value}(0);
      }
      `,S="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!t.transA&&t.transB?($=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${h.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${w.type.value}(0);
      }
      `,S="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!t.transA&&!t.transB&&($=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${h.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${w.type.value}(0);
      }
      `,S="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let O=t.alpha===1?"":"value *= uniforms.alpha;";return`
  ${_.registerUniforms(T).declareVariables(...x)}
  var<workgroup> tile_a: array<array<${h.type.storage}, ${l}>, ${l}>;
  var<workgroup> tile_b: array<array<${w.type.storage}, ${l}>, ${l}>;
  ${_.mainStart([l,l,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${l};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${l};
    let num_tiles = (uniforms.K - 1) / ${l} + 1;
    var k_start = 0u;
    var value = ${b.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${$}
      k_start = k_start + ${l};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${l}; k++) {
        ${S}
      }
      workgroupBarrier();
    }

    ${O}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${M!=null?`let cOffset = ${M.broadcastedIndicesToOffset("vec2(m, n)",b)}; value += ${b.type.value}(uniforms.beta) * ${M.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return c?{name:"GemmShared",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:u*p},programUniforms:f}),getShaderSource:C}:{name:"Gemm",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:f}),getShaderSource:y}},xO=e=>{let t=e.transA,n=e.transB,r=e.alpha,s=e.beta;return{transA:t,transB:n,alpha:r,beta:s,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},bO=(e,t)=>{T2(e.inputs),e.compute(E2(e.inputs,t))}}),Ws,ni,Lo,zo,P2,S2,C2,k2,$2,I2,A2,D2,TO,EO,CU=Ue(()=>{mt(),xt(),wn(),bt(),[Ws,ni,Lo,zo]=[0,1,2,3],P2=e=>{if(e[0].dims.length!==4)throw new Error("only 4-D tensor is supported.");if(e[0].dims.length!==e[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${e[0].dims.length-2}`);if(e[0].dims[0]!==e[1].dims[0])throw new Error("grid batch size must match input batch size")},S2=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,C2=e=>`
  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,k2=e=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${e.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,$2=e=>`
  ${e.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,I2=(e,t,n)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {
     var pixel = ${t}(0);
     var indices = vec4<u32>(0);
     indices[${Ws}] = batch;
     indices[${ni}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${Lo}] = u32(r);
            indices[${zo}] = u32(c);
          } else {
            return ${t}(0);
          }
        `;case"border":return`
          indices[${Lo}] = u32(clamp(r, 0, H - 1));
          indices[${zo}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${Lo}] = gs_reflect(r, border[1], border[3]);
          indices[${zo}] = gs_reflect(c, border[0], border[2]);
        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`
    return ${e.getByIndices("indices")};
  }
`,A2=(e,t,n)=>(()=>{switch(n.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${Ws}], indices[${ni}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${Ws}], indices[${ni}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${Ws}], indices[${ni}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${Ws}], indices[${ni}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${Ws}], indices[${ni}], border);

          let dx2 = ${t}(f32(x2) - x);
          let dx1 = ${t}(x - f32(x1));
          let dy2 = ${t}(f32(y2) - y);
          let dy1 = ${t}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${t}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${Ws}], indices[${ni}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${e.setByOffset("global_idx","result")}`,D2=(e,t)=>{let n=ke("x",e[0].dataType,e[0].dims.length),r=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],s=ke("grid",e[1].dataType,r.length,2),i=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];t.format==="NHWC"&&(i=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[Ws,ni,Lo,zo]=[0,3,1,2]);let o=rt("output",e[0].dataType,i.length),a=n.type.value,l=Me.size(i),u=[{type:12,data:l},...lt(e[0].dims,r,i)],p=c=>`
  ${c.registerUniform("output_size","u32").declareVariables(n,s,o)}
  ${S2}
  ${C2(a)}
  ${k2(t)}
  ${$2(t)}
  ${I2(n,a,t)}

  ${c.mainStart()}
    ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${Lo}]);
      let W_in = i32(uniforms.x_shape[${zo}]);

      ${t.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${o.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${Ws}], indices[${Lo}], indices[${zo}]);
      let nxy = ${s.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${A2(o,a,t)}
  }`;return{name:"GridSample",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:["type","type"]},getRunData:c=>{let d=Me.size(i);return{outputs:[{dims:i,dataType:c[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:u}},getShaderSource:p}},TO=(e,t)=>{P2(e.inputs),e.compute(D2(e.inputs,t))},EO=e=>jt({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})}),yr,O2,PO,a_,F2,Pu,SO,CO=Ue(()=>{mt(),xt(),wn(),Oy(),zy(),bt(),lo(),yr=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,O2=(e,t)=>{let n=e[0],r=yr(e,1),s=yr(e,2),i=yr(e,3),o=yr(e,4),a=yr(e,5),l=yr(e,6),u=yr(e,7);if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let p=n.dims[0],c=n.dims[1],d=n.dims.length===3?n.dims[2]:t.numHeads*n.dims[4],f=c,m=0,y=0,C=Math.floor(d/t.numHeads);if(l&&u&&Me.size(l.dims)&&Me.size(u.dims)){if(l.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(l.dims[0]!==p||l.dims[1]!==t.numHeads||l.dims[3]!==C)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(u.dims[0]!==p||u.dims[1]!==t.numHeads||u.dims[3]!==C)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[2]!==u.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(u.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');m=l.dims[2],y=l.dims[2]}else if(l&&Me.size(l.dims)||u&&Me.size(u.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let _;if(r&&Me.size(r.dims)>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(r.dims.length===3){if(r.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');_=2,f=r.dims[1]}else if(r.dims.length===5){if(r.dims[2]!==t.numHeads||r.dims[3]!==2||r.dims[4]!==C)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(s)throw new Error('Expect "value" be none when "key" has packed kv format.');_=5,f=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==C)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');_=0,f=r.dims[2]}}else{if(n.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==t.numHeads||n.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');_=3}if(i&&Me.size(i.dims)>0){if(i.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(r&&r.dims.length===5&&r.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let h=m+f,w=0;if(o&&Me.size(o.dims)>0){w=8;let T=o.dims;throw T.length===1?T[0]===p?w=1:T[0]===3*p+2&&(w=3):T.length===2&&T[0]===p&&T[1]===h&&(w=5),w===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let M=!1,x=d;if(s&&Me.size(s.dims)>0){if(s.dims.length!==3&&s.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==s.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(s.dims.length===3){if(f!==s.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');x=s.dims[2]}else{if(f!==s.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');x=s.dims[1]*s.dims[3],M=!0}}let b=!1;if(o&&Me.size(o.dims)>0)throw new Error("Key padding mask is not supported");if(a&&Me.size(a.dims)>0){if(a.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(a.dims[0]!==p||a.dims[1]!==t.numHeads||a.dims[2]!==c||a.dims[3]!==h)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:p,sequenceLength:c,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:h,maxSequenceLength:y,inputHiddenSize:0,hiddenSize:d,vHiddenSize:x,headSize:C,vHeadSize:Math.floor(x/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:w,scale:t.scale,broadcastResPosBias:b,passPastInKv:M,qkvFormat:_}},PO=e=>jt({...e}),a_=jt({perm:[0,2,1,3]}),F2=(e,t,n,r,s,i,o)=>{let a=[r,s,i],l=Me.size(a),u=[{type:12,data:l},{type:12,data:o},{type:12,data:i}],p=c=>{let d=rt("qkv_with_bias",t.dataType,a),f=ke("qkv",t.dataType,a),m=ke("bias",n.dataType,a),y=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${c.registerUniforms(y).declareVariables(f,m,d)}
  ${c.mainStart()}
    ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u}),getShaderSource:p},{inputs:[t,n],outputs:[-1]})[0]},Pu=(e,t,n,r,s,i,o,a)=>{let l=i;if(o&&Me.size(o.dims)>0){if(r===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return l=F2(e,i,o,t,r,n*s,a),l=l.reshape([t,r,n,s]),n===1||r===1?l:e.compute(Hr(l,a_.perm),{inputs:[l],outputs:[-1]})[0]}else return i.dims.length===3&&(l=i.reshape([t,r,n,s])),n===1||r===1?l:e.compute(Hr(l,a_.perm),{inputs:[l],outputs:[-1]})[0]},SO=(e,t)=>{let n=O2(e.inputs,t),r=e.inputs[0],s=yr(e.inputs,1),i=yr(e.inputs,2),o=yr(e.inputs,3),a=yr(e.inputs,4),l=yr(e.inputs,5),u=yr(e.inputs,6),p=yr(e.inputs,7);if(r.dims.length===5)throw new Error("Packed QKV is not implemented");if((s==null?void 0:s.dims.length)===5)throw new Error("Packed KV is not implemented");let c=s&&i&&s.dims.length===4&&i.dims.length===4,d=Pu(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,r,o,0);if(c)return dc(e,d,s,i,a,void 0,u,p,l,n);if(!s||!i)throw new Error("key and value must be provided");let f=Pu(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,s,o,n.hiddenSize),m=Pu(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,i,o,2*n.hiddenSize);dc(e,d,f,m,a,void 0,u,p,l,n)}}),L2,z2,R2,B2,Jg,kO,$O,IO=Ue(()=>{mt(),xt(),wn(),bt(),L2=e=>{if(!e||e.length<1)throw new Error("too few inputs")},z2=(e,t)=>{let n=[],r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(s=>n.push(Number(s))),r=n.length),jt({numOutputs:r,axis:t.axis,splitSizes:n})},R2=e=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
    if (index < ${at("uniforms.size_in_split_axis","i",e)}) {
        return i;
    }
    }
    return ${e}u;
}`,B2=e=>{let t=e.length,n=[];for(let r=0;r<t;++r){let s=e[r].setByIndices("indices","input[global_idx]");t===1?n.push(s):r===0?n.push(`if (output_number == ${r}u) { ${s} }`):r===t-1?n.push(`else { ${s} }`):n.push(`else if (output_number == ${r}) { ${s} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {
        ${n.join(`
`)}
      }`},Jg=(e,t)=>{let n=e[0].dims,r=Me.size(n),s=e[0].dataType,i=Me.normalizeAxis(t.axis,n.length),o=new Array(t.numOutputs),a=ke("input",s,n.length),l=new Array(t.numOutputs),u=[],p=[],c=0,d=[{type:12,data:r}];for(let m=0;m<t.numOutputs;m++){c+=t.splitSizes[m],l[m]=c;let y=n.slice();y[i]=t.splitSizes[m],p.push(y),o[m]=rt(`output${m}`,s,y.length),u.push({dims:p[m],dataType:e[0].dataType})}d.push({type:12,data:l},...lt(n,...p));let f=m=>`
  ${m.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",l.length).declareVariables(a,...o)}
  ${R2(l.length)}
  ${B2(o)}

  ${m.mainStart()}
    ${m.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${a.offsetToIndices("global_idx")};
    var index = ${a.indicesGet("indices",i)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${at("uniforms.size_in_split_axis","output_number - 1u",l.length)};
      ${a.indicesSet("indices",i,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:f,getRunData:()=>({outputs:u,dispatchGroup:{x:Math.ceil(r/64)},programUniforms:d})}},kO=(e,t)=>{L2(e.inputs);let n=e.inputs.length===1?t:z2(e.inputs,t);e.compute(Jg(e.inputs,n),{inputs:[0]})},$O=e=>{let t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return jt({axis:t,numOutputs:r,splitSizes:n})}}),N2,lf,AO,DO=Ue(()=>{mt(),xt(),wn(),bt(),N2=(e,t)=>{let[n,r,s,i]=e,{numHeads:o,rotaryEmbeddingDim:a}=t;if(n.dims.length!==3&&n.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!Me.areEqual(r.dims,[])&&!Me.areEqual(r.dims,[1])&&r.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${r.dims.length}`);if(s.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${s.dims.length}`);if(i.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${i.dims.length}`);if(!Me.areEqual(s.dims,i.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(a>0&&o===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let l=n.dims[0],u=n.dims[n.dims.length-2],p=s.dims[0],c=Me.sizeFromDimension(n.dims,1)/u,d=a===0?s.dims[1]*2:c/o;if(a>d)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(r.dims.length===2){if(l!==r.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${r.dims[0]}`);if(u!==r.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${r.dims[1]}`)}if(d/2!==s.dims[1]&&a/2!==s.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${s.dims[1]}`);if(u>p)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},lf=(e,t)=>{let{interleaved:n,numHeads:r,rotaryEmbeddingDim:s,scale:i}=t,o=e[0].dims[0],a=Me.sizeFromDimension(e[0].dims,1),l=e[0].dims[e[0].dims.length-2],u=a/l,p=e[2].dims[1],c=s===0?p*2:u/r,d=new Array(o,l,u/c,c-p),f=Me.computeStrides(d),m=[{type:1,data:i},{type:12,data:d},{type:12,data:f},...e[0].dims.length===3?new Array({type:12,data:[a,u,c,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[a,c,l*c,1]}):[],...lt(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],y=C=>{let _=ke("input",e[0].dataType,e[0].dims.length),h=ke("position_ids",e[1].dataType,e[1].dims.length),w=ke("cos_cache",e[2].dataType,e[2].dims.length),M=ke("sin_cache",e[3].dataType,e[3].dims.length),x=rt("output",e[0].dataType,e[0].dims.length);return C.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:d.length},{name:"global_strides",type:"u32",length:f.length},{name:"input_output_strides",type:"u32",length:f.length}]),`
        ${C.declareVariables(_,h,w,M,x)}

        ${C.mainStart(vl)}
          let half_rotary_emb_dim = uniforms.${w.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${C.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${h.broadcastedIndicesToOffset("bsnh.xy",rt("",h.type.tensor,2))};
            let position_id =
                u32(${h.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});
            let j = i + select(half_rotary_emb_dim, 1, ${n});
            let re = ${_.getByOffset("i")} * ${w.get("position_id","bsnh[3]")} -
                ${_.getByOffset("j")} * ${M.get("position_id","bsnh[3]")};
            ${x.setByOffset("i","re")}
            let im = ${_.getByOffset("i")} * ${M.get("position_id","bsnh[3]")} +
                ${_.getByOffset("j")} * ${w.get("position_id","bsnh[3]")};
            ${x.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${x.setByOffset("k",_.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:jt({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:y,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Me.size(d)/vl)},programUniforms:m})}},AO=(e,t)=>{N2(e.inputs,t),e.compute(lf(e.inputs,t))}}),j2,V2,l_,U2,OO,kU=Ue(()=>{wn(),mt(),zy(),CO(),IO(),lo(),DO(),bt(),j2=(e,t)=>{if(t.doRotary&&e.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=e[0],r=e[1],s=e[2],i=e[3],o=e[4];if(t.doRotary!==0&&e.length<=7)throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(t.localWindowSize!==-1)throw new Error("Local attention is not supported");if(t.softcap!==0)throw new Error("Softcap is not supported");if(t.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(t.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let a=!1,l=n.dims[0],u=n.dims[1],p=n.dims.length===3?a?n.dims[2]/3:n.dims[2]:t.numHeads*n.dims[4],c=u,d=0,f=!r||r.dims.length===0,m=Math.floor(f?p/(t.numHeads+2*t.kvNumHeads):p/t.numHeads);f&&(p=m*t.numHeads);let y=i&&i.dims.length!==0,C=o&&o.dims.length!==0;if(y&&i.dims.length===4&&i.dims[0]===l&&i.dims[1]!==t.kvNumHeads&&i.dims[2]===t.kvNumHeads&&i.dims[3]===m)throw new Error("BSNH pastKey/pastValue is not supported");if(y&&C){if(i.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(o.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');d=i.dims[2]}else if(y||C)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let _=1;if(r&&r.dims.length>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(r.dims.length===3){if(n.dims[2]%r.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');c=r.dims[1]}else if(r.dims.length===5){if(r.dims[2]!==t.numHeads||r.dims[3]!==2||r.dims[4]!==m)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(s)throw new Error('Expect "value" be none when "key" has packed kv format.');c=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==m)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');c=r.dims[2]}}else{if(n.dims.length!==3&&n.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(n.dims.length===5&&(n.dims[2]!==t.numHeads||n.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');_=3}let h=0,w=!1,M=t.kvNumHeads?m*t.kvNumHeads:p;if(s&&s.dims.length>0){if(s.dims.length!==3&&s.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==s.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(s.dims.length===3){if(c!==s.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');M=s.dims[2]}else{if(c!==s.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');M=s.dims[1]*s.dims[3],w=!0}}let x=e.length>4?e[5]:void 0;if(x&&x.dims.length!==1&&x.dims[0]!==l)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:l,sequenceLength:u,pastSequenceLength:d,kvSequenceLength:c,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:p,vHiddenSize:M,headSize:m,vHeadSize:Math.floor(M/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:h,scale:t.scale,broadcastResPosBias:!1,passPastInKv:w,qkvFormat:_}},V2=jt({perm:[0,2,1,3]}),l_=(e,t,n)=>{let r=t,s=n.kvNumHeads;return t.dims.length===3&&n.kvSequenceLength!==0&&(r=t.reshape([n.batchSize,n.kvSequenceLength,s,n.headSize]),r=e.compute(Hr(r,V2.perm),{inputs:[r],outputs:[-1]})[0]),r},U2=(e,t,n,r)=>{let s=7,i=["type","type"],o=[e*t],a=e*t,l=[{type:12,data:a},{type:12,data:t},{type:12,data:e}],u=p=>{let c=ke("seq_lens",n.dataType,n.dims),d=ke("total_seq_lens",r.dataType,r.dims),f=rt("pos_ids",s,o),m=[{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}];return`
  ${p.registerUniforms(m).declareVariables(c,d,f)}
  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${d.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${c.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${f.setByOffset("global_idx","pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${f.setByOffset("global_idx","pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${f.setByOffset("global_idx","seqlen")}
    };
  }
  `};return{name:"GeneratePositionIds",shaderCache:{hint:`${e};${t}`,inputDependencies:i},getRunData:()=>({outputs:[{dims:o,dataType:s}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:l}),getShaderSource:u}},OO=(e,t)=>{var M;let n=j2(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(((M=e.inputs[1])==null?void 0:M.dims.length)===5)throw new Error("Packed KV is not implemented");let r=e.inputs[0],s=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,i=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,o=e.inputs[3]&&e.inputs[3].dims.length!==0?e.inputs[3]:void 0,a=e.inputs[4]&&e.inputs[4].dims.length!==0?e.inputs[4]:void 0,l=e.inputs.length>4?e.inputs[5]:void 0,u=e.inputs.length>5?e.inputs[6]:void 0,p=n.kvNumHeads?n.kvNumHeads:n.numHeads,c=jt({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,p*n.headSize,p*n.headSize]}),[d,f,m]=!s&&!i?e.compute(Jg([r],c),{inputs:[r],outputs:[-1,-1,-1]}):[r,s,i],y,C;if(t.doRotary){let x=e.compute(U2(n.batchSize,n.sequenceLength,l,u),{inputs:[l,u],outputs:[-1]})[0],b=e.inputs[7],T=e.inputs[8],S=jt({interleaved:t.rotaryInterleaved!==0,numHeads:n.numHeads,rotaryEmbeddingDim:0,scale:t.scale}),$=[d,x,b,T],O=[-1];y=e.compute(lf($,S),{inputs:$,outputs:O})[0],$.splice(0,1,f);let G=jt({interleaved:t.rotaryInterleaved!==0,numHeads:n.kvNumHeads,rotaryEmbeddingDim:0,scale:t.scale});C=e.compute(lf($,G),{inputs:$,outputs:O})[0]}let _=Pu(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,t.doRotary?y:d,void 0,0),h=l_(e,t.doRotary?C:f,n),w=l_(e,m,n);dc(e,_,h,w,void 0,void 0,o,a,void 0,n,l,u)}}),u_,W2,G2,FO,$U=Ue(()=>{mt(),xt(),lo(),bt(),u_=(e,t,n,r,s,i,o,a)=>{let l=pn(i),u=l===1?"f32":`vec${l}f`,p=l===1?"vec2f":`mat2x${l}f`,c=s*o,d=64;c===1&&(d=256);let f=[s,o,i/l],m=[s,o,2],y=["rank","type","type"],C=[];C.push(...lt(f,m));let _=h=>{let w=ke("x",t.dataType,3,l),M=ke("scale",n.dataType,n.dims),x=ke("bias",r.dataType,r.dims),b=rt("output",1,3,2),T=[w,M,x,b];return`
  var<workgroup> workgroup_shared : array<${p}, ${d}>;
  const workgroup_size = ${d}u;
  ${h.declareVariables(...T)}
  ${h.mainStart(d)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${u}(0);
    var squared_sum = ${u}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${u}(${w.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${p}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${ro("workgroup_shared[0][0]",l)} / f32(hight * ${l});
      let squared_sum_final = ${ro("workgroup_shared[0][1]",l)} / f32(hight * ${l});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${a}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${l};${a};${d}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:m,dataType:1}],dispatchGroup:{x:c},programUniforms:C}),getShaderSource:_},{inputs:[t,n,r],outputs:[-1]})[0]},W2=(e,t,n)=>{let r=t[0].dims,s=r,i=2,o=r[0],a=r[1],l=Me.sizeFromDimension(r,i),u=pn(l),p=Me.size(s)/u,c=u_(e,t[0],t[1],t[2],o,l,a,n.epsilon),d=[o,a,l/u],f=[o,a],m=["type","none"],y=C=>{let _=ke("x",t[0].dataType,d.length,u),h=ke("scale_shift",1,f.length,2),w=rt("output",t[0].dataType,d.length,u),M=[_,h,w];return`
  ${C.registerUniform("output_size","u32").declareVariables(...M)}
  ${C.mainStart()}
  ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${w.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${h.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${_.getByOffset("global_idx")} * ${w.type.value}(scale_shift.x) + ${w.type.value}(scale_shift.y);
      ${w.setByOffset("global_idx","value")};
  }`};e.compute({name:"InstanceNormalization",shaderCache:{hint:`${u}`,inputDependencies:m},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:[{type:12,data:p},...lt(d,f,d)]}),getShaderSource:y},{inputs:[t[0],c]})},G2=(e,t,n)=>{let r=t[0].dims,s=r,i=r[0],o=r[r.length-1],a=Me.sizeFromDimension(r,1)/o,l=pn(o),u=Me.size(s)/l,p=[{type:12,data:a},{type:12,data:Math.floor(o/l)}],c=["type","type"],d=!1,f=[0,r.length-1];for(let _=0;_<r.length-2;_++)d=d||r[_+1]!==1,f.push(_+1);d=d&&r[r.length-1]!==1;let m=d?e.compute(Hr(e.inputs[0],f),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:r.length},(_,h)=>r[f[h]])),y=u_(e,m,t[1],t[2],i,a,o,n.epsilon),C=_=>{let h=Kn(t[0].dataType),w=l===1?"vec2f":`mat${l}x2f`,M=T=>{let S=T===0?"x":"y",$=l===1?"f32":`vec${l}f`;switch(l){case 1:return`${h}(${$}(scale.${S}))`;case 2:return`vec2<${h}>(${$}(scale[0].${S}, scale[1].${S}))`;case 4:return`vec4<${h}>(${$}(scale[0].${S}, scale[1].${S}, scale[2].${S}, scale[3].${S}))`;default:throw new Error(`Not supported compoents ${l}`)}},x=ke("input",t[0].dataType,t[0].dims,l),b=rt("output",t[0].dataType,s,l);return`
  @group(0) @binding(0) var<storage, read> input : array<${x.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${w}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${b.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${_.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${M(0)}, ${M(1)});
  }`};e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${l}`,inputDependencies:c},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:p}),getShaderSource:C},{inputs:[t[0],y]})},FO=(e,t)=>{t.format==="NHWC"?G2(e,e.inputs,t):W2(e,e.inputs,t)}}),H2,K2,LO,IU=Ue(()=>{mt(),xt(),bt(),H2=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},K2=(e,t,n)=>{let r=t.simplified,s=e[0].dims,i=e[1],o=!r&&e[2],a=s,l=Me.normalizeAxis(t.axis,s.length),u=Me.sizeToDimension(s,l),p=Me.sizeFromDimension(s,l),c=Me.size(i.dims),d=o?Me.size(o.dims):0;if(c!==p||o&&d!==p)throw new Error(`Size of X.shape()[axis:] == ${p}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${c} and bias size of ${d}`);let f=[];for(let x=0;x<s.length;++x)x<l?f.push(s[x]):f.push(1);let m=pn(p),y=["type","type"],C=[{type:12,data:u},{type:1,data:p},{type:12,data:Math.floor(p/m)},{type:1,data:t.epsilon}];o&&y.push("type");let _=n>1,h=n>2,w=x=>{let b=Kn(e[0].dataType),T=[ke("x",e[0].dataType,e[0].dims,m),ke("scale",i.dataType,i.dims,m)];o&&T.push(ke("bias",o.dataType,o.dims,m)),T.push(rt("output",e[0].dataType,a,m)),_&&T.push(rt("mean_data_output",1,f)),h&&T.push(rt("inv_std_output",1,f));let S=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${x.registerUniforms(S).declareVariables(...T)}
  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${Ug("f32",m)};
    var mean_square_vector = ${Ug("f32",m)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${nl(b,m,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${ro("mean_vector",m)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${ro("mean_square_vector",m)} / uniforms.norm_size ${r?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${nl(b,m,"x[j + offset]")};
      let f32scale = ${nl(b,m,"scale[j]")};
      output[j + offset] = ${T[0].type.value}((f32input ${r?"":"- mean"}) * inv_std_dev * f32scale
        ${o?`+ ${nl(b,m,"bias[j]")}`:""}
      );
    }

    ${_?"mean_data_output[global_idx] = mean":""};
    ${h?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},M=[{dims:a,dataType:e[0].dataType}];return _&&M.push({dims:f,dataType:1}),h&&M.push({dims:f,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${m};${n};${r}`,inputDependencies:y},getRunData:()=>({outputs:M,dispatchGroup:{x:Math.ceil(u/64)},programUniforms:C}),getShaderSource:w}},LO=(e,t)=>{H2(e.inputs),e.compute(K2(e.inputs,t,e.outputCount))}}),q2,zO,AU=Ue(()=>{xt(),Vy(),Uy(),q2=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},zO=e=>{q2(e.inputs);let t=yl.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");let n=t[t.length-1],r=e.inputs[0].dims[e.inputs[0].dims.length-1];if(n<8&&r<8)e.compute(jy(e.inputs,{activation:""},t));else{let s=t[t.length-2],i=Me.size(e.inputs[0].dims.slice(0,-2)),o=Me.size(e.inputs[1].dims.slice(0,-2));if(i!==1&&s===1&&o===1){let a=e.inputs[0].reshape([1,i,r]),l=e.inputs[1].reshape([1,r,n]),u=[1,i,n],p=[a,l];e.compute(af(p,{activation:""},t,u),{inputs:p})}else e.compute(af(e.inputs,{activation:""},t))}}}),Q2,X2,Y2,RO,BO,DU=Ue(()=>{mt(),xt(),wn(),bt(),Q2=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=e[0],r=n.dims.length;if(n.dims[r-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let s=Math.floor((t.k+t.blockSize-1)/t.blockSize),i=t.blockSize/8*t.bits,o=e[1];if(!Me.areEqual(o.dims,[t.n,s,i]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let a=e[2].dims;if(Me.size(a)!==t.n*s)throw new Error("scales input size error.");if(e.length===4){let l=e[3].dims,u=t.bits>4?t.n*s:t.n*Math.floor((s+1)/2);if(Me.size(l)!==u)throw new Error("zeroPoints input size error.")}},X2=(e,t)=>{let n=e[0].dims,r=n.length,s=n[r-2],i=t.k,o=t.n,a=n.slice(0,r-2),l=Me.size(a),u=e[1].dims[2]/4,p=e[0].dataType,c=pn(t.k),d=pn(u),f=pn(o),m=a.concat([s,o]),y=s>1&&o/f%2===0?2:1,C=Me.size(m)/f/y,_=64,h=[],w=[l,s,i/c],M=Me.convertShape(e[1].dims).slice();M.splice(-1,1,u/d),h.push(...lt(w)),h.push(...lt(M)),h.push(...lt(e[2].dims)),e.length===4&&h.push(...lt(Me.convertShape(e[3].dims)));let x=[l,s,o/f];h.push(...lt(x));let b=T=>{let S=w.length,$=ke("a",e[0].dataType,S,c),O=ke("b",12,M.length,d),G=ke("scales",e[2].dataType,e[2].dims.length),H=[$,O,G],N=e.length===4?ke("zero_points",12,e[3].dims.length):void 0;N&&H.push(N);let J=x.length,q=rt("output",e[0].dataType,J,f),X=Kn(e[0].dataType),Y=(()=>{switch(c){case 1:return`array<${X}, 8>`;case 2:return`mat4x2<${X}>`;case 4:return`mat2x4<${X}>`;default:throw new Error(`${c}-component is not supported.`)}})(),K=()=>{let F=`
          // reuse a data
            var input_offset = ${$.indicesToOffset(`${$.type.indices}(batch, row, word_offset)`)};
            var a_data: ${Y};
            for (var j: u32 = 0; j < ${8/c}; j++) {
              a_data[j] = ${$.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let I=0;I<f*y;I++)F+=`
            b_value = ${d===1?`b${I}_data`:`b${I}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${Y}(${Array.from({length:4},(V,ee)=>`${X}(b_value_lower[${ee}]), ${X}(b_value_upper[${ee}])`).join(", ")});
            b_dequantized_values = ${c===1?`${Y}(${Array.from({length:8},(V,ee)=>`(b_quantized_values[${ee}] - ${N?`zero_point${I}`:"zero_point"}) * scale${I}`).join(", ")});`:`(b_quantized_values - ${Y}(${Array(8).fill(`${N?`zero_point${I}`:"zero_point"}`).join(",")})) * scale${I};`};
            workgroup_shared[local_id.x * ${y} + ${Math.floor(I/f)}]${f>1?`[${I%f}]`:""} += ${Array.from({length:8/c},(V,ee)=>`${c===1?`a_data[${ee}] * b_dequantized_values[${ee}]`:`dot(a_data[${ee}], b_dequantized_values[${ee}])`}`).join(" + ")};
          `;return F},oe=()=>{let F=`
            var col_index = col * ${f};
            ${N?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${X}(8);`}
            `;for(let I=0;I<f*y;I++)F+=`
            let scale${I} = ${G.getByOffset("col_index * nBlocksPerCol + block")};
            ${N?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${N.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${I} = ${X}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return F},se=()=>{let F=`col_index = col * ${f};`;for(let I=0;I<f*y;I++)F+=`
            let b${I}_data = ${O.getByIndices(`${O.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return F+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${Y};
            var b_dequantized_values: ${Y};`,F};return`
        var<workgroup> workgroup_shared: array<${q.type.value}, ${y*_}>;
        ${T.declareVariables(...H,q)}
        ${T.mainStart([_,1,1])}
          let output_indices = ${q.offsetToIndices(`(global_idx / ${_}) * ${y}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${_}) {
            //process one block
            var word_offset: u32 = block * ${t.blockSize/c};
            ${oe()}
            for (var word: u32 = 0; word < ${u}; word += ${d}) {
              ${se()}
              for (var i: u32 = 0; i < ${d}; i++) {
                ${K()}
                word_offset += ${8/c};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${y}) {
            var output_value: ${q.type.value} = ${q.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${_}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${y};
            }
            ${q.setByIndices(`${q.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${t.blockSize};${t.bits};${c};${d};${f};${y};${_}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:m,dataType:p}],dispatchGroup:{x:C},programUniforms:h}),getShaderSource:b}},Y2=(e,t)=>{let n=e[0].dims,r=n.length,s=n[r-2],i=t.k,o=t.n,a=n.slice(0,r-2),l=Me.size(a),u=e[1].dims[2]/4,p=e[0].dataType,c=pn(t.k),d=pn(u),f=a.concat([s,o]),m=128,y=o%8===0?8:o%4===0?4:1,C=m/y,_=C*d*8,h=_/c,w=_/t.blockSize,M=Me.size(f)/y,x=[],b=[l,s,i/c],T=Me.convertShape(e[1].dims).slice();T.splice(-1,1,u/d),x.push(...lt(b)),x.push(...lt(T)),x.push(...lt(e[2].dims)),e.length===4&&x.push(...lt(Me.convertShape(e[3].dims)));let S=[l,s,o];x.push(...lt(S));let $=O=>{let G=b.length,H=ke("a",e[0].dataType,G,c),N=ke("b",12,T.length,d),J=ke("scales",e[2].dataType,e[2].dims.length),q=[H,N,J],X=e.length===4?ke("zero_points",12,e[3].dims.length):void 0;X&&q.push(X);let Y=S.length,K=rt("output",e[0].dataType,Y),oe=Kn(e[0].dataType),se=()=>{switch(c){case 1:return`
          let a_data0 = vec4<${oe}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${oe}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${oe}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${oe}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${c}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${H.type.value}, ${h}>;
        var<workgroup> inter_results: array<array<${K.type.value}, ${C}>, ${y}>;
        ${O.declareVariables(...q,K)}
        ${O.mainStart([C,y,1])}
          let output_indices = ${K.offsetToIndices(`workgroup_index * ${y}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${w} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${h};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${h}; a_offset += ${m})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${H.getByIndices(`${H.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${H.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${w} + local_id.x;
            ${X?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${X.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${oe}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${oe}(8);`}
            let scale = ${J.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${N.getByIndices(`${N.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${t.blockSize/c};
            for (var i: u32 = 0; i < ${d}; i++) {
              ${se()}
              let b_value = ${d===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${oe}>(${Array.from({length:4},(F,I)=>`${oe}(b_value_lower[${I}]), ${oe}(b_value_upper[${I}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${oe}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(F,I)=>`${`dot(a_data${I}, b_dequantized_values[${I}])`}`).join(" + ")};
              word_offset += ${8/c};
            }
            workgroupBarrier();
          }

          if (local_idx < ${y}) {
            var output_value: ${K.type.value} = ${K.type.value}(0);
            for (var b = 0u; b < ${C}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${K.setByIndices(`${K.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${t.blockSize};${c};${d};${C};${y}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:f,dataType:p}],dispatchGroup:{x:M},programUniforms:x}),getShaderSource:$}},RO=(e,t)=>{Q2(e.inputs,t),t.blockSize===32&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(Y2(e.inputs,t)):e.compute(X2(e.inputs,t))},BO=e=>jt(e)}),J2,Z2,eS,tS,nS,rS,sS,iS,NO,OU=Ue(()=>{mt(),xt(),bt(),J2=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Z2=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`
            k = i32(${e.indicesGet("indices",s)}) - ${at("uniforms.pads",s,n)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${at("uniforms.x_shape",s,t)})) {
              break;
            }
            offset += k * i32(${at("uniforms.x_strides",s,t)});
        `;return`
          value = ${e.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${r}
            value = x[offset];
          }
      `},eS=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`
                k = i32(${e.indicesGet("indices",s)}) - ${at("uniforms.pads",s,n)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${at("uniforms.x_shape",s,t)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${at("uniforms.x_shape",s,t)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${at("uniforms.x_strides",s,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${r}
              value = x[offset];
          `},tS=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`
                k = i32(${e.indicesGet("indices",s)}) - ${at("uniforms.pads",s,n)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${at("uniforms.x_shape",s,t)})) {
                  k = i32(${at("uniforms.x_shape",s,t)}) - 1;
                }
                offset += k * i32(${at("uniforms.x_strides",s,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${r}
              value = x[offset];
          `},nS=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`
                k = i32(${e.indicesGet("indices",s)}) - ${at("uniforms.pads",s,n)};
                if (k < 0)  {
                  k += i32(${at("uniforms.x_shape",s,t)}]);
                }
                if (k >= i32(${at("uniforms.x_shape",s,t)})) {
                  k -= i32(${at("uniforms.x_shape",s,t)});
                }
                offset += k * i32(${at("uniforms.x_strides",s,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${r}
              value = x[offset];
          `},rS=(e,t,n)=>{switch(n.mode){case 0:return Z2(e,t,n.pads.length);case 1:return eS(e,t,n.pads.length);case 2:return tS(e,t,n.pads.length);case 3:return nS(e,t,n.pads.length);default:throw new Error("Invalid mode")}},sS=(e,t)=>{let n=Me.padShape(e[0].dims.slice(),t.pads),r=e[0].dims,s=Me.size(n),i=[{type:12,data:s},{type:6,data:t.pads}],o=e.length>=3&&e[2].data;t.mode===0&&i.push({type:o?e[2].dataType:1,data:t.value}),i.push(...lt(e[0].dims,n));let a=["rank"],l=u=>{let p=rt("output",e[0].dataType,n.length),c=ke("x",e[0].dataType,r.length),d=c.type.value,f=rS(p,r.length,t),m=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return t.mode===0&&m.push({name:"constant_value",type:o?d:"f32"}),`
            ${u.registerUniforms(m).declareVariables(c,p)}
            ${u.mainStart()}
            ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${p.offsetToIndices("global_idx")};

            var value = ${d}(0);
            ${f}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${t.mode}${o}`,inputDependencies:a},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Me.size(n)/64)},programUniforms:i}),getShaderSource:l}},iS=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),r=e.length>=3&&e[2].data?e[2].dataType===10?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,s=e[0].dims.length,i=new Int32Array(2*s).fill(0);if(e.length>=4){let a=e[3].getBigInt64Array();for(let l=0;l<a.length;l++)i[Number(a[l])]=Number(n[l]),i[Number(a[l])+s]=Number(n[l+a.length])}else n.forEach((a,l)=>i[Number(l)]=Number(a));let o=[];return i.forEach(a=>o.push(a)),{mode:t.mode,value:r,pads:o}}else return t},NO=(e,t)=>{J2(e.inputs);let n=iS(e.inputs,t);e.compute(sS(e.inputs,n),{inputs:[0]})}}),hu,c_,d_,p_,f_,oS,aS,h_,m_,jO,VO,__,UO,WO,g_,GO,HO,KO,qO,FU=Ue(()=>{Rs(),mt(),xt(),bt(),hu=e=>{if(Zt.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},c_=(e,t,n)=>{let r=t.format==="NHWC",s=e.dims.slice();r&&s.splice(1,0,s.pop());let i=Object.hasOwnProperty.call(t,"dilations"),o=t.kernelShape.slice(),a=t.strides.slice(),l=i?t.dilations.slice():[],u=t.pads.slice();sf.adjustPoolAttributes(n,s,o,a,l,u);let p=sf.computePoolOutputShape(n,s,a,l,o,u,t.autoPad),c=Object.assign({},t);i?Object.assign(c,{kernelShape:o,strides:a,pads:u,dilations:l,cacheKey:t.cacheKey}):Object.assign(c,{kernelShape:o,strides:a,pads:u,cacheKey:t.cacheKey});let d=p.slice();return d.push(d.splice(1,1)[0]),[c,r?d:p]},d_=(e,t)=>{let n=t.format==="NHWC",r=Me.size(e),s=Me.size(t.kernelShape),i=[{type:12,data:r},{type:12,data:s}],o=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let a=t.kernelShape[t.kernelShape.length-1],l=t.strides[t.strides.length-1],u=t.pads[t.pads.length/2-1],p=t.pads[t.pads.length-1],c=!!(u+p);i.push({type:12,data:a},{type:12,data:l},{type:12,data:u},{type:12,data:p}),o.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let d=!1;if(t.kernelShape.length===2){let f=t.kernelShape[t.kernelShape.length-2],m=t.strides[t.strides.length-2],y=t.pads[t.pads.length/2-2],C=t.pads[t.pads.length-2];d=!!(y+C),i.push({type:12,data:f},{type:12,data:m},{type:12,data:y},{type:12,data:C}),o.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[i,o,!0,c,d]}else{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let a=Me.computeStrides(t.kernelShape);i.push({type:12,data:a},{type:12,data:t.pads},{type:12,data:t.strides}),o.push({name:"kernelStrides",type:"u32",length:a.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let l=t.pads.reduce((u,p)=>u+p);return[i,o,!!l,!1,!1]}},p_=(e,t,n,r,s,i,o,a,l,u,p,c)=>{let d=s.format==="NHWC",f=t.type.value,m=rt("output",t.type.tensor,r);if(s.kernelShape.length<=2){let y="",C="",_="",h=n-(d?2:1);if(p?y=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${h}] = indices[${h}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${h}] < 0 || xIndices[${h}]
                      >= uniforms.x_shape[${h}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${i}
                }`:y=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${h}] = indices[${h}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${i}
                }`,s.kernelShape.length===2){let w=n-(d?3:2);c?C=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${w}] = indices[${w}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${w}] < 0 || xIndices[${w}] >= uniforms.x_shape[${w}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:C=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${w}] = indices[${w}] * uniforms.sh - uniforms.phStart + j;
                `,_=`
              }
            `}return`
            ${e.registerUniforms(l).declareVariables(t,m)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${m.offsetToIndices("global_idx")};
              var xIndices = ${m.offsetToIndices("global_idx")};

              var value = ${f}(${a});
              var pad = 0;
              ${C}
              ${y}
              ${_}
              ${o}

              output[global_idx] = value;
            }`}else{if(d)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let y=s.kernelShape.length,C=s.pads.length,_="";return u?_=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${t.indicesToOffset("xIndices")}];
                ${i}
              }`:_=`
              }
              let x_val = x[${t.indicesToOffset("xIndices")}];
              ${i}
            `,`
            ${e.registerUniforms(l).declareVariables(t,m)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${m.offsetToIndices("global_idx")};
              var xIndices = ${m.offsetToIndices("global_idx")};

              var offsets: array<u32, ${y}>;

              var value = ${f}(${a});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${y-1}u; j++) {
                  offsets[j] = offset / ${at("uniforms.kernelStrides","j",y)};
                  offset -= offsets[j] * ${at("uniforms.kernelStrides","j",y)};
                }
                offsets[${y-1}] = offset;

                isPad = false;
                for (var j = ${n-y}u; j < ${n}u; j++) {
                  xIndices[j] = indices[j] * ${at("uniforms.strides",`j - ${n-y}u`,y)}
                    + offsets[j - ${n-y}u] - ${at("uniforms.pads","j - 2u",C)};
                  ${_}
              }
              ${o}

              output[global_idx] = value;
            }`}},f_=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,oS=e=>`${f_(e)};${e.countIncludePad}`,aS=e=>`${f_(e)};${e.storageOrder};${e.dilations}`,h_=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),m_=(e,t,n,r)=>{let[s,i]=c_(t,r,n),o=ke("x",t.dataType,t.dims.length),a=o.type.value,l="value += x_val;",u="";s.countIncludePad?u+=`value /= ${a}(uniforms.kernelSize);`:u+=`value /= ${a}(i32(uniforms.kernelSize) - pad);`;let[p,c,d,f,m]=d_(i,s);p.push(...lt(t.dims,i));let y=["rank"];return{name:e,shaderCache:{hint:`${r.cacheKey};${d};${f};${m}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(Me.size(i)/64)},programUniforms:p}),getShaderSource:C=>p_(C,o,t.dims.length,i.length,s,l,u,0,c,d,f,m)}},jO=e=>{let t=e.count_include_pad!==0,n=h_(e);if(n.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let r={countIncludePad:t,...n,cacheKey:""};return{...r,cacheKey:oS(r)}},VO=(e,t)=>{hu(e.inputs),e.compute(m_("AveragePool",e.inputs[0],!1,t))},__={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},UO=e=>{let t=e.format;return{format:t,...__,cacheKey:t}},WO=(e,t)=>{hu(e.inputs),e.compute(m_("GlobalAveragePool",e.inputs[0],!0,t))},g_=(e,t,n,r)=>{let[s,i]=c_(t,r,n),o=`
      value = max(x_val, value);
    `,a="",l=ke("x",t.dataType,t.dims.length),u=["rank"],[p,c,d,f,m]=d_(i,s);return p.push(...lt(t.dims,i)),{name:e,shaderCache:{hint:`${r.cacheKey};${d};${f};${m}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:i,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(Me.size(i)/64)},programUniforms:p}),getShaderSource:y=>p_(y,l,t.dims.length,i.length,s,o,a,t.dataType===10?-65504:-1e5,c,d,f,m)}},GO=(e,t)=>{hu(e.inputs),e.compute(g_("MaxPool",e.inputs[0],!1,t))},HO=e=>{let t=e.storage_order,n=e.dilations,r=h_(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let s={storageOrder:t,dilations:n,...r,cacheKey:""};return{...s,cacheKey:aS(s)}},KO=e=>{let t=e.format;return{format:t,...__,cacheKey:t}},qO=(e,t)=>{hu(e.inputs),e.compute(g_("GlobalMaxPool",e.inputs[0],!0,t))}}),lS,uS,QO,XO,LU=Ue(()=>{mt(),xt(),wn(),bt(),lS=(e,t)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(e.length===3&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[0].dataType===6&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(e[1].dims.length!==0&&e[1].dims.length!==1&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map((n,r)=>n===e[2].dims[r]).reduce((n,r)=>n&&r,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(t.blockSize>0){if(e[1].dims.length===0||e[1].dims.length===1&&e[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map((s,i)=>i===t.axis||s===e[0].dims[i]).reduce((s,i)=>s&&i,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=e[0].dims[t.axis],r=e[1].dims[t.axis];if(t.blockSize<Math.ceil(n/r)||t.blockSize>Math.ceil(n/(r-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},uS=(e,t)=>{let n=Me.normalizeAxis(t.axis,e[0].dims.length),r=e[0].dataType,s=r===3,i=e[0].dims,o=e[1].dataType,a=Me.size(i),l=r===3||r===2,u=l?[Math.ceil(Me.size(e[0].dims)/4)]:e[0].dims,p=e[1].dims,c=e.length>2?e[2]:void 0,d=c?l?[Math.ceil(Me.size(c.dims)/4)]:c.dims:void 0,f=p.length===0||p.length===1&&p[0]===1,m=f===!1&&p.length===1,y=pn(a),C=f&&(!l||y===4),_=C?y:1,h=C&&!l?y:1,w=ke("input",l?12:r,u.length,h),M=ke("scale",o,p.length),x=c?ke("zero_point",l?12:r,d.length):void 0,b=rt("output",o,i.length,_),T=[w,M];x&&T.push(x);let S=[u,p];c&&S.push(d);let $=[{type:12,data:a/_},{type:12,data:n},{type:12,data:t.blockSize},...lt(...S,i)],O=G=>{let H=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${G.registerUniforms(H).declareVariables(...T,b)}
      ${G.mainStart()}
          ${G.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${b.offsetToIndices("global_idx")};

          // Set input x
          ${l?`
            let input = ${w.getByOffset("global_idx / 4")};
            let x_vec = ${s?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${_===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${w.getByOffset("global_idx")};`};

          // Set scale input
          ${f?`let scale_value= ${M.getByOffset("0")}`:m?`
            let scale_index = ${b.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${M.getByOffset("scale_index")};`:`
            var scale_indices: ${M.type.indices} = output_indices;
            let index = ${M.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${M.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${M.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${x?f?l?`
                let zero_point_input = ${x.getByOffset("0")};
                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${x.getByOffset("0")}`:m?l?`
                let zero_point_index = ${b.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${x.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${b.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${x.getByOffset("zero_point_index")};`:l?`
                let zero_point_offset = ${M.indicesToOffset("scale_indices")};
                let zero_point_input = ${x.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${x.getByIndices("scale_indices")};`:`let zero_point_value = ${l?s?"i32":"u32":w.type.value}(0);`};
      // Compute and write output
      ${b.setByOffset("global_idx",`${b.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:t.cacheKey,inputDependencies:x?["rank","rank","rank"]:["rank","rank"]},getShaderSource:O,getRunData:()=>({outputs:[{dims:i,dataType:o}],dispatchGroup:{x:Math.ceil(a/_/64),y:1,z:1},programUniforms:$})}},QO=(e,t)=>{lS(e.inputs,t),e.compute(uS(e.inputs,t))},XO=e=>jt({axis:e.axis,blockSize:e.blockSize})}),cS,dS,YO,zU=Ue(()=>{Rs(),mt(),bt(),cS=(e,t,n)=>{let r=e===t,s=e<t&&n<0,i=e>t&&n>0;if(r||s||i)throw new Error("Range these inputs' contents are invalid.")},dS=(e,t,n,r)=>{let s=Math.abs(Math.ceil((t-e)/n)),i=[s],o=s,a=[{type:12,data:o},{type:r,data:e},{type:r,data:n},...lt(i)],l=u=>{let p=rt("output",r,i.length),c=p.type.value,d=[{name:"outputSize",type:"u32"},{name:"start",type:c},{name:"delta",type:c}];return`
        ${u.registerUniforms(d).declareVariables(p)}
        ${u.mainStart()}
        ${u.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${c}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${r}`},getShaderSource:l,getRunData:()=>({outputs:[{dims:i,dataType:r}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:a})}},YO=e=>{let t=0,n=0,r=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],r=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],r=e.inputs[2].getFloat32Array()[0]),Zt.webgpu.validateInputContent&&cS(t,n,r),e.compute(dS(t,n,r,e.inputs[0].dataType),{inputs:[]})}}),pS,y_,v_,fS,JO,ZO,RU=Ue(()=>{mt(),xt(),wn(),bt(),pS=(e,t,n,r)=>{if(e!=="none"&&r!=="i32"&&r!=="u32"&&r!=="f32")throw new Error(`Input ${r} is not supported with reduction ${e}.`);let s=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,i=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(e){case"none":return`${t}=${n};`;case"add":return r==="i32"||r==="u32"?`atomicAdd(&${t}, bitcast<${r}>(${n}));`:`
              ${s}bitcast<${r}>(oldValue) + (${n})${i}`;case"max":return r==="i32"||r==="u32"?`atomicMax(&${t}, bitcast<${r}>(${n}));`:`
                ${s}max(bitcast<f32>(oldValue), (${n}))${i}`;case"min":return r==="i32"||r==="u32"?`atomicMin(&${t}, bitcast<${r}>(${n}));`:`${s}min(bitcast<${r}>(oldValue), (${n}))${i}`;case"mul":return`${s}(bitcast<${r}>(oldValue) * (${n}))${i}`;default:throw new Error(`Reduction ${e} is not supported.`)}},y_=(e,t)=>`${e===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[${t?"i - indices_start":"i"}];
    let dim_value = uniforms.output_shape[${t?"i - indices_start":"i"} + uniforms.last_index_dimension];`}
    
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));`,v_=(e,t,n)=>`for (var i = 0u; i < uniforms.num_updates_elements; i++) {
        let value = updates[uniforms.num_updates_elements * ${n?"global_idx":"idx"} + i];
        ${pS(e.reduction,"output[data_offset + i]","value",t)}
      }`,fS=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n,i=1,o=Math.ceil(Me.size(r)/i),a=r[r.length-1],l=Me.sizeFromDimension(n,a),u=Me.sizeFromDimension(r,0)/a,p=[{type:12,data:o},{type:12,data:a},{type:12,data:l},...lt(e[1].dims,e[2].dims,s)],c=d=>{let f=ke("indices",e[1].dataType,e[1].dims.length),m=ke("updates",e[2].dataType,e[2].dims.length,i),y=t.reduction!=="none"&&t.reduction!==""?SA("output",e[0].dataType,s.length):rt("output",e[0].dataType,s.length,i);return`
      ${d.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(f,m,y)}
      ${d.mainStart()}
        ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var hasDuplicates = false;
  if (${t.reduction==="none"}) {
    for (var i = 0; i < ${u}; i = i + 1) {
      for (var j = i + 1; j < ${u}; j = j + 1) {
        var index_i = i32(indices[i].x);
        var index_j = i32(indices[j].x);
        if (index_i == index_j) {
          hasDuplicates = true;
          break;
        }
      }
      if (hasDuplicates) {
        break;
      }
    }
  }

  if (${t.reduction==="none"} && hasDuplicates) {
    if (global_idx != 0u) {
      return;
    }
    // Process each index-update pair individually when duplicates exist
    for (var idx = 0u; idx < ${u}u; idx++) {
      var data_offset = 0u;
      for (var i = 0u; i < uniforms.last_index_dimension; i++) {
        var index = i32(indices[idx * uniforms.last_index_dimension + i].x);
        ${y_(n.length,!1)}
      }
      ${v_(t,y.type.value,!1)}
    }
    return;
  }

  var data_offset = 0u;
  var indices_start = uniforms.last_index_dimension * global_idx;
  var indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${y_(n.length,!0)}
  }
  ${v_(t,y.type.value,!0)}
  }`};return{name:"ScatterND",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:p}),getShaderSource:c}},JO=e=>jt({reduction:e.reduction}),ZO=(e,t)=>{e.compute(fS(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}}),hS,mS,_S,w_,gS,yS,vS,wS,MS,xS,bS,TS,M_,ES,PS,SS,CS,kS,eF,tF,BU=Ue(()=>{mt(),xt(),wn(),bt(),hS=(e,t)=>{if(e.every(n=>n>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},mS=(e,t,n)=>{t.every(s=>s>=0&&s<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let r=new Array(n).fill(1);return t.forEach((s,i)=>r[s]=e[i]),r},_S=(e,t,n,r,s,i)=>{let[o,a,l]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],u=e[0].dims.length;if(o>0&&e.length>o&&e[o].dims.length>0)e[o].getFloat32Array().forEach(p=>i.push(p));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(a>0&&e.length>a&&e[a].dims.length===1&&e[a].dims[0]>0){if(e[a].getFloat32Array().forEach(p=>r.push(p)),r.length!==0&&r.length!==u&&n>=18&&r.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");hS(r,t),t.axes.length>0&&mS(r,t.axes,u).forEach((p,c)=>r[c]=p)}if(l>0&&e.length>l&&e[l].dims.length===1&&e[l].dims[0]>0&&(e[l].getBigInt64Array().forEach(p=>s.push(Number(p))),s.length!==0&&s.length!==u&&n>=18&&s.length!==t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(r.length!==0&&r.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(s.length!==0&&s.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof r<"u"&&typeof s<"u"&&r.length>0&&s.length>u)throw new Error("Resize requires only of scales or sizes to be specified")},w_=(e,t,n,r)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${e}) * (${t});
  let whole = ${r}(big / (${n}));
  let fract = ${r}(big % (${n})) / ${r}(${n});
  return whole + fract;
`,gS=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${t}(xResized) / ${t}(xScale);
          } else {
            ${w_("xResized","lengthOriginal","lengthResized",t)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${w_("xResized","lengthOriginal - 1","lengthResized - 1",t)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +
                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /
                        ${t}(lengthResized - 1);
                  } else {
                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);
                  const adjustment = ${t}(lengthResized) / outputWidth;
                  const center = ${t}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",yS=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",vS=(e,t,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),s=e.length===0?r:e.slice();return t.length>0?(t.forEach((i,o)=>{r[i]=s[o],r[o+n]=s[t.length+o]}),r):s},wS=(e,t,n,r)=>{let s=[];if(n.length>0)if(r.length>0){if(e.forEach(i=>s.push(i)),Math.max(...r)>e.length)throw new Error("axes is out of bound");r.forEach((i,o)=>s[i]=n[o])}else n.forEach(i=>s.push(i));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");s=e.map((i,o)=>Math.round(i*t[o]))}return s},MS=(e,t,n)=>{let r=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map(i=>t[i]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map(i=>t[i]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let s=e.slice();return n.axes.length>0?(n.axes.forEach(i=>t[i]=r),n.axes.forEach(i=>s[i]=Math.round(e[i]*t[i]))):(t.fill(r,0,t.length),s.forEach((i,o)=>s[o]=Math.round(i*t[o]))),s},xS=(e,t,n,r,s)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {
      var original_indices: array<${e.type.value}, ${n.length}>;
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var scale = ${at("uniforms.scales","i",r)};
        var roi_low = ${at("uniforms.roi","i",s)};
        var roi_hi = ${at("uniforms.roi",`i + ${t.length}`,s)};
        if (scale == 1.0) {
          original_indices[i] = ${e.type.value}(output_index);
        } else {
          var input_shape_i = ${at("uniforms.input_shape","i",t.length)};
          var output_shape_i = ${at("uniforms.output_shape","i",n.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,bS=(e,t,n,r,s,i,o)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {
      var input_indices: ${e.type.indices};
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var output_index = ${t.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${at("uniforms.scales","i",s)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${at("uniforms.roi","i",i)};
          var roi_hi = ${at("uniforms.roi",`i + ${n.length}`,i)};
          var input_shape_i = ${at("uniforms.input_shape","i",n.length)};
          var output_shape_i = ${at("uniforms.output_shape","i",r.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${o} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${e.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,TS=(e,t)=>`
    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var input_index = ${e.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${at("uniforms.input_shape","i",t.length)}) {
          return false;
        }
      }
      return true;
    }`,M_=(e,t,n,r)=>e.rank>r?`
    ${e.indicesSet("input_indices",t,"channel")};
    ${e.indicesSet("input_indices",n,"batch")};
`:"",ES=(e,t,n,r,s)=>{let[i,o,a,l]=n.length===2?[-1,0,1,-1]:[0,2,3,1],u=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${u} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",o,`max(0, min(row, ${n[o]} - 1))`)};
      ${e.indicesSet("input_indices",a,`max(0, min(col, ${n[a]} - 1))`)};
      ${M_(e,l,i,2)}
      return ${e.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${u} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${u} = originalIndices[${o}];
      var col:${u} = originalIndices[${a}];
      ${r?`if (row < 0 || row > (${n[o]} - 1) || col < 0 || col > (${n[a]} - 1)) {
        return ${s};
      }`:""};
      row = max(0, min(row, ${n[o]} - 1));
      col = max(0, min(col, ${n[a]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${n.length>2?`u32(originalIndices[${l}])`:"0"};
      var batch: u32 =  ${n.length>2?`u32(originalIndices[${i}])`:"0"};
      var x11: ${u} = getInputValue(batch, channel, row1, col1);
      var x12: ${u} = getInputValue(batch, channel, row1, col2);
      var x21: ${u} = getInputValue(batch, channel, row2, col1);
      var x22: ${u} = getInputValue(batch, channel, row2, col2);
      var dx1: ${u} = abs(row - ${u}(row1));
      var dx2: ${u} = abs(${u}(row2) - row);
      var dy1: ${u} = abs(col - ${u}(col1));
      var dy2: ${u} = abs(${u}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},PS=(e,t,n,r,s,i,o,a,l,u)=>{let p=n.length===2,[c,d]=p?[0,1]:[2,3],f=e.type.value,m=y=>{let C=y===c?"row":"col";return`
      fn ${C}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${f} {
        var output_index = ${t.indicesGet("output_indices",y)};
        var originalIdx: ${f} = getOriginalCoordinateFromResizedCoordinate(output_index, ${s[y]},
        ${r[y]}, ${n[y]}, ${i[y]}, ${i[y]} + ${n.length});
        var fractOriginalIdx: ${f} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${a} && (originalIdx < 0 || originalIdx > (${n[y]} - 1))) {
          return ${l};
        }
        var data: array<${f}, 4> = array<${f}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${C}: ${f} = originalIdx + ${f}(i);
          if (${C} < 0 || ${C} >= ${n[y]}) {
            ${u?`coefs[i + 1] = 0.0;
                        continue;`:a?`return ${l};`:`${C} = max(0, min(${C}, ${n[y]} - 1));`};
          }
        var input_indices_copy: ${e.type.indices} = input_indices;
          ${e.indicesSet("input_indices_copy",y,`u32(${C})`)};
          data[i + 1] = ${y===c?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${m(c)};
    ${m(d)};
  fn getCubicInterpolationCoefs(s: ${f}) -> array<${f}, 4> {
    var absS = abs(s);
    var coeffs: array<${f}, 4> = array<${f}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${f} = 1.0 - absS;
    var twoMinusAbsS: ${f} = 2.0 - absS;
    var onePlusAbsS: ${f} = 1.0 + absS;
    coeffs[0] = ((${o} * onePlusAbsS - 5 * ${o}) * onePlusAbsS + 8 * ${o}) * onePlusAbsS - 4 * ${o};
    coeffs[1] = ((${o} + 2) * absS - (${o} + 3)) * absS * absS + 1;
    coeffs[2] = ((${o} + 2) * oneMinusAbsS - (${o} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${o} * twoMinusAbsS - 5 * ${o}) * twoMinusAbsS + 8 * ${o}) * twoMinusAbsS - 4 * ${o};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${f}, 4>, coefs: array<${f}, 4>) -> ${f} {
    var coefsSum: ${f} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${f} {
    var input_indices: ${e.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},SS=(e,t,n,r,s)=>{let[i,o,a,l,u]=n.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],p=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${p} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",o,`max(0, min(depth, ${n[o]} - 1))`)};
      ${e.indicesSet("input_indices",a,`max(0, min(height, ${n[a]} - 1))`)};
      ${e.indicesSet("input_indices",l,`max(0, min(width, ${n[l]} - 1))`)};
      ${M_(e,u,i,3)}
      return ${e.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${p} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${p} = originalIndices[${o}];
      var height:${p} = originalIndices[${a}];
      var width:${p} = originalIndices[${l}];
      ${r?`if (depth < 0 || depth > (${n[o]} - 1) || height < 0 || height > (${n[a]} - 1) || width < 0 || (width > ${n[l]} - 1)) {
      return ${s};
        }`:""};

    depth = max(0, min(depth, ${n[o]} - 1));
      height = max(0, min(height, ${n[a]} - 1));
      width = max(0, min(width, ${n[l]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${n.length>3?`u32(originalIndices[${u}])`:"0"};
      var batch: u32 =  ${n.length>3?`u32(originalIndices[${i}])`:"0"};

      var x111: ${p} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${p} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${p} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${p} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${p} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${p} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${p} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${p} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${p} = abs(depth - ${p}(depth1));
      var dx2: ${p} = abs(${p}(depth2) - depth);
      var dy1: ${p} = abs(height - ${p}(height1));
      var dy2: ${p} = abs(${p}(height2) - height);
      var dz1: ${p} = abs(width - ${p}(width1));
      var dz2: ${p} = abs(${p}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},CS=(e,t,n,r,s,i)=>{let o=e.dims,a=vS(i,t.axes,o.length),l=wS(o,r,s,t.axes),u=r.slice();r.length===0&&(u=o.map((h,w)=>h===0?1:l[w]/h),t.keepAspectRatioPolicy!=="stretch"&&(l=MS(o,u,t)));let p=rt("output",e.dataType,l.length),c=ke("input",e.dataType,o.length),d=Me.size(l),f=o.length===l.length&&o.every((h,w)=>h===l[w]),m=t.coordinateTransformMode==="tf_crop_and_resize",y=t.extrapolationValue,C=c.type.value,_=h=>`
      ${f?"":`
      ${gS(t.coordinateTransformMode,C)};
      ${(()=>{switch(t.mode){case"nearest":return`
              ${TS(c,o)};
              ${yS(t.nearestMode,n,C)};
              ${bS(c,p,o,l,u.length,a.length,m)};
              `;case"linear":return`
              ${xS(p,o,l,u.length,a.length)};
              ${(()=>{if(o.length===2||o.length===4)return`${ES(c,p,o,m,y)}`;if(o.length===3||o.length===5)return`${SS(c,p,o,m,y)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(o.length===2||o.length===4)return`${PS(c,p,o,l,u,a,t.cubicCoeffA,m,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${h.registerUniform("output_size","u32").registerUniform("scales","f32",u.length).registerUniform("roi","f32",a.length).declareVariables(c,p)}
      ${h.mainStart()}
        ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${f?"output[global_idx] = input[global_idx];":`
        let output_indices = ${p.offsetToIndices("global_idx")};
        var input_indices: ${c.type.indices};
        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${c.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${t.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${o.length===2||o.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${u.length>0?t.mode==="cubic"?u:u.length:""}|${s.length>0?s:""}|${a.length>0?a:""}|${f}|${t.mode==="nearest"?o.length:o}`,inputDependencies:["rank"]},getShaderSource:_,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},{type:1,data:u},{type:1,data:a},...lt(o,l)]})}},kS=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},eF=(e,t)=>{let n=[],r=[],s=[],i=kS(e);if(t.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");_S(e.inputs,t,i,n,r,s),e.compute(CS(e.inputs[0],t,i,n,r,s),{inputs:[0]})},tF=e=>{let t=e.antialias,n=e.axes,r=e.coordinateTransformMode,s=e.cubicCoeffA,i=e.excludeOutside!==0,o=e.extrapolationValue,a=e.keepAspectRatioPolicy,l=e.mode,u=e.nearestMode===""?"simple":e.nearestMode;return jt({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:s,excludeOutside:i,extrapolationValue:o,keepAspectRatioPolicy:a,mode:l,nearestMode:u})}}),$S,IS,nF,NU=Ue(()=>{mt(),xt(),bt(),$S=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(n.dims.length!==3&&n.dims.length!==2)throw new Error("Skip must be 2D or 3D");let s=t.dims[t.dims.length-1],i=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==s)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(r.dims.length!==1)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==s)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let o=e[3];if(o.dims.length!==1)throw new Error("Beta must be 1D");if(o.dims[o.dims.length-1]!==s)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let o=e[4];if(o.dims.length!==1)throw new Error("Bias must be 1D");if(o.dims[o.dims.length-1]!==s)throw new Error("Bias must have the same hidden size as input")}},IS=(e,t,n,r)=>{let s=t.simplified,i=e[0].dims,o=Me.size(i),a=i,l=o,u=i.slice(-1)[0],p=r?i.slice(0,-1).concat(1):[],c=!s&&e.length>3,d=e.length>4,f=r&&n>1,m=r&&n>2,y=n>3,C=64,_=pn(u),h=[{type:12,data:l},{type:12,data:_},{type:12,data:u},{type:1,data:t.epsilon}],w=x=>{let b=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],T=[ke("x",e[0].dataType,e[0].dims,_),ke("skip",e[1].dataType,e[1].dims,_),ke("gamma",e[2].dataType,e[2].dims,_)];c&&T.push(ke("beta",e[3].dataType,e[3].dims,_)),d&&T.push(ke("bias",e[4].dataType,e[4].dims,_)),T.push(rt("output",e[0].dataType,a,_)),f&&T.push(rt("mean_output",1,p)),m&&T.push(rt("inv_std_output",1,p)),y&&T.push(rt("input_skip_bias_sum",e[0].dataType,a,_));let S=Kn(e[0].dataType),$=Kn(1,_);return`

      ${x.registerUniforms(b).declareVariables(...T)}
      var<workgroup> sum_shared : array<${$}, ${C}>;
      var<workgroup> sum_squared_shared : array<${$}, ${C}>;

      ${x.mainStart([C,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${C};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${C};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${C-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${d?"bias[offset1d + i]":S+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${y?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${nl(S,_,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${C};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${ro("sum",_)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${ro("square_sum",_)} / f32(uniforms.hidden_size) ${s?"":"- mean * mean"} + uniforms.epsilon);
        ${f?"mean_output[global_idx] = mean;":""}
        ${m?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${s?"":`- ${S}(mean)`}) *
            ${S}(inv_std_dev) * gamma[offset1d + i]
            ${c?"+ beta[offset1d + i]":""};
        }
      }`},M=[{dims:a,dataType:e[0].dataType}];return n>1&&M.push({dims:p,dataType:1}),n>2&&M.push({dims:p,dataType:1}),n>3&&M.push({dims:i,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${_};${f};${m};${y}`,inputDependencies:e.map((x,b)=>"type")},getShaderSource:w,getRunData:()=>({outputs:M,dispatchGroup:{x:Math.ceil(l/u)},programUniforms:h})}},nF=(e,t)=>{$S(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(IS(e.inputs,t,e.outputCount,!1),{outputs:n})}}),AS,mu,DS,x_,OS,FS,rF,sF,jU=Ue(()=>{mt(),xt(),wn(),bt(),AS=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((n,r)=>{if(e[r+1].dataType!==6&&e[r+1].dataType!==7)throw new Error(`Input ${r} must be an array of int32 or int64`)})},mu=(e,t)=>{let n=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(r=>n.push(Number(r)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(r=>n.push(Number(r)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return n},DS=(e,t)=>{if(e.length>1){let n=mu(e,1),r=mu(e,2),s=mu(e,3);return s.length===0&&(s=[...Array(e[0].dims.length).keys()]),jt({starts:n,ends:r,axes:s})}else return t},x_=(e,t,n,r,s)=>{let i=e;return e<0&&(i+=n[r[t]]),s[t]<0?Math.max(0,Math.min(i,n[r[t]]-1)):Math.max(0,Math.min(i,n[r[t]]))},OS=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {
          var input_indices: ${e.type.indices};
          var carry = 0u;
          for (var i = ${n.length}; i >= 0; i--) {
            let input_shape_i = ${at("uniforms.input_shape","i",n.length)};
            let steps_i = ${at("uniforms.steps","i",n.length)};
            let signs_i = ${at("uniforms.signs","i",n.length)};
            let starts_i = ${at("uniforms.starts","i",n.length)};
            var output_index = ${t.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${e.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,FS=(e,t)=>{let n=e[0].dims,r=Me.size(n),s=t.axes.length>0?Me.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],i=mu(e,4);i.forEach(_=>_!==0||(()=>{throw new Error("step cannot be 0")})),i.length===0&&(i=Array(s.length).fill(1));let o=t.starts.map((_,h)=>x_(_,h,n,s,i)),a=t.ends.map((_,h)=>x_(_,h,n,s,i));if(s.length!==o.length||s.length!==a.length)throw new Error("start, ends and axes should have the same number of elements");if(s.length!==n.length)for(let _=0;_<n.length;++_)s.includes(_)||(o.splice(_,0,0),a.splice(_,0,n[_]),i.splice(_,0,1));let l=i.map(_=>Math.sign(_));i.forEach((_,h,w)=>{if(_<0){let M=(a[h]-o[h])/_,x=o[h],b=x+M*i[h];o[h]=b,a[h]=x,w[h]=-_}});let u=n.slice(0);s.forEach((_,h)=>{u[_]=Math.ceil((a[_]-o[_])/i[_])});let p={dims:u,dataType:e[0].dataType},c=rt("output",e[0].dataType,u.length),d=ke("input",e[0].dataType,e[0].dims.length),f=Me.size(u),m=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:o.length},{name:"signs",type:"i32",length:l.length},{name:"steps",type:"u32",length:i.length}],y=[{type:12,data:f},{type:12,data:o},{type:6,data:l},{type:12,data:i},...lt(e[0].dims,u)],C=_=>`
      ${_.registerUniforms(m).declareVariables(d,c)}
        ${OS(d,c,n)}
        ${_.mainStart()}
          ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${c.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${c.setByOffset("global_idx",d.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${l.length}_${o.length}_${i.length}`,inputDependencies:["rank"]},getShaderSource:C,getRunData:()=>({outputs:[p],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:y})}},rF=(e,t)=>{AS(e.inputs,t);let n=DS(e.inputs,t);e.compute(FS(e.inputs,n),{inputs:[0]})},sF=e=>{let t=e.starts,n=e.ends,r=e.axes;return jt({starts:t,ends:n,axes:r})}}),LS,zS,iF,oF,VU=Ue(()=>{mt(),xt(),wn(),lo(),bt(),LS=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},zS=(e,t)=>{let n=e.inputs[0],r=n.dims,s=Me.size(r),i=r.length,o=Me.normalizeAxis(t.axis,i),a=o<r.length-1,l,u=[];a?(u=Array.from({length:i},(T,S)=>S),u[o]=i-1,u[i-1]=o,l=e.compute(Hr(n,u),{inputs:[n],outputs:[-1]})[0]):l=n;let p=l.dims,c=p[i-1],d=s/c,f=pn(c),m=c/f,y=64;d===1&&(y=256);let C=(T,S)=>S===4?`max(max(${T}.x, ${T}.y), max(${T}.z, ${T}.w))`:S===2?`max(${T}.x, ${T}.y)`:S===3?`max(max(${T}.x, ${T}.y), ${T}.z)`:T,_=ke("x",l.dataType,l.dims,f),h=rt("result",l.dataType,l.dims,f),w=_.type.value,M=Kn(l.dataType)==="f32"?`var threadMax = ${w}(-3.402823e+38f);`:`var threadMax = ${w}(-65504.0h);`,x=T=>`
      var<workgroup> rowMaxShared : ${w};
      var<workgroup> rowSumShared : ${w};
      var<workgroup> threadShared : array<${w}, ${y}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${w} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${w}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${T.registerUniform("packedCols","i32").declareVariables(_,h)}
      ${T.mainStart(y)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${y};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${M}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${w}(${C("threadShared[0]",f)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${w}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${w}(${ro("threadShared[0]",f)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,b=e.compute({name:"Softmax",shaderCache:{hint:`${f};${y}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:p,dataType:l.dataType}],dispatchGroup:{x:d},programUniforms:[{type:6,data:m}]}),getShaderSource:x},{inputs:[l],outputs:[a?-1:0]})[0];a&&e.compute(Hr(b,u),{inputs:[b]})},iF=(e,t)=>{LS(e.inputs),zS(e,t)},oF=e=>jt({axis:e.axis})}),b_,RS,BS,NS,aF,UU=Ue(()=>{mt(),xt(),bt(),b_=e=>Array.from(e.getBigInt64Array(),Number),RS=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==10&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(b_(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},BS=(e,t)=>{let n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n},NS=(e,t)=>{let n=e[0].dims,r=t??b_(e[1]),s=BS(n,r),i=Me.size(s),o=e[0].dataType,a=ke("input",o,n.length),l=rt("output",o,s.length),u=p=>`
      const inputShape = ${a.indices(...n)};
      ${p.registerUniform("output_size","u32").declareVariables(a,l)}
      ${p.mainStart()}
      ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${l.offsetToIndices("global_idx")};
      var input_indices: ${a.type.indices};
      for (var i = 0; i < ${n.length}; i++) {
        let input_dim_i = ${a.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${l.indicesGet("output_indices","i")}  % input_dim_i;

        ${a.indicesSet("input_indices","i","input_dim_value")}
      }
      ${l.setByOffset("global_idx",a.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...lt(e[0].dims,s)]}),getShaderSource:u}},aF=e=>{RS(e.inputs),e.compute(NS(e.inputs),{inputs:[0]})}}),jS,VS,lF,WU=Ue(()=>{mt(),xt(),bt(),jS=(e,t,n,r,s)=>{let i=rt("output_data",s,n.length,4),o=ke("a_data",t[1].dataType,t[1].dims.length,4),a=ke("b_data",t[2].dataType,t[2].dims.length,4),l=ke("c_data",t[0].dataType,t[0].dims.length,4),u,p=(c,d,f)=>`select(${d}, ${c}, ${f})`;if(!r)u=i.setByOffset("global_idx",p(o.getByOffset("global_idx"),a.getByOffset("global_idx"),l.getByOffset("global_idx")));else{let c=(d,f,m="")=>{let y=`a_data[index_a${f}][component_a${f}]`,C=`b_data[index_b${f}][component_b${f}]`,_=`bool(c_data[index_c${f}] & (0xffu << (component_c${f} * 8)))`;return`
            let output_indices${f} = ${i.offsetToIndices(`global_idx * 4u + ${f}u`)};
            let offset_a${f} = ${o.broadcastedIndicesToOffset(`output_indices${f}`,i)};
            let offset_b${f} = ${a.broadcastedIndicesToOffset(`output_indices${f}`,i)};
            let offset_c${f} = ${l.broadcastedIndicesToOffset(`output_indices${f}`,i)};
            let index_a${f} = offset_a${f} / 4u;
            let index_b${f} = offset_b${f} / 4u;
            let index_c${f} = offset_c${f} / 4u;
            let component_a${f} = offset_a${f} % 4u;
            let component_b${f} = offset_b${f} % 4u;
            let component_c${f} = offset_c${f} % 4u;
            ${d}[${f}] = ${m}(${p(y,C,_)});
          `};s===9?u=`
            var data = vec4<u32>(0);
            ${c("data",0,"u32")}
            ${c("data",1,"u32")}
            ${c("data",2,"u32")}
            ${c("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:u=`
            ${c("output_data[global_idx]",0)}
            ${c("output_data[global_idx]",1)}
            ${c("output_data[global_idx]",2)}
            ${c("output_data[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(l,o,a,i)}
        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${u}
      }`},VS=e=>{let t=e[1].dims,n=e[2].dims,r=e[0].dims,s=e[1].dataType,i=!(Me.areEqual(t,n)&&Me.areEqual(n,r)),o=t,a=Me.size(t);if(i){let u=yl.calcShape(yl.calcShape(t,n,!1),r,!1);if(!u)throw new Error("Can't perform where op on the given tensors");o=u,a=Me.size(o)}let l=Math.ceil(a/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:u=>jS(u,e,o,i,s),getRunData:()=>({outputs:[{dims:o,dataType:s}],dispatchGroup:{x:Math.ceil(a/64/4)},programUniforms:[{type:12,data:l},...lt(r,t,n,o)]})}},lF=e=>{e.compute(VS(e.inputs))}}),uF,GU=Ue(()=>{iU(),zy(),oU(),aU(),lU(),uU(),cU(),mU(),gU(),yU(),vU(),wU(),MU(),xU(),bU(),TU(),EU(),PU(),SU(),CU(),kU(),$U(),IU(),AU(),DU(),CO(),OU(),FU(),LU(),zU(),RU(),Ly(),BU(),DO(),NU(),jU(),VU(),IO(),UU(),lo(),Ry(),WU(),uF=new Map([["Abs",[nD]],["Acos",[rD]],["Acosh",[sD]],["Add",[RD]],["ArgMax",[JA,Gg]],["ArgMin",[YA,Gg]],["Asin",[iD]],["Asinh",[oD]],["Atan",[aD]],["Atanh",[lD]],["Attention",[ZA]],["AveragePool",[VO,jO]],["BatchNormalization",[eD]],["BiasAdd",[tD]],["BiasSplitGelu",[zD]],["Cast",[cD,uD]],["Ceil",[pD]],["Clip",[dD]],["Concat",[qD,QD]],["Conv",[Yg,Xg]],["ConvTranspose",[iO,sO]],["Cos",[fD]],["Cosh",[hD]],["CumSum",[oO,aO]],["DepthToSpace",[lO,uO]],["DequantizeLinear",[QO,XO]],["Div",[BD]],["Einsum",[cO,dO]],["Elu",[mD,Eu]],["Equal",[ND]],["Erf",[_D]],["Exp",[gD]],["Expand",[pO]],["FastGelu",[fO]],["Floor",[yD]],["FusedConv",[Yg,Xg]],["Gather",[mO,hO]],["GatherElements",[MO,wO]],["GatherBlockQuantized",[yO,vO]],["GatherND",[_O,gO]],["Gelu",[vD]],["Gemm",[bO,xO]],["GlobalAveragePool",[WO,UO]],["GlobalMaxPool",[qO,KO]],["Greater",[WD]],["GreaterOrEqual",[HD]],["GridSample",[TO,EO]],["GroupQueryAttention",[OO]],["HardSigmoid",[SD,PD]],["InstanceNormalization",[FO]],["LayerNormalization",[LO]],["LeakyRelu",[wD,Eu]],["Less",[GD]],["LessOrEqual",[KD]],["Log",[FD]],["MatMul",[zO]],["MatMulNBits",[RO,BO]],["MaxPool",[GO,HO]],["Mul",[jD]],["MultiHeadAttention",[SO,PO]],["Neg",[xD]],["Not",[MD]],["Pad",[NO]],["Pow",[VD]],["QuickGelu",[LD,Eu]],["Range",[YO]],["Reciprocal",[bD]],["ReduceMin",[HA]],["ReduceMean",[jA]],["ReduceMax",[GA]],["ReduceSum",[qA]],["ReduceProd",[KA]],["ReduceL1",[VA]],["ReduceL2",[UA]],["ReduceLogSum",[XA]],["ReduceLogSumExp",[WA]],["ReduceSumSquare",[QA]],["Relu",[TD]],["Resize",[eF,tF]],["RotaryEmbedding",[AO]],["ScatterND",[ZO,JO]],["Sigmoid",[ED]],["Sin",[CD]],["Sinh",[kD]],["Slice",[rF,sF]],["SkipLayerNormalization",[nF]],["Split",[kO,$O]],["Sqrt",[$D]],["Softmax",[iF,oF]],["Sub",[UD]],["Tan",[ID]],["Tanh",[AD]],["ThresholdedRelu",[OD,Eu]],["Tile",[aF]],["Transpose",[kA,$A]],["Where",[lF]]])}),cF,HU=Ue(()=>{Rs(),wi(),bt(),cF=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r,s){zs(e.programInfo.name);let i=this.backend.device,o=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let a=[];for(let u of t)a.push({binding:a.length,resource:{buffer:u.buffer}});for(let u of n)a.push({binding:a.length,resource:{buffer:u.buffer}});s&&a.push({binding:a.length,resource:s});let l=i.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:a,label:e.programInfo.name});if(this.backend.sessionStatus==="capturing"){let u={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:l,dispatchGroup:r};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(u)}o.setPipeline(e.computePipeline),o.setBindGroup(0,l),o.dispatchWorkgroups(...r),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),ds(e.programInfo.name)}dispose(){}build(e,t){zs(e.name);let n=this.backend.device,r=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach(u=>{n.features.has(u.feature)&&r.push(`enable ${u.extension};`)});let s=CA(t,this.backend.device.limits),i=e.getShaderSource(s),o=`${r.join(`
`)}
${s.additionalImplementations}
${i}`,a=n.createShaderModule({code:o,label:e.name});Dt("verbose",()=>`[WebGPU] ${e.name} shader code: ${o}`);let l=n.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto",label:e.name});return ds(e.name),{programInfo:e,computePipeline:l,uniformVariablesInfo:s.variablesInfo}}normalizeDispatchGroupSize(e){let t=typeof e=="number"?e:e.x,n=typeof e=="number"?1:e.y||1,r=typeof e=="number"?1:e.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=s&&n<=s&&r<=s)return[t,n,r];let i=t*n*r,o=Math.ceil(Math.sqrt(i));if(o>s){if(o=Math.ceil(Math.cbrt(i)),o>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[o,o,o]}else return[o,o,1]}}}),dF={};Tl(dF,{WebGpuBackend:()=>pF});var US,WS,GS,pF,KU=Ue(()=>{Rs(),mt(),wi(),bA(),rU(),GU(),HU(),US=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let r=0;r<e.length;++r){let s=e[r].dataType;switch(t[r]){case"none":{n.push("");break}case"type":{n.push(`${s}`);break}case"rank":{let i=e[r].dims.length;n.push(`${s};${i}`);break}case"dims":{let i=e[r].dims.join(",");n.push(`${s};${i}`);break}default:throw new Error(`unsupported input dependency: ${t[r]}`)}}return n.join("|")},WS=(e,t,n)=>{var s,i;let r=e.name;return(s=e.shaderCache)!=null&&s.hint&&(r+="["+e.shaderCache.hint+"]"),r+=":"+n+`:${US(t,((i=e.shaderCache)==null?void 0:i.inputDependencies)??new Array(t.length).fill("dims"))}`,r},GS=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},pF=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,t){this.env=e;let n=[],r={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},s=i=>t.features.has(i)&&n.push(i)&&!0;s("chromium-experimental-timestamp-query-inside-passes")||s("timestamp-query"),s("shader-f16"),s("subgroups"),this.device=await t.requestDevice(r),this.adapterInfo=new GS(t.info||await t.requestAdapterInfo()),this.gpuDataManager=PA(this),this.programManager=new cF(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Ay(e.logLevel,!!e.debug),this.device.onuncapturederror=i=>{i.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${i.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:t,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),t={};this.queryType==="at-passes"&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=e.beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;zs(),this.endComputePass();let e;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),e=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&e.mapAsync(GPUMapMode.READ).then(()=>{var r;let t=new BigUint64Array(e.getMappedRange()),n=this.pendingQueries.get(e);for(let s=0;s<t.length/2;s++){let i=n[s],o=i.kernelId,a=this.kernels.get(o),l=a.kernelType,u=a.kernelName,p=i.programName,c=i.inputTensorViews,d=i.outputTensorViews,f=t[s*2],m=t[s*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=f);let y=Number(f-this.queryTimeBase),C=Number(m-this.queryTimeBase);if(!Number.isSafeInteger(y)||!Number.isSafeInteger(C))throw new RangeError("incorrect timestamp range");if((r=this.env.webgpu.profiling)!=null&&r.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:c.map(_=>({dims:_.dims,dataType:oi(_.dataType)})),outputsMetadata:d.map(_=>({dims:_.dims,dataType:oi(_.dataType)})),kernelId:o,kernelType:l,kernelName:u,programName:p,startTime:y,endTime:C});else{let _="";c.forEach((w,M)=>{_+=`input[${M}]: [${w.dims}] | ${oi(w.dataType)}, `});let h="";d.forEach((w,M)=>{h+=`output[${M}]: [${w.dims}] | ${oi(w.dataType)}, `}),console.log(`[profiling] kernel "${o}|${l}|${u}|${p}" ${_}${h}execution time: ${C-y} ns`)}cc("GPU",`${p}::${f}::${m}`)}e.unmap(),this.pendingQueries.delete(e)}),ds()}run(e,t,n,r,s,i){zs(e.name);let o=[];for(let h=0;h<t.length;++h){let w=t[h].data;if(w===0)continue;let M=this.gpuDataManager.get(w);if(!M)throw new Error(`no GPU data for input: ${w}`);o.push(M)}let{outputs:a,dispatchGroup:l,programUniforms:u}=e.getRunData(t),p=n.length===0?a.map((h,w)=>w):n;if(p.length!==a.length)throw new Error(`Output size ${p.length} must be equal to ${a.length}.`);let c=[],d=[];for(let h=0;h<a.length;++h){if(!Number.isInteger(p[h])||p[h]<-3||p[h]>=i)throw new Error(`Invalid output index: ${p[h]}`);if(p[h]===-3)continue;let w=p[h]===-1,M=p[h]===-2,x=w||M?s(a[h].dataType,a[h].dims):r(p[h],a[h].dataType,a[h].dims);if(c.push(x),x.data===0)continue;let b=this.gpuDataManager.get(x.data);if(!b)throw new Error(`no GPU data for output: ${x.data}`);if(w&&this.temporaryData.push(b),M){let T=this.kernelPersistentData.get(this.currentKernelId);T||(T=[],this.kernelPersistentData.set(this.currentKernelId,T)),T.push(b)}d.push(b)}if(o.length!==t.length||d.length!==c.length){if(d.length===0)return ds(e.name),c;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let f;if(u){let h=0,w=[];u.forEach(T=>{let S=typeof T.data=="number"?[T.data]:T.data;if(S.length===0)return;let $=T.type===10?2:4,O,G;T.type===10?(G=S.length>4?16:S.length>2?8:S.length*$,O=S.length>4?16:$*S.length):(G=S.length<=2?S.length*$:16,O=16),h=Math.ceil(h/G)*G,w.push(h);let H=T.type===10?8:4;h+=S.length>4?Math.ceil(S.length/H)*O:S.length*$});let M=16;h=Math.ceil(h/M)*M;let x=new ArrayBuffer(h);u.forEach((T,S)=>{let $=w[S],O=typeof T.data=="number"?[T.data]:T.data;if(T.type===6)new Int32Array(x,$,O.length).set(O);else if(T.type===12)new Uint32Array(x,$,O.length).set(O);else if(T.type===10)new Uint16Array(x,$,O.length).set(O);else if(T.type===1)new Float32Array(x,$,O.length).set(O);else throw new Error(`Unsupported uniform type: ${oi(T.type)}`)});let b=this.gpuDataManager.create(h,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(b.buffer,0,x,0,h),this.gpuDataManager.release(b.id),f={offset:0,size:h,buffer:b.buffer}}let m=this.programManager.normalizeDispatchGroupSize(l),y=m[1]===1&&m[2]===1,C=WS(e,t,y),_=this.programManager.getArtifact(C);if(_||(_=this.programManager.build(e,m),this.programManager.setArtifact(C,_),Dt("info",()=>`[artifact] key: ${C}, programName: ${e.name}`)),u&&_.uniformVariablesInfo){if(u.length!==_.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${_.uniformVariablesInfo.length}, got ${u.length} in program "${_.programInfo.name}".`);for(let h=0;h<u.length;h++){let w=u[h],M=w.type,x=typeof w.data=="number"?1:w.data.length,[b,T]=_.uniformVariablesInfo[h];if(M!==b||x!==T)throw new Error(`Uniform variable ${h} mismatch: expect type ${b} with size ${T}, got type ${M} with size ${x} in program "${_.programInfo.name}".`)}}if(Dt("info",()=>`[ProgramManager] run "${e.name}" (key=${C}) with ${m[0]}x${m[1]}x${m[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let h={kernelId:this.currentKernelId,programName:_.programInfo.name,inputTensorViews:t,outputTensorViews:c};this.pendingKernels.push(h),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(h)}return this.programManager.run(_,o,d,m,f),ds(e.name),c}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,r){let s=uF.get(e);if(!s)throw new Error(`kernel not implemented: ${e}`);let i={kernelType:e,kernelName:r,kernelEntry:s[0],attributes:[s[1],n]};this.kernels.set(t,i)}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let n of t)this.gpuDataManager.release(n.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let r=this.kernels.get(e);if(!r)throw new Error(`kernel not created: ${e}`);let s=r.kernelType,i=r.kernelName,o=r.kernelEntry,a=r.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${i}" is not allowed to be called recursively`);this.currentKernelId=e,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),Dt("info",()=>`[WebGPU] Start to run kernel "[${s}] ${i}"...`);let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),o(t,a[1]),0}catch(u){return n.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${i}" failed. ${u}`)),1}finally{l&&n.push(this.device.popErrorScope().then(u=>u?`GPU validation error for kernel "[${s}] ${i}": ${u.message}`:null));for(let u of this.temporaryData)this.gpuDataManager.release(u.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,r){let s=this.sessionExternalDataMapping.get(e);s||(s=new Map,this.sessionExternalDataMapping.set(e,s));let i=s.get(t),o=this.gpuDataManager.registerExternalBuffer(n,r,i);return s.set(t,[o,n]),o}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach(n=>this.gpuDataManager.unregisterExternalBuffer(n[0])),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let r=await Vg(this,e,t);return Dy(r.buffer,n)}}writeTimestamp(e){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){var e;this.queryType="none",(((e=this.env.webgpu.profiling)==null?void 0:e.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Dt("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Dt("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Dt("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),t=this.capturedPendingKernels.get(this.currentSessionId),n=e.length;this.pendingKernels=[];for(let r=0;r<n;r++){let s=this.getComputePassEncoder(),i=e[r];this.writeTimestamp(this.pendingDispatchNumber*2),s.setPipeline(i.computePipeline),s.setBindGroup(0,i.bindGroup),s.dispatchWorkgroups(...i.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(t[r]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}}),fF={};Tl(fF,{init:()=>hF});var Yd,HS,hF,qU=Ue(()=>{mt(),wi(),xt(),nU(),Yd=class mF{constructor(t,n,r,s){this.module=t,this.dataType=n,this.data=r,this.dims=s}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=Me.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=Me.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=Me.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let t=Me.size(this.dims);return t===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(Me.size(t)!==Me.size(this.dims))throw new Error("Invalid new shape");return new mF(this.module,this.dataType,this.data,t)}},HS=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=t.adapterInfo;let r=e.PTR_SIZE,s=n/e.PTR_SIZE,i=r===4?"i32":"i64";this.opKernelContext=Number(e.getValue(r*s++,i));let o=Number(e.getValue(r*s++,i));this.outputCount=Number(e.getValue(r*s++,i)),this.customDataOffset=Number(e.getValue(r*s++,"*")),this.customDataSize=Number(e.getValue(r*s++,i));let a=[];for(let l=0;l<o;l++){let u=Number(e.getValue(r*s++,i)),p=Number(e.getValue(r*s++,"*")),c=Number(e.getValue(r*s++,i)),d=[];for(let f=0;f<c;f++)d.push(Number(e.getValue(r*s++,i)));a.push(new Yd(e,u,p,d))}this.inputs=a}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){var o;let n=((o=t==null?void 0:t.inputs)==null?void 0:o.map(a=>typeof a=="number"?this.inputs[a]:a))??this.inputs,r=(t==null?void 0:t.outputs)??[],s=(a,l,u)=>new Yd(this.module,l,this.output(a,u),u),i=(a,l)=>{let u=Ko(a,l);if(!u)throw new Error(`Unsupported data type: ${a}`);let p=u>0?this.backend.gpuDataManager.create(u).id:0;return new Yd(this.module,a,p,l)};return this.backend.run(e,n,r,s,i,this.outputCount)}output(e,t){let n=this.module.stackSave();try{let r=this.module.PTR_SIZE,s=r===4?"i32":"i64",i=this.module.stackAlloc((1+t.length)*r);this.module.setValue(i,t.length,s);for(let o=0;o<t.length;o++)this.module.setValue(i+r*(o+1),t[o],s);return this.module._JsepOutput(this.opKernelContext,e,i)}catch(r){throw new Error(`Failed to generate kernel's output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${r}`)}finally{this.module.stackRestore(n)}}},hF=async(e,t,n,r)=>{let s=t.jsepInit;if(!s)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(e==="webgpu"){let i=(KU(),uc(dF)).WebGpuBackend,o=new i;await o.initialize(n,r),s("webgpu",[o,a=>o.alloc(Number(a)),a=>o.free(a),(a,l,u,p=!1)=>{if(p)Dt("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(a)}, dst=${Number(l)}, size=${Number(u)}`),o.memcpy(Number(a),Number(l));else{Dt("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(a)}, gpuDataId=${Number(l)}, size=${Number(u)}`);let c=t.HEAPU8.subarray(Number(a>>>0),Number(a>>>0)+Number(u));o.upload(Number(l),c)}},async(a,l,u)=>{Dt("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${l}, size=${u}`),await o.download(Number(a),()=>t.HEAPU8.subarray(Number(l)>>>0,Number(l+u)>>>0))},(a,l,u)=>o.createKernel(a,Number(l),u,t.UTF8ToString(t._JsepGetNodeName(Number(l)))),a=>o.releaseKernel(a),(a,l,u,p)=>{Dt("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${a}, contextDataOffset=${l}`);let c=new HS(t,o,Number(l));return o.computeKernel(Number(a),c,p)},()=>o.captureBegin(),()=>o.captureEnd(),()=>o.replay()])}else{let i=new EA(n);s("webnn",[i,()=>i.reserveTensorId(),o=>i.releaseTensorId(o),async(o,a,l,u,p)=>i.ensureTensor(o,a,l,u,p),(o,a)=>{i.uploadTensor(o,a)},async(o,a)=>i.downloadTensor(o,a)])}}}),KS,Wy,Gy,Di,qS,T_,uf,Hy,Ky,E_,qy,Qy,Xy,_F=Ue(()=>{ZV(),eU(),mt(),ga(),Sy(),vA(),KS=(e,t)=>{Xt()._OrtInit(e,t)!==0&&Wt("Can't initialize onnxruntime.")},Wy=async e=>{KS(e.wasm.numThreads,rf(e.logLevel))},Gy=async(e,t)=>{var n,r;(r=(n=Xt()).asyncInit)==null||r.call(n);{let s=(qU(),uc(fF)).init;if(t==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let i=e.webgpu.adapter;if(i){if(typeof i.limits!="object"||typeof i.features!="object"||typeof i.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let o=e.webgpu.powerPreference;if(o!==void 0&&o!=="low-power"&&o!=="high-performance")throw new Error(`Invalid powerPreference setting: "${o}"`);let a=e.webgpu.forceFallbackAdapter;if(a!==void 0&&typeof a!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${a}"`);if(i=await navigator.gpu.requestAdapter({powerPreference:o,forceFallbackAdapter:a}),!i)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await s("webgpu",Xt(),e,i)}if(t==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await s("webnn",Xt(),e)}}},Di=new Map,qS=e=>{let t=Xt(),n=t.stackSave();try{let r=t.PTR_SIZE,s=t.stackAlloc(2*r);t._OrtGetInputOutputCount(e,s,s+r)!==0&&Wt("Can't get session input/output count.");let i=r===4?"i32":"i64";return[Number(t.getValue(s,i)),Number(t.getValue(s+r,i))]}finally{t.stackRestore(n)}},T_=(e,t)=>{let n=Xt(),r=n.stackSave(),s=0;try{let i=n.PTR_SIZE,o=n.stackAlloc(2*i);n._OrtGetInputOutputMetadata(e,t,o,o+i)!==0&&Wt("Can't get session input/output metadata.");let a=Number(n.getValue(o,"*"));s=Number(n.getValue(o+i,"*"));let l=n.HEAP32[s/4];if(l===0)return[a,0];let u=n.HEAPU32[s/4+1],p=[];for(let c=0;c<u;c++){let d=Number(n.getValue(s+8+c*i,"*"));p.push(d!==0?n.UTF8ToString(d):Number(n.getValue(s+8+(c+u)*i,"*")))}return[a,l,p]}finally{n.stackRestore(r),s!==0&&n._OrtFree(s)}},uf=e=>{let t=Xt(),n=t._malloc(e.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Hy=async(e,t)=>{var c,d,f,m;let n,r,s=Xt();Array.isArray(e)?[n,r]=e:e.buffer===s.HEAPU8.buffer?[n,r]=[e.byteOffset,e.byteLength]:[n,r]=uf(e);let i=0,o=0,a=0,l=[],u=[],p=[];try{if([o,l]=await yA(t),(t==null?void 0:t.externalData)&&s.mountExternalData){let S=[];for(let $ of t.externalData){let O=typeof $=="string"?$:$.path;S.push(Iy(typeof $=="string"?$:$.data).then(G=>{s.mountExternalData(O,G)}))}await Promise.all(S)}for(let S of(t==null?void 0:t.executionProviders)??[])if((typeof S=="string"?S:S.name)==="webnn"){if(s.shouldTransferToMLTensor=!1,typeof S!="string"){let $=S,O=$==null?void 0:$.context,G=$==null?void 0:$.gpuDevice,H=$==null?void 0:$.deviceType,N=$==null?void 0:$.powerPreference;O?s.currentContext=O:G?s.currentContext=await s.webnnCreateMLContext(G):s.currentContext=await s.webnnCreateMLContext({deviceType:H,powerPreference:N})}else s.currentContext=await s.webnnCreateMLContext();break}i=await s._OrtCreateSession(n,r,o),(c=s.webgpuOnCreateSession)==null||c.call(s,i),i===0&&Wt("Can't create a session."),(d=s.jsepOnCreateSession)==null||d.call(s),s.currentContext&&(s.webnnRegisterMLContext(i,s.currentContext),s.currentContext=void 0,s.shouldTransferToMLTensor=!0);let[y,C]=qS(i),_=!!(t!=null&&t.enableGraphCapture),h=[],w=[],M=[],x=[],b=[];for(let S=0;S<y;S++){let[$,O,G]=T_(i,S);$===0&&Wt("Can't get an input name."),u.push($);let H=s.UTF8ToString($);h.push(H),M.push(O===0?{name:H,isTensor:!1}:{name:H,isTensor:!0,type:oi(O),shape:G})}for(let S=0;S<C;S++){let[$,O,G]=T_(i,S+y);$===0&&Wt("Can't get an output name."),p.push($);let H=s.UTF8ToString($);w.push(H),x.push(O===0?{name:H,isTensor:!1}:{name:H,isTensor:!0,type:oi(O),shape:G});{if(_&&(t==null?void 0:t.preferredOutputLocation)===void 0){b.push("gpu-buffer");continue}let N=typeof(t==null?void 0:t.preferredOutputLocation)=="string"?t.preferredOutputLocation:((f=t==null?void 0:t.preferredOutputLocation)==null?void 0:f[H])??"cpu";if(N!=="cpu"&&N!=="cpu-pinned"&&N!=="gpu-buffer"&&N!=="ml-tensor")throw new Error(`Not supported preferred output location: ${N}.`);if(_&&N!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${N}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);b.push(N)}}let T=null;return b.some(S=>S==="gpu-buffer"||S==="ml-tensor")&&(a=s._OrtCreateBinding(i),a===0&&Wt("Can't create IO binding."),T={handle:a,outputPreferredLocations:b,outputPreferredLocationsEncoded:b.map(S=>Ng(S))}),Di.set(i,[i,u,p,T,_,!1]),[i,h,w,M,x]}catch(y){throw u.forEach(C=>s._OrtFree(C)),p.forEach(C=>s._OrtFree(C)),a!==0&&s._OrtReleaseBinding(a)!==0&&Wt("Can't release IO binding."),i!==0&&s._OrtReleaseSession(i)!==0&&Wt("Can't release session."),y}finally{s._free(n),o!==0&&s._OrtReleaseSessionOptions(o)!==0&&Wt("Can't release session options."),l.forEach(y=>s._free(y)),(m=s.unmountExternalData)==null||m.call(s)}},Ky=e=>{var l,u,p;let t=Xt(),n=Di.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[r,s,i,o,a]=n;o&&(a&&t._OrtClearBoundOutputs(o.handle)!==0&&Wt("Can't clear bound outputs."),t._OrtReleaseBinding(o.handle)!==0&&Wt("Can't release IO binding.")),(l=t.jsepOnReleaseSession)==null||l.call(t,e),(u=t.webnnOnReleaseSession)==null||u.call(t,e),(p=t.webgpuOnReleaseSession)==null||p.call(t,e),s.forEach(c=>t._OrtFree(c)),i.forEach(c=>t._OrtFree(c)),t._OrtReleaseSession(r)!==0&&Wt("Can't release session."),Di.delete(e)},E_=async(e,t,n,r,s,i,o=!1)=>{if(!e){t.push(0);return}let a=Xt(),l=a.PTR_SIZE,u=e[0],p=e[1],c=e[3],d=c,f,m;if(u==="string"&&(c==="gpu-buffer"||c==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(o&&c!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${i} when enableGraphCapture is true.`);if(c==="gpu-buffer"){let _=e[2].gpuBuffer;m=Ko(Ra(u),p);{let h=a.jsepRegisterBuffer;if(!h)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');f=h(r,i,_,m)}}else if(c==="ml-tensor"){let _=e[2].mlTensor;m=Ko(Ra(u),p);let h=a.webnnRegisterMLTensor;if(!h)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');f=h(r,_,Ra(u),p)}else{let _=e[2];if(Array.isArray(_)){m=l*_.length,f=a._malloc(m),n.push(f);for(let h=0;h<_.length;h++){if(typeof _[h]!="string")throw new TypeError(`tensor data at index ${h} is not a string`);a.setValue(f+h*l,Is(_[h],n),"*")}}else{let h=a.webnnIsGraphInput;if(u!=="string"&&h){let w=a.UTF8ToString(s);if(h(r,w)){let M=Ra(u);m=Ko(M,p),d="ml-tensor";let x=a.webnnCreateTemporaryTensor,b=a.webnnUploadTensor;if(!x||!b)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let T=await x(r,M,p);b(T,new Uint8Array(_.buffer,_.byteOffset,_.byteLength)),f=T}else m=_.byteLength,f=a._malloc(m),n.push(f),a.HEAPU8.set(new Uint8Array(_.buffer,_.byteOffset,m),f)}else m=_.byteLength,f=a._malloc(m),n.push(f),a.HEAPU8.set(new Uint8Array(_.buffer,_.byteOffset,m),f)}}let y=a.stackSave(),C=a.stackAlloc(4*p.length);try{p.forEach((h,w)=>a.setValue(C+w*l,h,l===4?"i32":"i64"));let _=a._OrtCreateTensor(Ra(u),f,m,C,p.length,Ng(d));_===0&&Wt(`Can't create tensor for input/output. session=${r}, index=${i}.`),t.push(_)}finally{a.stackRestore(y)}},qy=async(e,t,n,r,s,i)=>{var G,H,N,J;let o=Xt(),a=o.PTR_SIZE,l=Di.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let u=l[0],p=l[1],c=l[2],d=l[3],f=l[4],m=l[5],y=t.length,C=r.length,_=0,h=[],w=[],M=[],x=[],b=o.stackSave(),T=o.stackAlloc(y*a),S=o.stackAlloc(y*a),$=o.stackAlloc(C*a),O=o.stackAlloc(C*a);try{[_,h]=gA(i);for(let Y=0;Y<y;Y++)await E_(n[Y],w,x,e,p[t[Y]],t[Y],f);for(let Y=0;Y<C;Y++)await E_(s[Y],M,x,e,c[r[Y]],y+r[Y],f);for(let Y=0;Y<y;Y++)o.setValue(T+Y*a,w[Y],"*"),o.setValue(S+Y*a,p[t[Y]],"*");for(let Y=0;Y<C;Y++)o.setValue($+Y*a,M[Y],"*"),o.setValue(O+Y*a,c[r[Y]],"*");if(d&&!m){let{handle:Y,outputPreferredLocations:K,outputPreferredLocationsEncoded:oe}=d;if(p.length!==y)throw new Error(`input count from feeds (${y}) is expected to be always equal to model's input count (${p.length}).`);for(let se=0;se<y;se++){let F=t[se];await o._OrtBindInput(Y,p[F],w[se])!==0&&Wt(`Can't bind input[${se}] for session=${e}.`)}for(let se=0;se<C;se++){let F=r[se];(G=s[se])!=null&&G[3]?o._OrtBindOutput(Y,c[F],M[se],0)!==0&&Wt(`Can't bind pre-allocated output[${se}] for session=${e}.`):o._OrtBindOutput(Y,c[F],0,oe[F])!==0&&Wt(`Can't bind output[${se}] to ${K[se]} for session=${e}.`)}Di.set(e,[u,p,c,d,f,!0])}(H=o.jsepOnRunStart)==null||H.call(o,u),(N=o.webnnOnRunStart)==null||N.call(o,u);let q;d?q=await o._OrtRunWithBinding(u,d.handle,C,$,_):q=await o._OrtRun(u,S,T,y,O,C,$,_),q!==0&&Wt("failed to call OrtRun().");let X=[];for(let Y=0;Y<C;Y++){let K=Number(o.getValue($+Y*a,"*"));if(K===M[Y]){X.push(s[Y]);continue}let oe=o.stackSave(),se=o.stackAlloc(4*a),F=!1,I,V=0;try{o._OrtGetTensorData(K,se,se+a,se+2*a,se+3*a)!==0&&Wt(`Can't access output tensor data on index ${Y}.`);let ee=a===4?"i32":"i64",pe=Number(o.getValue(se,ee));V=o.getValue(se+a,"*");let Z=o.getValue(se+a*2,"*"),de=Number(o.getValue(se+a*3,ee)),Se=[];for(let Q=0;Q<de;Q++)Se.push(Number(o.getValue(Z+Q*a,ee)));o._OrtFree(Z)!==0&&Wt("Can't free memory for tensor dims.");let Re=Se.reduce((Q,j)=>Q*j,1);I=oi(pe);let ye=d==null?void 0:d.outputPreferredLocations[r[Y]];if(I==="string"){if(ye==="gpu-buffer"||ye==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let Q=[];for(let j=0;j<Re;j++){let he=o.getValue(V+j*a,"*"),be=o.getValue(V+(j+1)*a,"*"),we=j===Re-1?void 0:be-he;Q.push(o.UTF8ToString(he,we))}X.push([I,Se,Q,"cpu"])}else if(ye==="gpu-buffer"&&Re>0){let Q=o.jsepGetBuffer;if(!Q)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let j=Q(V),he=Ko(pe,Re);if(he===void 0||!ky(I))throw new Error(`Unsupported data type: ${I}`);F=!0,X.push([I,Se,{gpuBuffer:j,download:o.jsepCreateDownloader(j,he,I),dispose:()=>{o._OrtReleaseTensor(K)!==0&&Wt("Can't release tensor.")}},"gpu-buffer"])}else if(ye==="ml-tensor"&&Re>0){let Q=o.webnnEnsureTensor,j=o.webnnIsInt64Supported;if(!Q||!j)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(Ko(pe,Re)===void 0||!$y(I))throw new Error(`Unsupported data type: ${I}`);if(I==="int64"&&!j(e))throw new Error('preferredLocation "ml-tensor" for int64 output is not supported by current WebNN Context.');let he=await Q(e,V,pe,Se,!1);F=!0,X.push([I,Se,{mlTensor:he,download:o.webnnCreateMLTensorDownloader(V,I),dispose:()=>{o.webnnReleaseTensorId(V),o._OrtReleaseTensor(K)}},"ml-tensor"])}else{let Q=Cy(I),j=new Q(Re);new Uint8Array(j.buffer,j.byteOffset,j.byteLength).set(o.HEAPU8.subarray(V,V+j.byteLength)),X.push([I,Se,j,"cpu"])}}finally{o.stackRestore(oe),I==="string"&&V&&o._free(V),F||o._OrtReleaseTensor(K),(J=o.webnnOnRunEnd)==null||J.call(o,u)}}return d&&!f&&(o._OrtClearBoundOutputs(d.handle)!==0&&Wt("Can't clear bound outputs."),Di.set(e,[u,p,c,d,f,!1])),X}finally{o.stackRestore(b),w.forEach(q=>o._OrtReleaseTensor(q)),M.forEach(q=>o._OrtReleaseTensor(q)),x.forEach(q=>o._free(q)),_!==0&&o._OrtReleaseRunOptions(_),h.forEach(q=>o._free(q))}},Qy=e=>{let t=Xt(),n=Di.get(e);if(!n)throw new Error("invalid session id");let r=n[0],s=t._OrtEndProfiling(r);s===0&&Wt("Can't get an profile file name."),t._OrtFree(s)},Xy=e=>{let t=[];for(let n of e){let r=n[2];!Array.isArray(r)&&"buffer"in r&&t.push(r.buffer)}return t}}),Oi,Er,Fa,_u,gu,Jd,P_,Zd,Ro,Bo,QS,gF,yF,vF,wF,MF,xF,bF,TF=Ue(()=>{Rs(),_F(),ga(),Ey(),Oi=()=>!!Zt.wasm.proxy&&typeof document<"u",Fa=!1,_u=!1,gu=!1,Zd=new Map,Ro=(e,t)=>{let n=Zd.get(e);n?n.push(t):Zd.set(e,[t])},Bo=()=>{if(Fa||!_u||gu||!Er)throw new Error("worker not ready")},QS=e=>{switch(e.data.type){case"init-wasm":Fa=!1,e.data.err?(gu=!0,P_[1](e.data.err)):(_u=!0,P_[0]()),Jd&&(URL.revokeObjectURL(Jd),Jd=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=Zd.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},gF=async()=>{if(!_u){if(Fa)throw new Error("multiple calls to 'initWasm()' detected.");if(gu)throw new Error("previous call to 'initWasm()' failed.");if(Fa=!0,Oi())return new Promise((e,t)=>{Er==null||Er.terminate(),mA().then(([n,r])=>{try{Er=r,Er.onerror=i=>t(i),Er.onmessage=QS,P_=[e,t];let s={type:"init-wasm",in:Zt};!s.in.wasm.wasmPaths&&(n||Bg)&&(s.in.wasm.wasmPaths={wasm:new URL(""+new URL("ort-wasm-simd-threaded.jsep-B0T3yYHD.wasm",import.meta.url).href,import.meta.url).href}),Er.postMessage(s),Jd=n}catch(s){t(s)}},t)});try{await Py(Zt.wasm),await Wy(Zt),_u=!0}catch(e){throw gu=!0,e}finally{Fa=!1}}},yF=async e=>{if(Oi())return Bo(),new Promise((t,n)=>{Ro("init-ep",[t,n]);let r={type:"init-ep",in:{epName:e,env:Zt}};Er.postMessage(r)});await Gy(Zt,e)},vF=async e=>Oi()?(Bo(),new Promise((t,n)=>{Ro("copy-from",[t,n]);let r={type:"copy-from",in:{buffer:e}};Er.postMessage(r,[e.buffer])})):uf(e),wF=async(e,t)=>{if(Oi()){if(t!=null&&t.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Bo(),new Promise((n,r)=>{Ro("create",[n,r]);let s={type:"create",in:{model:e,options:{...t}}},i=[];e instanceof Uint8Array&&i.push(e.buffer),Er.postMessage(s,i)})}else return Hy(e,t)},MF=async e=>{if(Oi())return Bo(),new Promise((t,n)=>{Ro("release",[t,n]);let r={type:"release",in:e};Er.postMessage(r)});Ky(e)},xF=async(e,t,n,r,s,i)=>{if(Oi()){if(n.some(o=>o[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(s.some(o=>o))throw new Error("pre-allocated output tensor is not supported for proxy.");return Bo(),new Promise((o,a)=>{Ro("run",[o,a]);let l=n,u={type:"run",in:{sessionId:e,inputIndices:t,inputs:l,outputIndices:r,options:i}};Er.postMessage(u,Xy(l))})}else return qy(e,t,n,r,s,i)},bF=async e=>{if(Oi())return Bo(),new Promise((t,n)=>{Ro("end-profiling",[t,n]);let r={type:"end-profiling",in:e};Er.postMessage(r)});Qy(e)}}),S_,XS,EF,QU=Ue(()=>{Rs(),TF(),mt(),Ty(),vA(),S_=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},XS=e=>{switch(e[3]){case"cpu":return new As(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!ky(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:s}=e[2];return As.fromGpuBuffer(n,{dataType:t,dims:e[1],download:r,dispose:s})}case"ml-tensor":{let t=e[0];if(!$y(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:r,dispose:s}=e[2];return As.fromMLTensor(n,{dataType:t,dims:e[1],download:r,dispose:s})}default:throw new Error(`invalid data location: ${e[3]}`)}},EF=class{async fetchModelAndCopyToWasmMemory(e){return vF(await Iy(e))}async loadModel(e,t){zs();let n;typeof e=="string"?n=await this.fetchModelAndCopyToWasmMemory(e):n=e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await wF(n,t),ds()}async dispose(){return MF(this.sessionId)}async run(e,t,n){zs();let r=[],s=[];Object.entries(e).forEach(c=>{let d=c[0],f=c[1],m=this.inputNames.indexOf(d);if(m===-1)throw new Error(`invalid input '${d}'`);r.push(f),s.push(m)});let i=[],o=[];Object.entries(t).forEach(c=>{let d=c[0],f=c[1],m=this.outputNames.indexOf(d);if(m===-1)throw new Error(`invalid output '${d}'`);i.push(f),o.push(m)});let a=r.map((c,d)=>S_(c,()=>`input "${this.inputNames[s[d]]}"`)),l=i.map((c,d)=>c?S_(c,()=>`output "${this.outputNames[o[d]]}"`):null),u=await xF(this.sessionId,s,a,o,l,n),p={};for(let c=0;c<u.length;c++)p[this.outputNames[o[c]]]=i[c]??XS(u[c]);return ds(),p}startProfiling(){}endProfiling(){bF(this.sessionId)}}}),PF={};Tl(PF,{OnnxruntimeWebAssemblyBackend:()=>e0,initializeFlags:()=>Zg,wasmBackend:()=>SF});var Zg,e0,SF,XU=Ue(()=>{Rs(),TF(),QU(),Zg=()=>{(typeof Zt.wasm.initTimeout!="number"||Zt.wasm.initTimeout<0)&&(Zt.wasm.initTimeout=0);let e=Zt.wasm.simd;if(typeof e!="boolean"&&e!==void 0&&e!=="fixed"&&e!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${e}". Reset it to \`false\` and ignore SIMD feature checking.`),Zt.wasm.simd=!1),typeof Zt.wasm.proxy!="boolean"&&(Zt.wasm.proxy=!1),typeof Zt.wasm.trace!="boolean"&&(Zt.wasm.trace=!1),typeof Zt.wasm.numThreads!="number"||!Number.isInteger(Zt.wasm.numThreads)||Zt.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)Zt.wasm.numThreads=1;else{let t=typeof navigator>"u"?LV("node:os").cpus().length:navigator.hardwareConcurrency;Zt.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},e0=class{async init(e){Zg(),await gF(),await yF(e)}async createInferenceSessionHandler(e,t){let n=new EF;return await n.loadModel(e,t),n}},SF=new e0});Rs();Rs();Rs();var YU="1.22.0-dev.20250409-89f8206ba4",JU=uA;{let e=(XU(),uc(PF)).wasmBackend;Jo("webgpu",e,5),Jo("webnn",e,5),Jo("cpu",e,10),Jo("wasm",e,10)}Object.defineProperty(Zt.versions,"web",{value:YU,enumerable:!0});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZU=Object.freeze(Object.defineProperty({__proto__:null,get InferenceSession(){return by},get TRACE(){return cc},get TRACE_FUNC_BEGIN(){return zs},get TRACE_FUNC_END(){return ds},get Tensor(){return As},default:JU,get env(){return Zt},get registerBackend(){return Jo}},Symbol.toStringTag,{value:"Module"}));var ri={},eW={"onnxruntime-common":e=>{e.exports=AV},"onnxruntime-web":e=>{e.exports=ZU},"?2ce3":()=>{},"?7a2c":()=>{},"?a42a":()=>{},"?2b25":()=>{},"?569f":()=>{},"?3f59":()=>{},"?154a":()=>{},"./node_modules/@huggingface/jinja/dist/index.js":(e,t,n)=>{n.r(t),n.d(t,{Environment:()=>Ce,Interpreter:()=>De,Template:()=>je,parse:()=>F,tokenize:()=>c});var r=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",NullLiteral:"NullLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndSet:"EndSet",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator",Macro:"Macro",EndMacro:"EndMacro"}),s=Object.freeze({set:r.Set,for:r.For,in:r.In,is:r.Is,if:r.If,else:r.Else,endset:r.EndSet,endif:r.EndIf,elif:r.ElseIf,endfor:r.EndFor,and:r.And,or:r.Or,not:r.Not,"not in":r.NotIn,macro:r.Macro,endmacro:r.EndMacro,true:r.BooleanLiteral,false:r.BooleanLiteral,none:r.NullLiteral,True:r.BooleanLiteral,False:r.BooleanLiteral,None:r.NullLiteral}),i=class{constructor(L,re){this.value=L,this.type=re}};function o(L){return/\w/.test(L)}function a(L){return/[0-9]/.test(L)}var l=[["{%",r.OpenStatement],["%}",r.CloseStatement],["{{",r.OpenExpression],["}}",r.CloseExpression],["(",r.OpenParen],[")",r.CloseParen],["{",r.OpenCurlyBracket],["}",r.CloseCurlyBracket],["[",r.OpenSquareBracket],["]",r.CloseSquareBracket],[",",r.Comma],[".",r.Dot],[":",r.Colon],["|",r.Pipe],["<=",r.ComparisonBinaryOperator],[">=",r.ComparisonBinaryOperator],["==",r.ComparisonBinaryOperator],["!=",r.ComparisonBinaryOperator],["<",r.ComparisonBinaryOperator],[">",r.ComparisonBinaryOperator],["+",r.AdditiveBinaryOperator],["-",r.AdditiveBinaryOperator],["*",r.MultiplicativeBinaryOperator],["/",r.MultiplicativeBinaryOperator],["%",r.MultiplicativeBinaryOperator],["=",r.Equals]],u=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function p(L,re={}){return L.endsWith(`
`)&&(L=L.slice(0,-1)),L=L.replace(/{#.*?#}/gs,"{##}"),re.lstrip_blocks&&(L=L.replace(/^[ \t]*({[#%])/gm,"$1")),re.trim_blocks&&(L=L.replace(/([#%]})\n/g,"$1")),L.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function c(L,re={}){var Te,Ae,$e;const R=[],ne=p(L,re);let ue=0;const ve=Ve=>{let Je="";for(;Ve(ne[ue]);){if(ne[ue]==="\\"){if(++ue,ue>=ne.length)throw new SyntaxError("Unexpected end of input");const qe=ne[ue++],pt=u.get(qe);if(pt===void 0)throw new SyntaxError(`Unexpected escaped character: ${qe}`);Je+=pt;continue}if(Je+=ne[ue++],ue>=ne.length)throw new SyntaxError("Unexpected end of input")}return Je};e:for(;ue<ne.length;){const Ve=(Te=R.at(-1))==null?void 0:Te.type;if(Ve===void 0||Ve===r.CloseStatement||Ve===r.CloseExpression){let qe="";for(;ue<ne.length&&!(ne[ue]==="{"&&(ne[ue+1]==="%"||ne[ue+1]==="{"));)qe+=ne[ue++];if(qe.length>0){R.push(new i(qe,r.Text));continue}}ve(qe=>/\s/.test(qe));const Je=ne[ue];if(Je==="-"||Je==="+"){const qe=(Ae=R.at(-1))==null?void 0:Ae.type;if(qe===r.Text||qe===void 0)throw new SyntaxError(`Unexpected character: ${Je}`);switch(qe){case r.Identifier:case r.NumericLiteral:case r.BooleanLiteral:case r.NullLiteral:case r.StringLiteral:case r.CloseParen:case r.CloseSquareBracket:break;default:{++ue;const pt=ve(a);R.push(new i(`${Je}${pt}`,pt.length>0?r.NumericLiteral:r.UnaryOperator));continue}}}for(const[qe,pt]of l)if(ne.slice(ue,ue+qe.length)===qe){R.push(new i(qe,pt)),ue+=qe.length;continue e}if(Je==="'"||Je==='"'){++ue;const qe=ve(pt=>pt!==Je);R.push(new i(qe,r.StringLiteral)),++ue;continue}if(a(Je)){const qe=ve(a);R.push(new i(qe,r.NumericLiteral));continue}if(o(Je)){const qe=ve(o),pt=Object.hasOwn(s,qe)?s[qe]:r.Identifier;pt===r.In&&(($e=R.at(-1))==null?void 0:$e.type)===r.Not?(R.pop(),R.push(new i("not in",r.NotIn))):R.push(new i(qe,pt));continue}throw new SyntaxError(`Unexpected character: ${Je}`)}return R}var d=class{constructor(){ie(this,"type","Statement")}},f=class extends d{constructor(re){super();ie(this,"type","Program");this.body=re}},m=class extends d{constructor(re,R,ne){super();ie(this,"type","If");this.test=re,this.body=R,this.alternate=ne}},y=class extends d{constructor(re,R,ne,ue){super();ie(this,"type","For");this.loopvar=re,this.iterable=R,this.body=ne,this.defaultBlock=ue}},C=class extends d{constructor(re,R,ne){super();ie(this,"type","Set");this.assignee=re,this.value=R,this.body=ne}},_=class extends d{constructor(re,R,ne){super();ie(this,"type","Macro");this.name=re,this.args=R,this.body=ne}},h=class extends d{constructor(){super(...arguments);ie(this,"type","Expression")}},w=class extends h{constructor(re,R,ne){super();ie(this,"type","MemberExpression");this.object=re,this.property=R,this.computed=ne}},M=class extends h{constructor(re,R){super();ie(this,"type","CallExpression");this.callee=re,this.args=R}},x=class extends h{constructor(re){super();ie(this,"type","Identifier");this.value=re}},b=class extends h{constructor(re){super();ie(this,"type","Literal");this.value=re}},T=class extends b{constructor(){super(...arguments);ie(this,"type","NumericLiteral")}},S=class extends b{constructor(){super(...arguments);ie(this,"type","StringLiteral")}},$=class extends b{constructor(){super(...arguments);ie(this,"type","BooleanLiteral")}},O=class extends b{constructor(){super(...arguments);ie(this,"type","NullLiteral")}},G=class extends b{constructor(){super(...arguments);ie(this,"type","ArrayLiteral")}},H=class extends b{constructor(){super(...arguments);ie(this,"type","TupleLiteral")}},N=class extends b{constructor(){super(...arguments);ie(this,"type","ObjectLiteral")}},J=class extends h{constructor(re,R,ne){super();ie(this,"type","BinaryExpression");this.operator=re,this.left=R,this.right=ne}},q=class extends h{constructor(re,R){super();ie(this,"type","FilterExpression");this.operand=re,this.filter=R}},X=class extends h{constructor(re,R){super();ie(this,"type","SelectExpression");this.iterable=re,this.test=R}},Y=class extends h{constructor(re,R,ne){super();ie(this,"type","TestExpression");this.operand=re,this.negate=R,this.test=ne}},K=class extends h{constructor(re,R){super();ie(this,"type","UnaryExpression");this.operator=re,this.argument=R}},oe=class extends h{constructor(re=void 0,R=void 0,ne=void 0){super();ie(this,"type","SliceExpression");this.start=re,this.stop=R,this.step=ne}},se=class extends h{constructor(re,R){super();ie(this,"type","KeywordArgumentExpression");this.key=re,this.value=R}};function F(L){const re=new f([]);let R=0;function ne(Be,et){const it=L[R++];if(!it||it.type!==Be)throw new Error(`Parser Error: ${et}. ${it.type} !== ${Be}.`);return it}function ue(){switch(L[R].type){case r.Text:return Ae();case r.OpenStatement:return $e();case r.OpenExpression:return Ve();default:throw new SyntaxError(`Unexpected token type: ${L[R].type}`)}}function ve(...Be){return R+Be.length<=L.length&&Be.some((et,it)=>et!==L[R+it].type)}function Te(...Be){return R+Be.length<=L.length&&Be.every((et,it)=>et===L[R+it].type)}function Ae(){return new S(ne(r.Text,"Expected text token").value)}function $e(){ne(r.OpenStatement,"Expected opening statement token");let Be;switch(L[R].type){case r.Set:++R,Be=Je(),ne(r.CloseStatement,"Expected closing statement token");break;case r.If:++R,Be=qe(),ne(r.OpenStatement,"Expected {% token"),ne(r.EndIf,"Expected endif token"),ne(r.CloseStatement,"Expected %} token");break;case r.Macro:++R,Be=pt(),ne(r.OpenStatement,"Expected {% token"),ne(r.EndMacro,"Expected endmacro token"),ne(r.CloseStatement,"Expected %} token");break;case r.For:++R,Be=Ht(),ne(r.OpenStatement,"Expected {% token"),ne(r.EndFor,"Expected endfor token"),ne(r.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${L[R].type}`)}return Be}function Ve(){ne(r.OpenExpression,"Expected opening expression token");const Be=$t();return ne(r.CloseExpression,"Expected closing expression token"),Be}function Je(){var et,it;const Be=$t();if(Te(r.Equals)){++R;const Yt=$t();return new C(Be,Yt,[])}else{const Yt=[];for(ne(r.CloseStatement,"Expected %} token");!(((et=L[R])==null?void 0:et.type)===r.OpenStatement&&((it=L[R+1])==null?void 0:it.type)===r.EndSet);){const Or=ue();Yt.push(Or)}return ne(r.OpenStatement,"Expected {% token"),ne(r.EndSet,"Expected endset token"),new C(Be,null,Yt)}}function qe(){var Yt,Or,_r,gs,ys,Yr,vs,ws;const Be=$t();ne(r.CloseStatement,"Expected closing statement token");const et=[],it=[];for(;!(((Yt=L[R])==null?void 0:Yt.type)===r.OpenStatement&&(((Or=L[R+1])==null?void 0:Or.type)===r.ElseIf||((_r=L[R+1])==null?void 0:_r.type)===r.Else||((gs=L[R+1])==null?void 0:gs.type)===r.EndIf));)et.push(ue());if(((ys=L[R])==null?void 0:ys.type)===r.OpenStatement&&((Yr=L[R+1])==null?void 0:Yr.type)!==r.EndIf)if(++R,Te(r.ElseIf))ne(r.ElseIf,"Expected elseif token"),it.push(qe());else for(ne(r.Else,"Expected else token"),ne(r.CloseStatement,"Expected closing statement token");!(((vs=L[R])==null?void 0:vs.type)===r.OpenStatement&&((ws=L[R+1])==null?void 0:ws.type)===r.EndIf);)it.push(ue());return new m(Be,et,it)}function pt(){const Be=fn();if(Be.type!=="Identifier")throw new SyntaxError("Expected identifier following macro statement");const et=hs();ne(r.CloseStatement,"Expected closing statement token");const it=[];for(;ve(r.OpenStatement,r.EndMacro);)it.push(ue());return new _(Be,et,it)}function Tt(Be=!1){const et=Be?fn:$t,it=[et()],Yt=Te(r.Comma);for(;Yt&&(++R,it.push(et()),!!Te(r.Comma)););return Yt?new H(it):it[0]}function Ht(){const Be=Tt(!0);if(!(Be instanceof x||Be instanceof H))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${Be.type} instead`);ne(r.In,"Expected `in` keyword following loop variable");const et=$t();ne(r.CloseStatement,"Expected closing statement token");const it=[];for(;ve(r.OpenStatement,r.EndFor)&&ve(r.OpenStatement,r.Else);)it.push(ue());const Yt=[];if(Te(r.OpenStatement,r.Else))for(++R,++R,ne(r.CloseStatement,"Expected closing statement token");ve(r.OpenStatement,r.EndFor);)Yt.push(ue());return new y(Be,et,it,Yt)}function $t(){return Pn()}function Pn(){const Be=ht();if(Te(r.If)){++R;const et=ht();if(Te(r.Else)){++R;const it=ht();return new m(et,[Be],[it])}else return new X(Be,et)}return Be}function ht(){let Be=Ft();for(;Te(r.Or);){const et=L[R];++R;const it=Ft();Be=new J(et,Be,it)}return Be}function Ft(){let Be=Ct();for(;Te(r.And);){const et=L[R];++R;const it=Ct();Be=new J(et,Be,it)}return Be}function Ct(){let Be;for(;Te(r.Not);){const et=L[R];++R;const it=Ct();Be=new K(et,it)}return Be??Bn()}function Bn(){let Be=An();for(;Te(r.ComparisonBinaryOperator)||Te(r.In)||Te(r.NotIn);){const et=L[R];++R;const it=An();Be=new J(et,Be,it)}return Be}function An(){let Be=ms();for(;Te(r.AdditiveBinaryOperator);){const et=L[R];++R;const it=ms();Be=new J(et,Be,it)}return Be}function Dr(){const Be=Gt(fn());return Te(r.OpenParen)?ft(Be):Be}function ft(Be){let et=new M(Be,hs());return et=Gt(et),Te(r.OpenParen)&&(et=ft(et)),et}function hs(){ne(r.OpenParen,"Expected opening parenthesis for arguments list");const Be=br();return ne(r.CloseParen,"Expected closing parenthesis for arguments list"),Be}function br(){const Be=[];for(;!Te(r.CloseParen);){let et=$t();if(Te(r.Equals)){if(++R,!(et instanceof x))throw new SyntaxError("Expected identifier for keyword argument");const it=$t();et=new se(et,it)}Be.push(et),Te(r.Comma)&&++R}return Be}function Bs(){const Be=[];let et=!1;for(;!Te(r.CloseSquareBracket);)Te(r.Colon)?(Be.push(void 0),++R,et=!0):(Be.push($t()),Te(r.Colon)&&(++R,et=!0));if(Be.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(et){if(Be.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new oe(...Be)}return Be[0]}function Gt(Be){for(;Te(r.Dot)||Te(r.OpenSquareBracket);){const et=L[R];++R;let it;const Yt=et.type!==r.Dot;if(Yt)it=Bs(),ne(r.CloseSquareBracket,"Expected closing square bracket");else if(it=fn(),it.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");Be=new w(Be,it,Yt)}return Be}function ms(){let Be=_s();for(;Te(r.MultiplicativeBinaryOperator);){const et=L[R];++R;const it=_s();Be=new J(et,Be,it)}return Be}function _s(){let Be=Ns();for(;Te(r.Is);){++R;const et=Te(r.Not);et&&++R;let it=fn();if(it instanceof $?it=new x(it.value.toString()):it instanceof O&&(it=new x("none")),!(it instanceof x))throw new SyntaxError("Expected identifier for the test");Be=new Y(Be,et,it)}return Be}function Ns(){let Be=Dr();for(;Te(r.Pipe);){++R;let et=fn();if(!(et instanceof x))throw new SyntaxError("Expected identifier for the filter");Te(r.OpenParen)&&(et=ft(et)),Be=new q(Be,et)}return Be}function fn(){const Be=L[R];switch(Be.type){case r.NumericLiteral:return++R,new T(Number(Be.value));case r.StringLiteral:return++R,new S(Be.value);case r.BooleanLiteral:return++R,new $(Be.value.toLowerCase()==="true");case r.NullLiteral:return++R,new O(null);case r.Identifier:return++R,new x(Be.value);case r.OpenParen:{++R;const et=Tt();if(L[R].type!==r.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${L[R].type} instead`);return++R,et}case r.OpenSquareBracket:{++R;const et=[];for(;!Te(r.CloseSquareBracket);)et.push($t()),Te(r.Comma)&&++R;return++R,new G(et)}case r.OpenCurlyBracket:{++R;const et=new Map;for(;!Te(r.CloseCurlyBracket);){const it=$t();ne(r.Colon,"Expected colon between key and value in object literal");const Yt=$t();et.set(it,Yt),Te(r.Comma)&&++R}return++R,new N(et)}default:throw new SyntaxError(`Unexpected token: ${Be.type}`)}}for(;R<L.length;)re.body.push(ue());return re}function I(L,re,R=1){re===void 0&&(re=L,L=0);const ne=[];for(let ue=L;ue<re;ue+=R)ne.push(ue);return ne}function V(L,re,R,ne=1){const ue=Math.sign(ne);ue>=0?(re=(re??(re=0))<0?Math.max(L.length+re,0):Math.min(re,L.length),R=(R??(R=L.length))<0?Math.max(L.length+R,0):Math.min(R,L.length)):(re=(re??(re=L.length-1))<0?Math.max(L.length+re,-1):Math.min(re,L.length-1),R=(R??(R=-1))<-1?Math.max(L.length+R,-1):Math.min(R,L.length-1));const ve=[];for(let Te=re;ue*Te<ue*R;Te+=ne)ve.push(L[Te]);return ve}function ee(L){return L.replace(/\b\w/g,re=>re.toUpperCase())}var pe=class{constructor(L=void 0){ie(this,"type","RuntimeValue");ie(this,"value");ie(this,"builtins",new Map);this.value=L}__bool__(){return new Se(!!this.value)}},Z=class extends pe{constructor(){super(...arguments);ie(this,"type","NumericValue")}},de=class extends pe{constructor(){super(...arguments);ie(this,"type","StringValue");ie(this,"builtins",new Map([["upper",new he(()=>new de(this.value.toUpperCase()))],["lower",new he(()=>new de(this.value.toLowerCase()))],["strip",new he(()=>new de(this.value.trim()))],["title",new he(()=>new de(ee(this.value)))],["length",new Z(this.value.length)],["rstrip",new he(()=>new de(this.value.trimEnd()))],["lstrip",new he(()=>new de(this.value.trimStart()))],["split",new he(re=>{const R=re[0]??new be;if(!(R instanceof de||R instanceof be))throw new Error("sep argument must be a string or null");const ne=re[1]??new Z(-1);if(!(ne instanceof Z))throw new Error("maxsplit argument must be a number");let ue=[];if(R instanceof be){const ve=this.value.trimStart();for(const{0:Te,index:Ae}of ve.matchAll(/\S+/g)){if(ne.value!==-1&&ue.length>=ne.value&&Ae!==void 0){ue.push(Te+ve.slice(Ae+Te.length));break}ue.push(Te)}}else{if(R.value==="")throw new Error("empty separator");ue=this.value.split(R.value),ne.value!==-1&&ue.length>ne.value&&ue.push(ue.splice(ne.value).join(R.value))}return new Q(ue.map(ve=>new de(ve)))})]]))}},Se=class extends pe{constructor(){super(...arguments);ie(this,"type","BooleanValue")}},Re=class extends pe{constructor(){super(...arguments);ie(this,"type","ObjectValue");ie(this,"builtins",new Map([["get",new he(([re,R])=>{if(!(re instanceof de))throw new Error(`Object key must be a string: got ${re.type}`);return this.value.get(re.value)??R??new be})],["items",new he(()=>new Q(Array.from(this.value.entries()).map(([re,R])=>new Q([new de(re),R]))))]]))}__bool__(){return new Se(this.value.size>0)}},ye=class extends Re{constructor(){super(...arguments);ie(this,"type","KeywordArgumentsValue")}},Q=class extends pe{constructor(){super(...arguments);ie(this,"type","ArrayValue");ie(this,"builtins",new Map([["length",new Z(this.value.length)]]))}__bool__(){return new Se(this.value.length>0)}},j=class extends Q{constructor(){super(...arguments);ie(this,"type","TupleValue")}},he=class extends pe{constructor(){super(...arguments);ie(this,"type","FunctionValue")}},be=class extends pe{constructor(){super(...arguments);ie(this,"type","NullValue")}},we=class extends pe{constructor(){super(...arguments);ie(this,"type","UndefinedValue")}},Ce=class{constructor(L){ie(this,"variables",new Map([["namespace",new he(L=>{if(L.length===0)return new Re(new Map);if(L.length!==1||!(L[0]instanceof Re))throw new Error("`namespace` expects either zero arguments or a single object argument");return L[0]})]]));ie(this,"tests",new Map([["boolean",L=>L.type==="BooleanValue"],["callable",L=>L instanceof he],["odd",L=>{if(L.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${L.type}`);return L.value%2!==0}],["even",L=>{if(L.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${L.type}`);return L.value%2===0}],["false",L=>L.type==="BooleanValue"&&!L.value],["true",L=>L.type==="BooleanValue"&&L.value],["none",L=>L.type==="NullValue"],["string",L=>L.type==="StringValue"],["number",L=>L.type==="NumericValue"],["integer",L=>L.type==="NumericValue"&&Number.isInteger(L.value)],["iterable",L=>L.type==="ArrayValue"||L.type==="StringValue"],["mapping",L=>L.type==="ObjectValue"],["lower",L=>{const re=L.value;return L.type==="StringValue"&&re===re.toLowerCase()}],["upper",L=>{const re=L.value;return L.type==="StringValue"&&re===re.toUpperCase()}],["none",L=>L.type==="NullValue"],["defined",L=>L.type!=="UndefinedValue"],["undefined",L=>L.type==="UndefinedValue"],["equalto",(L,re)=>L.value===re.value],["eq",(L,re)=>L.value===re.value]]));this.parent=L}set(L,re){return this.declareVariable(L,Oe(re))}declareVariable(L,re){if(this.variables.has(L))throw new SyntaxError(`Variable already declared: ${L}`);return this.variables.set(L,re),re}setVariable(L,re){return this.variables.set(L,re),re}resolve(L){if(this.variables.has(L))return this;if(this.parent)return this.parent.resolve(L);throw new Error(`Unknown variable: ${L}`)}lookupVariable(L){try{return this.resolve(L).variables.get(L)??new we}catch{return new we}}},De=class{constructor(L){ie(this,"global");this.global=L??new Ce}run(L){return this.evaluate(L,this.global)}evaluateBinaryExpression(L,re){const R=this.evaluate(L.left,re);switch(L.operator.value){case"and":return R.__bool__().value?this.evaluate(L.right,re):R;case"or":return R.__bool__().value?R:this.evaluate(L.right,re)}const ne=this.evaluate(L.right,re);switch(L.operator.value){case"==":return new Se(R.value==ne.value);case"!=":return new Se(R.value!=ne.value)}if(R instanceof we||ne instanceof we)throw new Error("Cannot perform operation on undefined values");if(R instanceof be||ne instanceof be)throw new Error("Cannot perform operation on null values");if(R instanceof Z&&ne instanceof Z)switch(L.operator.value){case"+":return new Z(R.value+ne.value);case"-":return new Z(R.value-ne.value);case"*":return new Z(R.value*ne.value);case"/":return new Z(R.value/ne.value);case"%":return new Z(R.value%ne.value);case"<":return new Se(R.value<ne.value);case">":return new Se(R.value>ne.value);case">=":return new Se(R.value>=ne.value);case"<=":return new Se(R.value<=ne.value)}else if(R instanceof Q&&ne instanceof Q)switch(L.operator.value){case"+":return new Q(R.value.concat(ne.value))}else if(ne instanceof Q){const ue=ne.value.find(ve=>ve.value===R.value)!==void 0;switch(L.operator.value){case"in":return new Se(ue);case"not in":return new Se(!ue)}}if(R instanceof de||ne instanceof de)switch(L.operator.value){case"+":return new de(R.value.toString()+ne.value.toString())}if(R instanceof de&&ne instanceof de)switch(L.operator.value){case"in":return new Se(ne.value.includes(R.value));case"not in":return new Se(!ne.value.includes(R.value))}if(R instanceof de&&ne instanceof Re)switch(L.operator.value){case"in":return new Se(ne.value.has(R.value));case"not in":return new Se(!ne.value.has(R.value))}throw new SyntaxError(`Unknown operator "${L.operator.value}" between ${R.type} and ${ne.type}`)}evaluateArguments(L,re){const R=[],ne=new Map;for(const ue of L)if(ue.type==="KeywordArgumentExpression"){const ve=ue;ne.set(ve.key.value,this.evaluate(ve.value,re))}else{if(ne.size>0)throw new Error("Positional arguments must come before keyword arguments");R.push(this.evaluate(ue,re))}return[R,ne]}evaluateFilterExpression(L,re){const R=this.evaluate(L.operand,re);if(L.filter.type==="Identifier"){const ne=L.filter;if(ne.value==="tojson")return new de(Le(R));if(R instanceof Q)switch(ne.value){case"list":return R;case"first":return R.value[0];case"last":return R.value[R.value.length-1];case"length":return new Z(R.value.length);case"reverse":return new Q(R.value.reverse());case"sort":return new Q(R.value.sort((ue,ve)=>{if(ue.type!==ve.type)throw new Error(`Cannot compare different types: ${ue.type} and ${ve.type}`);switch(ue.type){case"NumericValue":return ue.value-ve.value;case"StringValue":return ue.value.localeCompare(ve.value);default:throw new Error(`Cannot compare type: ${ue.type}`)}}));case"join":return new de(R.value.map(ue=>ue.value).join(""));case"string":return new de(Le(R));default:throw new Error(`Unknown ArrayValue filter: ${ne.value}`)}else if(R instanceof de)switch(ne.value){case"length":return new Z(R.value.length);case"upper":return new de(R.value.toUpperCase());case"lower":return new de(R.value.toLowerCase());case"title":return new de(ee(R.value));case"capitalize":return new de(R.value.charAt(0).toUpperCase()+R.value.slice(1));case"trim":return new de(R.value.trim());case"indent":return new de(R.value.split(`
`).map((ue,ve)=>ve===0||ue.length===0?ue:"    "+ue).join(`
`));case"join":case"string":return R;default:throw new Error(`Unknown StringValue filter: ${ne.value}`)}else if(R instanceof Z)switch(ne.value){case"abs":return new Z(Math.abs(R.value));default:throw new Error(`Unknown NumericValue filter: ${ne.value}`)}else if(R instanceof Re)switch(ne.value){case"items":return new Q(Array.from(R.value.entries()).map(([ue,ve])=>new Q([new de(ue),ve])));case"length":return new Z(R.value.size);default:throw new Error(`Unknown ObjectValue filter: ${ne.value}`)}throw new Error(`Cannot apply filter "${ne.value}" to type: ${R.type}`)}else if(L.filter.type==="CallExpression"){const ne=L.filter;if(ne.callee.type!=="Identifier")throw new Error(`Unknown filter: ${ne.callee.type}`);const ue=ne.callee.value;if(ue==="tojson"){const[,ve]=this.evaluateArguments(ne.args,re),Te=ve.get("indent")??new be;if(!(Te instanceof Z||Te instanceof be))throw new Error("If set, indent must be a number");return new de(Le(R,Te.value))}else if(ue==="join"){let ve;if(R instanceof de)ve=Array.from(R.value);else if(R instanceof Q)ve=R.value.map(Ve=>Ve.value);else throw new Error(`Cannot apply filter "${ue}" to type: ${R.type}`);const[Te,Ae]=this.evaluateArguments(ne.args,re),$e=Te.at(0)??Ae.get("separator")??new de("");if(!($e instanceof de))throw new Error("separator must be a string");return new de(ve.join($e.value))}if(R instanceof Q){switch(ue){case"selectattr":case"rejectattr":{const ve=ue==="selectattr";if(R.value.some(qe=>!(qe instanceof Re)))throw new Error(`\`${ue}\` can only be applied to array of objects`);if(ne.args.some(qe=>qe.type!=="StringLiteral"))throw new Error(`arguments of \`${ue}\` must be strings`);const[Te,Ae,$e]=ne.args.map(qe=>this.evaluate(qe,re));let Ve;if(Ae){const qe=re.tests.get(Ae.value);if(!qe)throw new Error(`Unknown test: ${Ae.value}`);Ve=qe}else Ve=(...qe)=>qe[0].__bool__().value;const Je=R.value.filter(qe=>{const pt=qe.value.get(Te.value),Tt=pt?Ve(pt,$e):!1;return ve?Tt:!Tt});return new Q(Je)}case"map":{const[,ve]=this.evaluateArguments(ne.args,re);if(ve.has("attribute")){const Te=ve.get("attribute");if(!(Te instanceof de))throw new Error("attribute must be a string");const Ae=ve.get("default"),$e=R.value.map(Ve=>{if(!(Ve instanceof Re))throw new Error("items in map must be an object");return Ve.value.get(Te.value)??Ae??new we});return new Q($e)}else throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${ue}`)}else if(R instanceof de){switch(ue){case"indent":{const[ve,Te]=this.evaluateArguments(ne.args,re),Ae=ve.at(0)??Te.get("width")??new Z(4);if(!(Ae instanceof Z))throw new Error("width must be a number");const $e=ve.at(1)??Te.get("first")??new Se(!1),Ve=ve.at(2)??Te.get("blank")??new Se(!1),Je=R.value.split(`
`),qe=" ".repeat(Ae.value),pt=Je.map((Tt,Ht)=>!$e.value&&Ht===0||!Ve.value&&Tt.length===0?Tt:qe+Tt);return new de(pt.join(`
`))}}throw new Error(`Unknown StringValue filter: ${ue}`)}else throw new Error(`Cannot apply filter "${ue}" to type: ${R.type}`)}throw new Error(`Unknown filter: ${L.filter.type}`)}evaluateTestExpression(L,re){const R=this.evaluate(L.operand,re),ne=re.tests.get(L.test.value);if(!ne)throw new Error(`Unknown test: ${L.test.value}`);const ue=ne(R);return new Se(L.negate?!ue:ue)}evaluateUnaryExpression(L,re){const R=this.evaluate(L.argument,re);switch(L.operator.value){case"not":return new Se(!R.value);default:throw new SyntaxError(`Unknown operator: ${L.operator.value}`)}}evalProgram(L,re){return this.evaluateBlock(L.body,re)}evaluateBlock(L,re){let R="";for(const ne of L){const ue=this.evaluate(ne,re);ue.type!=="NullValue"&&ue.type!=="UndefinedValue"&&(R+=ue.value)}return new de(R)}evaluateIdentifier(L,re){return re.lookupVariable(L.value)}evaluateCallExpression(L,re){const[R,ne]=this.evaluateArguments(L.args,re);ne.size>0&&R.push(new ye(ne));const ue=this.evaluate(L.callee,re);if(ue.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${ue.type}`);return ue.value(R,re)}evaluateSliceExpression(L,re,R){if(!(L instanceof Q||L instanceof de))throw new Error("Slice object must be an array or string");const ne=this.evaluate(re.start,R),ue=this.evaluate(re.stop,R),ve=this.evaluate(re.step,R);if(!(ne instanceof Z||ne instanceof we))throw new Error("Slice start must be numeric or undefined");if(!(ue instanceof Z||ue instanceof we))throw new Error("Slice stop must be numeric or undefined");if(!(ve instanceof Z||ve instanceof we))throw new Error("Slice step must be numeric or undefined");return L instanceof Q?new Q(V(L.value,ne.value,ue.value,ve.value)):new de(V(Array.from(L.value),ne.value,ue.value,ve.value).join(""))}evaluateMemberExpression(L,re){const R=this.evaluate(L.object,re);let ne;if(L.computed){if(L.property.type==="SliceExpression")return this.evaluateSliceExpression(R,L.property,re);ne=this.evaluate(L.property,re)}else ne=new de(L.property.value);let ue;if(R instanceof Re){if(!(ne instanceof de))throw new Error(`Cannot access property with non-string: got ${ne.type}`);ue=R.value.get(ne.value)??R.builtins.get(ne.value)}else if(R instanceof Q||R instanceof de)if(ne instanceof Z)ue=R.value.at(ne.value),R instanceof de&&(ue=new de(R.value.at(ne.value)));else if(ne instanceof de)ue=R.builtins.get(ne.value);else throw new Error(`Cannot access property with non-string/non-number: got ${ne.type}`);else{if(!(ne instanceof de))throw new Error(`Cannot access property with non-string: got ${ne.type}`);ue=R.builtins.get(ne.value)}return ue instanceof pe?ue:new we}evaluateSet(L,re){const R=L.value?this.evaluate(L.value,re):this.evaluateBlock(L.body,re);if(L.assignee.type==="Identifier"){const ne=L.assignee.value;re.setVariable(ne,R)}else if(L.assignee.type==="MemberExpression"){const ne=L.assignee,ue=this.evaluate(ne.object,re);if(!(ue instanceof Re))throw new Error("Cannot assign to member of non-object");if(ne.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");ue.value.set(ne.property.value,R)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(L.assignee)}`);return new be}evaluateIf(L,re){const R=this.evaluate(L.test,re);return this.evaluateBlock(R.__bool__().value?L.body:L.alternate,re)}evaluateFor(L,re){const R=new Ce(re);let ne,ue;if(L.iterable.type==="SelectExpression"){const Ve=L.iterable;ue=this.evaluate(Ve.iterable,R),ne=Ve.test}else ue=this.evaluate(L.iterable,R);if(!(ue instanceof Q))throw new Error(`Expected iterable type in for loop: got ${ue.type}`);const ve=[],Te=[];for(let Ve=0;Ve<ue.value.length;++Ve){const Je=new Ce(R),qe=ue.value[Ve];let pt;if(L.loopvar.type==="Identifier")pt=Tt=>Tt.setVariable(L.loopvar.value,qe);else if(L.loopvar.type==="TupleLiteral"){const Tt=L.loopvar;if(qe.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${qe.type}`);const Ht=qe;if(Tt.value.length!==Ht.value.length)throw new Error(`Too ${Tt.value.length>Ht.value.length?"few":"many"} items to unpack`);pt=$t=>{for(let Pn=0;Pn<Tt.value.length;++Pn){if(Tt.value[Pn].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${Tt.value[Pn].type}`);$t.setVariable(Tt.value[Pn].value,Ht.value[Pn])}}}else throw new Error(`Invalid loop variable(s): ${L.loopvar.type}`);ne&&(pt(Je),!this.evaluate(ne,Je).__bool__().value)||(ve.push(qe),Te.push(pt))}let Ae="",$e=!0;for(let Ve=0;Ve<ve.length;++Ve){const Je=new Map([["index",new Z(Ve+1)],["index0",new Z(Ve)],["revindex",new Z(ve.length-Ve)],["revindex0",new Z(ve.length-Ve-1)],["first",new Se(Ve===0)],["last",new Se(Ve===ve.length-1)],["length",new Z(ve.length)],["previtem",Ve>0?ve[Ve-1]:new we],["nextitem",Ve<ve.length-1?ve[Ve+1]:new we]]);R.setVariable("loop",new Re(Je)),Te[Ve](R);const qe=this.evaluateBlock(L.body,R);Ae+=qe.value,$e=!1}if($e){const Ve=this.evaluateBlock(L.defaultBlock,R);Ae+=Ve.value}return new de(Ae)}evaluateMacro(L,re){return re.setVariable(L.name.value,new he((R,ne)=>{var Te;const ue=new Ce(ne);R=R.slice();let ve;((Te=R.at(-1))==null?void 0:Te.type)==="KeywordArgumentsValue"&&(ve=R.pop());for(let Ae=0;Ae<L.args.length;++Ae){const $e=L.args[Ae],Ve=R[Ae];if($e.type==="Identifier"){const Je=$e;if(!Ve)throw new Error(`Missing positional argument: ${Je.value}`);ue.setVariable(Je.value,Ve)}else if($e.type==="KeywordArgumentExpression"){const Je=$e,qe=Ve??(ve==null?void 0:ve.value.get(Je.key.value))??this.evaluate(Je.value,ue);ue.setVariable(Je.key.value,qe)}else throw new Error(`Unknown argument type: ${$e.type}`)}return this.evaluateBlock(L.body,ue)})),new be}evaluate(L,re){if(L===void 0)return new we;switch(L.type){case"Program":return this.evalProgram(L,re);case"Set":return this.evaluateSet(L,re);case"If":return this.evaluateIf(L,re);case"For":return this.evaluateFor(L,re);case"Macro":return this.evaluateMacro(L,re);case"NumericLiteral":return new Z(Number(L.value));case"StringLiteral":return new de(L.value);case"BooleanLiteral":return new Se(L.value);case"NullLiteral":return new be(L.value);case"ArrayLiteral":return new Q(L.value.map(R=>this.evaluate(R,re)));case"TupleLiteral":return new j(L.value.map(R=>this.evaluate(R,re)));case"ObjectLiteral":{const R=new Map;for(const[ne,ue]of L.value){const ve=this.evaluate(ne,re);if(!(ve instanceof de))throw new Error(`Object keys must be strings: got ${ve.type}`);R.set(ve.value,this.evaluate(ue,re))}return new Re(R)}case"Identifier":return this.evaluateIdentifier(L,re);case"CallExpression":return this.evaluateCallExpression(L,re);case"MemberExpression":return this.evaluateMemberExpression(L,re);case"UnaryExpression":return this.evaluateUnaryExpression(L,re);case"BinaryExpression":return this.evaluateBinaryExpression(L,re);case"FilterExpression":return this.evaluateFilterExpression(L,re);case"TestExpression":return this.evaluateTestExpression(L,re);default:throw new SyntaxError(`Unknown node type: ${L.type}`)}}};function Oe(L){switch(typeof L){case"number":return new Z(L);case"string":return new de(L);case"boolean":return new Se(L);case"undefined":return new we;case"object":return L===null?new be:Array.isArray(L)?new Q(L.map(Oe)):new Re(new Map(Object.entries(L).map(([re,R])=>[re,Oe(R)])));case"function":return new he((re,R)=>{const ne=L(...re.map(ue=>ue.value))??null;return Oe(ne)});default:throw new Error(`Cannot convert to runtime value: ${L}`)}}function Le(L,re,R){const ne=R??0;switch(L.type){case"NullValue":case"UndefinedValue":return"null";case"NumericValue":case"StringValue":case"BooleanValue":return JSON.stringify(L.value);case"ArrayValue":case"ObjectValue":{const ue=re?" ".repeat(re):"",ve=`
`+ue.repeat(ne),Te=ve+ue;if(L.type==="ArrayValue"){const Ae=L.value.map($e=>Le($e,re,ne+1));return re?`[${Te}${Ae.join(`,${Te}`)}${ve}]`:`[${Ae.join(", ")}]`}else{const Ae=Array.from(L.value.entries()).map(([$e,Ve])=>{const Je=`"${$e}": ${Le(Ve,re,ne+1)}`;return re?`${Te}${Je}`:Je});return re?`{${Ae.join(",")}${ve}}`:`{${Ae.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${L.type}`)}}var je=class{constructor(L){ie(this,"parsed");const re=c(L,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=F(re)}render(L){const re=new Ce;if(re.set("false",!1),re.set("true",!0),re.set("raise_exception",ue=>{throw new Error(ue)}),re.set("range",I),L)for(const[ue,ve]of Object.entries(L))re.set(ue,ve);return new De(re).run(this.parsed).value}}},"./src/backends/onnx.js":(e,t,n)=>{var r;n.r(t),n.d(t,{Tensor:()=>a.Tensor,createInferenceSession:()=>C,deviceToExecutionProviders:()=>m,isONNXProxy:()=>w,isONNXTensor:()=>_});var s=n("./src/env.js"),i=n("?2ce3"),o=n("onnxruntime-web"),a=n("onnxruntime-common");const l=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),u=[];let p,c;const d=Symbol.for("onnxruntime");if(d in globalThis)c=globalThis[d];else if(s.apis.IS_NODE_ENV){switch(c=i??(r||(r=n.t(i,2))),process.platform){case"win32":u.push("dml");break;case"linux":process.arch==="x64"&&u.push("cuda");break}u.push("cpu"),p=["cpu"]}else c=o,s.apis.IS_WEBNN_AVAILABLE&&u.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),s.apis.IS_WEBGPU_AVAILABLE&&u.push("webgpu"),u.push("wasm"),p=["wasm"];const f=c.InferenceSession;function m(M=null){if(!M)return p;switch(M){case"auto":return u;case"gpu":return u.filter(x=>["webgpu","cuda","dml","webnn-gpu"].includes(x))}if(u.includes(M))return[l[M]??M];throw new Error(`Unsupported device: "${M}". Should be one of: ${u.join(", ")}.`)}let y=null;async function C(M,x,b){y&&await y;const T=f.create(M,x);y??(y=T);const S=await T;return S.config=b,S}function _(M){return M instanceof c.Tensor}const h=c==null?void 0:c.env;h!=null&&h.wasm&&(!(typeof ServiceWorkerGlobalScope<"u"&&self instanceof ServiceWorkerGlobalScope)&&!h.wasm.wasmPaths&&(h.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${s.env.version}/dist/`),h.wasm.proxy=!1),h!=null&&h.webgpu&&(h.webgpu.powerPreference="high-performance");function w(){var M;return(M=h==null?void 0:h.wasm)==null?void 0:M.proxy}s.env.backends.onnx=h},"./src/base/feature_extraction_utils.js":(e,t,n)=>{n.r(t),n.d(t,{FeatureExtractor:()=>o,validate_audio_inputs:()=>a});var r=n("./src/utils/constants.js"),s=n("./src/utils/generic.js"),i=n("./src/utils/hub.js");class o extends s.Callable{constructor(u){super(),this.config=u}static async from_pretrained(u,p){const c=await(0,i.getModelJSON)(u,r.FEATURE_EXTRACTOR_NAME,!0,p);return new this(c)}}function a(l,u){var p;if(!(l instanceof Float32Array||l instanceof Float64Array))throw new Error(`${u} expects input to be a Float32Array or a Float64Array, but got ${((p=l==null?void 0:l.constructor)==null?void 0:p.name)??typeof l} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}},"./src/base/image_processors_utils.js":(e,t,n)=>{n.r(t),n.d(t,{ImageProcessor:()=>M,center_to_corners_format:()=>c,post_process_instance_segmentation:()=>w,post_process_object_detection:()=>d,post_process_panoptic_segmentation:()=>h,post_process_semantic_segmentation:()=>f});var r=n("./src/utils/generic.js"),s=n("./src/utils/tensor.js"),i=n("./src/utils/maths.js");n("./src/utils/image.js");var o=n("./src/utils/core.js"),a=n("./src/utils/hub.js"),l=n("./src/utils/constants.js");function u(x,b,T=0,S=null){const $=x/b;let O=(0,i.bankers_round)($)*b;return S!==null&&O>S&&(O=Math.floor($)*b),O<T&&(O=Math.ceil($)*b),O}function p([x,b],T){return[Math.max(Math.floor(x/T),1)*T,Math.max(Math.floor(b/T),1)*T]}function c([x,b,T,S]){return[x-T/2,b-S/2,x+T/2,b+S/2]}function d(x,b=.5,T=null,S=!1){const $=x.logits,O=x.pred_boxes,[G,H,N]=$.dims;if(T!==null&&T.length!==G)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let J=[];for(let q=0;q<G;++q){let X=T!==null?T[q]:null,Y={boxes:[],classes:[],scores:[]},K=$[q],oe=O[q];for(let se=0;se<H;++se){let F=K[se],I=[],V;if(S){V=F.sigmoid().data;for(let ee=0;ee<V.length;++ee)V[ee]>b&&I.push(ee)}else{let ee=(0,i.max)(F.data)[1];if(ee===N-1||(V=(0,i.softmax)(F.data),V[ee]<b))continue;I.push(ee)}for(const ee of I){let pe=oe[se].data;pe=c(pe),X!==null&&(pe=pe.map((Z,de)=>Z*X[(de+1)%2])),Y.boxes.push(pe),Y.classes.push(ee),Y.scores.push(V[ee])}}J.push(Y)}return J}function f(x,b=null){const T=x.logits,S=T.dims[0];if(b!==null&&b.length!==S)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const $=[];for(let O=0;O<S;++O){const G=b!==null?b[O]:null;let H=T[O];G!==null&&(H=(0,s.interpolate)(H,G,"bilinear",!1));const[N,J]=G??H.dims.slice(-2),q=new s.Tensor("int32",new Int32Array(N*J),[N,J]),X=H[0].data,Y=q.data;for(let se=1;se<H.dims[0];++se){const F=H[se].data;for(let I=0;I<F.length;++I)F[I]>X[I]&&(X[I]=F[I],Y[I]=se)}const K=new Array(H.dims[0]);for(let se=0;se<Y.length;++se){const F=Y[se];K[F]=F}const oe=K.filter(se=>se!==void 0);$.push({segmentation:q,labels:oe})}return $}function m(x,b,T,S){const $=[],O=[],G=[];for(let H=0;H<x.dims[0];++H){const N=x[H],J=b[H],q=(0,i.max)(N.data)[1];if(q===S)continue;const Y=(0,i.softmax)(N.data)[q];Y>T&&($.push(J),O.push(Y),G.push(q))}return[$,O,G]}function y(x,b,T,S=.5,$=.8){const O=[];let G=0,H=0;const N=b[T].data;for(let q=0;q<x.length;++q)x[q]===T&&(O.push(q),++G),N[q]>=S&&++H;let J=G>0&&H>0;return J&&(J=G/H>$),[J,O]}function C(x,b,T,S,$,O=null,G=null){const[H,N]=G??x[0].dims,J=new s.Tensor("int32",new Int32Array(H*N),[H,N]),q=[];if(G!==null)for(let se=0;se<x.length;++se)x[se]=(0,s.interpolate)(x[se],G,"bilinear",!1);const X=new Int32Array(x[0].data.length),Y=new Float32Array(x[0].data.length);for(let se=0;se<x.length;++se){let F=b[se];const I=x[se].data;for(let V=0;V<I.length;++V)I[V]*=F,I[V]>Y[V]&&(X[V]=se,Y[V]=I[V])}let K=0;const oe=J.data;for(let se=0;se<T.length;++se){const F=T[se],[I,V]=y(X,x,se,S,$);if(I){++K;for(const ee of V)oe[ee]=K;q.push({id:K,label_id:F,score:b[se]})}}return[J,q]}function _(x,b,T=28,S=56*56,$=14*14*4*1280){if(x<T||b<T)throw new Error(`height:${x} or width:${b} must be larger than factor:${T}`);if(Math.max(x,b)/Math.min(x,b)>200)throw new Error(`absolute aspect ratio must be smaller than 200, got ${Math.max(x,b)/Math.min(x,b)}`);let O=Math.round(x/T)*T,G=Math.round(b/T)*T;if(O*G>$){const H=Math.sqrt(x*b/$);O=Math.floor(x/H/T)*T,G=Math.floor(b/H/T)*T}else if(O*G<S){const H=Math.sqrt(S/(x*b));O=Math.ceil(x*H/T)*T,G=Math.ceil(b*H/T)*T}return[O,G]}function h(x,b=.5,T=.5,S=.8,$=null,O=null){$===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),$=new Set);const G=x.class_queries_logits??x.logits,N=(x.masks_queries_logits??x.pred_masks).sigmoid();let[J,q,X]=G.dims;if(X-=1,O!==null&&O.length!==J)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let Y=[];for(let K=0;K<J;++K){let oe=O!==null?O[K]:null,se=G[K],F=N[K],[I,V,ee]=m(se,F,b,X);if(ee.length===0){let[de,Se]=oe??F.dims.slice(-2),Re=new s.Tensor("int32",new Int32Array(de*Se).fill(-1),[de,Se]);Y.push({segmentation:Re,segments_info:[]});continue}let[pe,Z]=C(I,V,ee,T,S,$,oe);Y.push({segmentation:pe,segments_info:Z})}return Y}function w(x,b=.5,T=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class M extends r.Callable{constructor(b){super(),this.image_mean=b.image_mean??b.mean,this.image_std=b.image_std??b.std,this.resample=b.resample??2,this.do_rescale=b.do_rescale??!0,this.rescale_factor=b.rescale_factor??1/255,this.do_normalize=b.do_normalize,this.do_thumbnail=b.do_thumbnail,this.size=b.size??b.image_size,this.do_resize=b.do_resize??this.size!==void 0,this.size_divisibility=b.size_divisibility??b.size_divisor,this.do_center_crop=b.do_center_crop,this.crop_size=b.crop_size,this.do_convert_rgb=b.do_convert_rgb??!0,this.do_crop_margin=b.do_crop_margin,this.pad_size=b.pad_size,this.do_pad=b.do_pad,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=b.do_flip_channel_order??!1,this.config=b}async thumbnail(b,T,S=2){const $=b.height,O=b.width,G=T.height,H=T.width;let N=Math.min($,G),J=Math.min(O,H);return N===$&&J===O?b:($>O?J=Math.floor(O*N/$):O>$&&(N=Math.floor($*J/O)),await b.resize(J,N,{resample:S}))}async crop_margin(b,T=200){const S=b.clone().grayscale(),$=(0,i.min)(S.data)[0],G=(0,i.max)(S.data)[0]-$;if(G===0)return b;const H=T/255;let N=S.width,J=S.height,q=0,X=0;const Y=S.data;for(let K=0;K<S.height;++K){const oe=K*S.width;for(let se=0;se<S.width;++se)(Y[oe+se]-$)/G<H&&(N=Math.min(N,se),J=Math.min(J,K),q=Math.max(q,se),X=Math.max(X,K))}return b=await b.crop([N,J,q,X]),b}pad_image(b,T,S,{mode:$="constant",center:O=!1,constant_values:G=0}={}){const[H,N,J]=T;let q,X;if(typeof S=="number"?(q=S,X=S):S==="square"?q=X=Math.max(H,N):(q=S.width,X=S.height),q!==N||X!==H){const Y=new Float32Array(q*X*J);if(Array.isArray(G))for(let se=0;se<Y.length;++se)Y[se]=G[se%J];else G!==0&&Y.fill(G);const[K,oe]=O?[Math.floor((q-N)/2),Math.floor((X-H)/2)]:[0,0];for(let se=0;se<H;++se){const F=(se+oe)*q,I=se*N;for(let V=0;V<N;++V){const ee=(F+V+K)*J,pe=(I+V)*J;for(let Z=0;Z<J;++Z)Y[ee+Z]=b[pe+Z]}}if($==="symmetric"){if(O)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const se=H-1,F=N-1;for(let I=0;I<X;++I){const V=I*q,ee=(0,o.calculateReflectOffset)(I,se)*N;for(let pe=0;pe<q;++pe){if(I<H&&pe<N)continue;const Z=(V+pe)*J,de=(ee+(0,o.calculateReflectOffset)(pe,F))*J;for(let Se=0;Se<J;++Se)Y[Z+Se]=b[de+Se]}}}b=Y,T=[X,q,J]}return[b,T]}rescale(b){for(let T=0;T<b.length;++T)b[T]=this.rescale_factor*b[T]}get_resize_output_image_size(b,T){const[S,$]=b.size;let O,G;if(this.do_thumbnail){const{height:H,width:N}=T;O=Math.min(H,N)}else Number.isInteger(T)?(O=T,G=this.config.max_size??O):T!==void 0&&(O=T.shortest_edge,G=T.longest_edge);if(O!==void 0||G!==void 0){const H=O===void 0?1:Math.max(O/S,O/$),N=S*H,J=$*H,q=G===void 0?1:Math.min(G/N,G/J);let X=Math.floor(Number((N*q).toFixed(2))),Y=Math.floor(Number((J*q).toFixed(2)));return this.size_divisibility!==void 0&&([X,Y]=p([X,Y],this.size_divisibility)),[X,Y]}else if(T!==void 0&&T.width!==void 0&&T.height!==void 0){let H=T.width,N=T.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let J=N/$,q=H/S;Math.abs(1-q)<Math.abs(1-J)?J=q:q=J,N=u(J*$,this.config.ensure_multiple_of),H=u(q*S,this.config.ensure_multiple_of)}return[H,N]}else{if(this.size_divisibility!==void 0)return p([S,$],this.size_divisibility);if(T.min_pixels!==void 0&&T.max_pixels!==void 0){const{min_pixels:H,max_pixels:N}=T,J=this.config.patch_size*this.config.merge_size;return _($,S,J,H,N)}else throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(T)}`)}}async resize(b){const[T,S]=this.get_resize_output_image_size(b,this.size);return await b.resize(T,S,{resample:this.resample})}async preprocess(b,{do_normalize:T=null,do_pad:S=null,do_convert_rgb:$=null,do_convert_grayscale:O=null,do_flip_channel_order:G=null}={}){this.do_crop_margin&&(b=await this.crop_margin(b));const[H,N]=b.size;if($??this.do_convert_rgb?b=b.rgb():O&&(b=b.grayscale()),this.do_resize&&(b=await this.resize(b)),this.do_thumbnail&&(b=await this.thumbnail(b,this.size,this.resample)),this.do_center_crop){let K,oe;Number.isInteger(this.crop_size)?(K=this.crop_size,oe=this.crop_size):(K=this.crop_size.width,oe=this.crop_size.height),b=await b.center_crop(K,oe)}const J=[b.height,b.width];let q=Float32Array.from(b.data),X=[b.height,b.width,b.channels];if(this.do_rescale&&this.rescale(q),T??this.do_normalize){let K=this.image_mean;Array.isArray(this.image_mean)||(K=new Array(b.channels).fill(K));let oe=this.image_std;if(Array.isArray(this.image_std)||(oe=new Array(b.channels).fill(K)),K.length!==b.channels||oe.length!==b.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${K.length}) and \`image_std\` (${oe.length}) must match the number of channels in the image (${b.channels}).`);for(let se=0;se<q.length;se+=b.channels)for(let F=0;F<b.channels;++F)q[se+F]=(q[se+F]-K[F])/oe[F]}if(S??this.do_pad){if(this.pad_size)[q,X]=this.pad_image(q,[b.height,b.width,b.channels],this.pad_size);else if(this.size_divisibility){const[K,oe]=p([X[1],X[0]],this.size_divisibility);[q,X]=this.pad_image(q,X,{width:K,height:oe})}}if(G??this.do_flip_channel_order){if(X[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let K=0;K<q.length;K+=3){const oe=q[K];q[K]=q[K+2],q[K+2]=oe}}const Y=new s.Tensor("float32",q,X).permute(2,0,1);return{original_size:[N,H],reshaped_input_size:J,pixel_values:Y}}async _call(b,...T){Array.isArray(b)||(b=[b]);const S=await Promise.all(b.map(O=>this.preprocess(O)));return{pixel_values:(0,s.stack)(S.map(O=>O.pixel_values),0),original_sizes:S.map(O=>O.original_size),reshaped_input_sizes:S.map(O=>O.reshaped_input_size)}}static async from_pretrained(b,T){const S=await(0,a.getModelJSON)(b,l.IMAGE_PROCESSOR_NAME,!0,T);return new this(S)}}},"./src/base/processing_utils.js":(e,t,n)=>{n.r(t),n.d(t,{Processor:()=>o});var r=n("./src/utils/constants.js"),s=n("./src/utils/generic.js"),i=n("./src/utils/hub.js");class o extends s.Callable{constructor(l,u){super(),this.config=l,this.components=u}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(l,u={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(l,{tokenize:!1,...u})}batch_decode(...l){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...l)}decode(...l){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.decode(...l)}async _call(l,...u){for(const p of[this.image_processor,this.feature_extractor,this.tokenizer])if(p)return p(l,...u);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(l,u){const[p,c]=await Promise.all([this.uses_processor_config?(0,i.getModelJSON)(l,r.PROCESSOR_NAME,!0,u):{},Promise.all(this.classes.filter(d=>d in this).map(async d=>{const f=await this[d].from_pretrained(l,u);return[d.replace(/_class$/,""),f]})).then(Object.fromEntries)]);return new this(p,c)}}ie(o,"classes",["image_processor_class","tokenizer_class","feature_extractor_class"]),ie(o,"uses_processor_config",!1)},"./src/configs.js":(e,t,n)=>{n.r(t),n.d(t,{AutoConfig:()=>u,PretrainedConfig:()=>l,getKeyValueShapes:()=>a});var r=n("./src/utils/core.js"),s=n("./src/utils/hub.js");async function i(p,c){return await(0,s.getModelJSON)(p,"config.json",!0,c)}function o(p){const c={};let d={};switch(p.model_type){case"llava":case"paligemma":case"gemma3":case"florence2":case"llava_onevision":case"idefics3":case"ultravox":case"smolvlm":d=o(p.text_config);break;case"moondream1":d=o(p.phi_config);break;case"musicgen":d=o(p.decoder);break;case"multi_modality":d=o(p.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":c.num_heads="n_head",c.num_layers="n_layer",c.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"falcon":c.num_heads="num_attention_heads",c.num_layers="num_hidden_layers",c.hidden_size="hidden_size";break;case"llama":case"olmo":case"olmo2":case"mobilellm":case"granite":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":case"phi":case"phi3":case"phi3_v":c.num_heads="num_key_value_heads",c.num_layers="num_hidden_layers",c.hidden_size="hidden_size",c.num_attention_heads="num_attention_heads";break;case"gemma":case"gemma2":case"gemma3_text":case"glm":case"helium":c.num_heads="num_key_value_heads",c.num_layers="num_hidden_layers",c.dim_kv="head_dim";break;case"openelm":c.num_heads="num_kv_heads",c.num_layers="num_transformer_layers",c.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":c.num_heads="num_heads",c.num_layers="num_layers",c.hidden_size="hidden_size";break;case"bloom":c.num_heads="n_head",c.num_layers="n_layer",c.hidden_size="hidden_size";break;case"mpt":c.num_heads="n_heads",c.num_layers="n_layers",c.hidden_size="d_model";break;case"exaone":c.num_heads="num_key_value_heads",c.num_layers="num_layers",c.dim_kv="head_dim",c.num_attention_heads="num_attention_heads";break;case"t5":case"mt5":case"longt5":c.num_decoder_layers="num_decoder_layers",c.num_decoder_heads="num_heads",c.decoder_dim_kv="d_kv",c.num_encoder_layers="num_layers",c.num_encoder_heads="num_heads",c.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"lite-whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":c.num_decoder_layers="decoder_layers",c.num_decoder_heads="decoder_attention_heads",c.decoder_hidden_size="d_model",c.num_encoder_layers="encoder_layers",c.num_encoder_heads="encoder_attention_heads",c.encoder_hidden_size="d_model";break;case"speecht5":c.num_decoder_layers="decoder_layers",c.num_decoder_heads="decoder_attention_heads",c.decoder_hidden_size="hidden_size",c.num_encoder_layers="encoder_layers",c.num_encoder_heads="encoder_attention_heads",c.encoder_hidden_size="hidden_size";break;case"trocr":c.num_encoder_layers=c.num_decoder_layers="decoder_layers",c.num_encoder_heads=c.num_decoder_heads="decoder_attention_heads",c.encoder_hidden_size=c.decoder_hidden_size="d_model";break;case"musicgen_decoder":c.num_encoder_layers=c.num_decoder_layers="num_hidden_layers",c.num_encoder_heads=c.num_decoder_heads="num_attention_heads",c.encoder_hidden_size=c.decoder_hidden_size="hidden_size";break;case"moonshine":c.num_decoder_layers="decoder_num_hidden_layers",c.num_decoder_heads="decoder_num_key_value_heads",c.num_encoder_layers="encoder_num_hidden_layers",c.num_encoder_heads="encoder_num_key_value_heads",c.encoder_hidden_size=c.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const m=o(p.decoder),y="num_decoder_layers"in m,C=(0,r.pick)(p,["model_type","is_encoder_decoder"]);return y?(C.num_decoder_layers=m.num_decoder_layers,C.num_decoder_heads=m.num_decoder_heads,C.decoder_hidden_size=m.decoder_hidden_size,C.num_encoder_layers=m.num_encoder_layers,C.num_encoder_heads=m.num_encoder_heads,C.encoder_hidden_size=m.encoder_hidden_size):(C.num_layers=m.num_layers,C.num_heads=m.num_heads,C.hidden_size=m.hidden_size),C}const f={...d,...(0,r.pick)(p,["model_type","multi_query","is_encoder_decoder"])};for(const m in c)f[m]=p[c[m]];return f}function a(p,{prefix:c="past_key_values",batch_size:d=1}={}){const f={},m=p.normalized_config;if(m.is_encoder_decoder&&"num_encoder_heads"in m&&"num_decoder_heads"in m){const y=m.encoder_dim_kv??m.encoder_hidden_size/m.num_encoder_heads,C=m.decoder_dim_kv??m.decoder_hidden_size/m.num_decoder_heads,_=[d,m.num_encoder_heads,0,y],h=[d,m.num_decoder_heads,0,C];for(let w=0;w<m.num_decoder_layers;++w)f[`${c}.${w}.encoder.key`]=_,f[`${c}.${w}.encoder.value`]=_,f[`${c}.${w}.decoder.key`]=h,f[`${c}.${w}.decoder.value`]=h}else{const y=m.num_heads,C=m.num_layers,_=m.dim_kv??m.hidden_size/(m.num_attention_heads??y);if(m.model_type==="falcon"){const h=[d*y,0,_];for(let w=0;w<C;++w)f[`${c}.${w}.key`]=h,f[`${c}.${w}.value`]=h}else if(m.multi_query){const h=[d*y,0,2*_];for(let w=0;w<C;++w)f[`${c}.${w}.key_value`]=h}else if(m.model_type==="bloom"){const h=[d*y,_,0],w=[d*y,0,_];for(let M=0;M<C;++M)f[`${c}.${M}.key`]=h,f[`${c}.${M}.value`]=w}else if(m.model_type==="openelm")for(let h=0;h<C;++h){const w=[d,y[h],0,_];f[`${c}.${h}.key`]=w,f[`${c}.${h}.value`]=w}else{const h=[d,y,0,_];for(let w=0;w<C;++w)f[`${c}.${w}.key`]=h,f[`${c}.${w}.value`]=h}}return f}class l{constructor(c){ie(this,"model_type",null);ie(this,"is_encoder_decoder",!1);ie(this,"max_position_embeddings");ie(this,"transformers.js_config");Object.assign(this,c),this.normalized_config=o(this)}static async from_pretrained(c,{progress_callback:d=null,config:f=null,cache_dir:m=null,local_files_only:y=!1,revision:C="main"}={}){f&&!(f instanceof l)&&(f=new l(f));const _=f??await i(c,{progress_callback:d,config:f,cache_dir:m,local_files_only:y,revision:C});return new this(_)}}class u{static async from_pretrained(...c){return l.from_pretrained(...c)}}},"./src/env.js":(e,t,n)=>{var S,$;n.r(t),n.d(t,{apis:()=>C,env:()=>b});var r=n("?569f"),s=n("?3f59"),i=n("?154a");const o="3.5.0",a=typeof window<"u"&&typeof window.document<"u",l=typeof self<"u"&&((S=self.constructor)==null?void 0:S.name)==="DedicatedWorkerGlobalScope",u=typeof self<"u"&&"caches"in self,p=typeof navigator<"u"&&"gpu"in navigator,c=typeof navigator<"u"&&"ml"in navigator,d=typeof process<"u",f=d&&(($=process==null?void 0:process.release)==null?void 0:$.name)==="node",m=!T(r),y=!T(s),C=Object.freeze({IS_BROWSER_ENV:a,IS_WEBWORKER_ENV:l,IS_WEB_CACHE_AVAILABLE:u,IS_WEBGPU_AVAILABLE:p,IS_WEBNN_AVAILABLE:c,IS_PROCESS_AVAILABLE:d,IS_NODE_ENV:f,IS_FS_AVAILABLE:m,IS_PATH_AVAILABLE:y}),_=m&&y;let h="./";if(_){const O=Object(import.meta).url;O?h=s.dirname(s.dirname(i.fileURLToPath(O))):typeof __dirname<"u"&&(h=s.dirname(__dirname))}const w=_?s.join(h,"/.cache/"):null,M="/models/",x=_?s.join(h,M):M,b={version:o,backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!(a||l),localModelPath:x,useFS:m,useBrowserCache:u,useFSCache:m,cacheDir:w,useCustomCache:!1,customCache:null};function T(O){return Object.keys(O).length===0}},"./src/generation/configuration_utils.js":(e,t,n)=>{n.r(t),n.d(t,{GenerationConfig:()=>s});var r=n("./src/utils/core.js");class s{constructor(o){ie(this,"max_length",20);ie(this,"max_new_tokens",null);ie(this,"min_length",0);ie(this,"min_new_tokens",null);ie(this,"early_stopping",!1);ie(this,"max_time",null);ie(this,"do_sample",!1);ie(this,"num_beams",1);ie(this,"num_beam_groups",1);ie(this,"penalty_alpha",null);ie(this,"use_cache",!0);ie(this,"temperature",1);ie(this,"top_k",50);ie(this,"top_p",1);ie(this,"typical_p",1);ie(this,"epsilon_cutoff",0);ie(this,"eta_cutoff",0);ie(this,"diversity_penalty",0);ie(this,"repetition_penalty",1);ie(this,"encoder_repetition_penalty",1);ie(this,"length_penalty",1);ie(this,"no_repeat_ngram_size",0);ie(this,"bad_words_ids",null);ie(this,"force_words_ids",null);ie(this,"renormalize_logits",!1);ie(this,"constraints",null);ie(this,"forced_bos_token_id",null);ie(this,"forced_eos_token_id",null);ie(this,"remove_invalid_values",!1);ie(this,"exponential_decay_length_penalty",null);ie(this,"suppress_tokens",null);ie(this,"streamer",null);ie(this,"begin_suppress_tokens",null);ie(this,"forced_decoder_ids",null);ie(this,"guidance_scale",null);ie(this,"num_return_sequences",1);ie(this,"output_attentions",!1);ie(this,"output_hidden_states",!1);ie(this,"output_scores",!1);ie(this,"return_dict_in_generate",!1);ie(this,"pad_token_id",null);ie(this,"bos_token_id",null);ie(this,"eos_token_id",null);ie(this,"encoder_no_repeat_ngram_size",0);ie(this,"decoder_start_token_id",null);ie(this,"generation_kwargs",{});Object.assign(this,(0,r.pick)(o,Object.getOwnPropertyNames(this)))}}},"./src/generation/logits_process.js":(e,t,n)=>{n.r(t),n.d(t,{ClassifierFreeGuidanceLogitsProcessor:()=>_,ForcedBOSTokenLogitsProcessor:()=>l,ForcedEOSTokenLogitsProcessor:()=>u,LogitsProcessor:()=>i,LogitsProcessorList:()=>a,LogitsWarper:()=>o,MinLengthLogitsProcessor:()=>m,MinNewTokensLengthLogitsProcessor:()=>y,NoBadWordsLogitsProcessor:()=>C,NoRepeatNGramLogitsProcessor:()=>d,RepetitionPenaltyLogitsProcessor:()=>f,SuppressTokensAtBeginLogitsProcessor:()=>p,TemperatureLogitsWarper:()=>h,TopKLogitsWarper:()=>M,TopPLogitsWarper:()=>w,WhisperTimeStampLogitsProcessor:()=>c});var r=n("./src/utils/generic.js");n("./src/utils/tensor.js");var s=n("./src/utils/maths.js");class i extends r.Callable{_call(b,T){throw Error("`_call` should be implemented in a subclass")}}class o extends r.Callable{_call(b,T){throw Error("`_call` should be implemented in a subclass")}}class a extends r.Callable{constructor(){super(),this.processors=[]}push(b){this.processors.push(b)}extend(b){this.processors.push(...b)}_call(b,T){let S=T;for(const $ of this.processors)S=$(b,S);return S}[Symbol.iterator](){return this.processors.values()}}class l extends i{constructor(b){super(),this.bos_token_id=b}_call(b,T){for(let S=0;S<b.length;++S)if(b[S].length===1){const $=T[S].data;$.fill(-1/0),$[this.bos_token_id]=0}return T}}class u extends i{constructor(b,T){super(),this.max_length=b,this.eos_token_id=Array.isArray(T)?T:[T]}_call(b,T){for(let S=0;S<b.length;++S)if(b[S].length===this.max_length-1){const $=T[S].data;$.fill(-1/0);for(const O of this.eos_token_id)$[O]=0}return T}}class p extends i{constructor(b,T){super(),this.begin_suppress_tokens=b,this.begin_index=T}_call(b,T){for(let S=0;S<b.length;++S)if(b[S].length===this.begin_index){const $=T[S].data;for(const O of this.begin_suppress_tokens)$[O]=-1/0}return T}}class c extends i{constructor(b,T){super(),this.eos_token_id=Array.isArray(b.eos_token_id)?b.eos_token_id[0]:b.eos_token_id,this.no_timestamps_token_id=b.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=T.length,T.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=b.max_initial_timestamp_index}_call(b,T){for(let S=0;S<b.length;++S){const $=T[S].data;if($[this.no_timestamps_token_id]=-1/0,b[S].length===this.begin_index-1){$.fill(-1/0),$[this.timestamp_begin]=0;continue}const O=b[S].slice(this.begin_index),G=O.length>=1&&O[O.length-1]>=this.timestamp_begin,H=O.length<2||O[O.length-2]>=this.timestamp_begin;if(G&&(H?$.subarray(this.timestamp_begin).fill(-1/0):$.subarray(0,this.eos_token_id).fill(-1/0)),b[S].length===this.begin_index&&this.max_initial_timestamp_index!==null){const X=this.timestamp_begin+this.max_initial_timestamp_index;$.subarray(X+1).fill(-1/0)}const N=(0,s.log_softmax)($),J=Math.log(N.subarray(this.timestamp_begin).map(Math.exp).reduce((X,Y)=>X+Y)),q=(0,s.max)(N.subarray(0,this.timestamp_begin))[0];J>q&&$.subarray(0,this.timestamp_begin).fill(-1/0)}return T}}class d extends i{constructor(b){super(),this.no_repeat_ngram_size=b}getNgrams(b){const T=b.length,S=[];for(let O=0;O<T+1-this.no_repeat_ngram_size;++O){const G=[];for(let H=0;H<this.no_repeat_ngram_size;++H)G.push(b[O+H]);S.push(G.map(Number))}const $=new Map;for(const O of S){const G=O.slice(0,O.length-1),H=JSON.stringify(G),N=$.get(H)??[];N.push(O[O.length-1]),$.set(H,N)}return $}getGeneratedNgrams(b,T){const S=T.slice(T.length+1-this.no_repeat_ngram_size,T.length);return b.get(JSON.stringify(S.map(Number)))??[]}calcBannedNgramTokens(b){const T=[];if(b.length+1<this.no_repeat_ngram_size)return T;{const S=this.getNgrams(b);return this.getGeneratedNgrams(S,b)}}_call(b,T){for(let S=0;S<b.length;++S){const $=T[S].data,O=this.calcBannedNgramTokens(b[S]);for(const G of O)$[G]=-1/0}return T}}class f extends i{constructor(b){super(),this.penalty=b}_call(b,T){for(let S=0;S<b.length;++S){const $=T[S].data;for(const O of new Set(b[S])){const G=Number(O);$[G]<0?$[G]*=this.penalty:$[G]/=this.penalty}}return T}}class m extends i{constructor(b,T){super(),this.min_length=b,this.eos_token_id=Array.isArray(T)?T:[T]}_call(b,T){for(let S=0;S<b.length;++S)if(b[S].length<this.min_length){const $=T[S].data;for(const O of this.eos_token_id)$[O]=-1/0}return T}}class y extends i{constructor(b,T,S){super(),this.prompt_length_to_skip=b,this.min_new_tokens=T,this.eos_token_id=Array.isArray(S)?S:[S]}_call(b,T){for(let S=0;S<b.length;++S)if(b[S].length-this.prompt_length_to_skip<this.min_new_tokens){const O=T[S].data;for(const G of this.eos_token_id)O[G]=-1/0}return T}}class C extends i{constructor(b,T){super(),this.bad_words_ids=b,this.eos_token_id=Array.isArray(T)?T:[T]}_call(b,T){for(let S=0;S<b.length;++S){const $=T[S].data,O=b[S];for(const G of this.bad_words_ids){if(O.length<G.length-1)continue;let H=!0;for(let N=1;N<=G.length-1;++N)if(G.at(-N-1)!=O.at(-N)){H=!1;break}H&&($[G.at(-1)]=-1/0)}}return T}}class _ extends i{constructor(b){if(super(),b<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${b}.`);this.guidance_scale=b}_call(b,T){if(T.dims[0]!==2*b.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${T.dims[0]} for the logits and ${b.length} for the input ids.`);const S=b.length,$=T.slice([0,S],null),O=T.slice([S,T.dims[0]],null);for(let G=0;G<O.data.length;++G)O.data[G]+=($.data[G]-O.data[G])*this.guidance_scale;return O}}class h extends o{constructor(b){super(),this.temperature=b}_call(b,T){const S=T.data;for(let $=0;$<S.length;++$)S[$]/=this.temperature;return T}}class w extends o{constructor(b,{filter_value:T=-1/0,min_tokens_to_keep:S=1}={}){if(super(),b<0||b>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${b}`);if(!Number.isInteger(S)||S<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${S}`);this.top_p=b,this.filter_value=T,this.min_tokens_to_keep=S}}class M extends o{constructor(b,{filter_value:T=-1/0,min_tokens_to_keep:S=1}={}){if(super(),!Number.isInteger(b)||b<0)throw new Error(`\`top_k\` must be a positive integer, but is ${b}`);this.top_k=Math.max(b,S),this.filter_value=T}}},"./src/generation/logits_sampler.js":(e,t,n)=>{n.r(t),n.d(t,{LogitsSampler:()=>o});var r=n("./src/utils/generic.js"),s=n("./src/utils/tensor.js"),i=n("./src/utils/maths.js");n("./src/generation/configuration_utils.js");class o extends r.Callable{constructor(c){super(),this.generation_config=c}async _call(c){return this.sample(c)}async sample(c){throw Error("sample should be implemented in subclasses.")}getLogits(c,d){let f=c.dims.at(-1),m=c.data;if(d===-1)m=m.slice(-f);else{let y=d*f;m=m.slice(y,y+f)}return m}randomSelect(c){let d=0;for(let m=0;m<c.length;++m)d+=c[m];let f=Math.random()*d;for(let m=0;m<c.length;++m)if(f-=c[m],f<=0)return m;return 0}static getSampler(c){if(c.do_sample)return new l(c);if(c.num_beams>1)return new u(c);if(c.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${c.num_return_sequences}.`);return new a(c)}}class a extends o{async sample(c){const d=(0,i.max)(c.data)[1];return[[BigInt(d),0]]}}class l extends o{async sample(c){let d=c.dims.at(-1);this.generation_config.top_k>0&&(d=Math.min(this.generation_config.top_k,d));const[f,m]=await(0,s.topk)(c,d),y=(0,i.softmax)(f.data);return Array.from({length:this.generation_config.num_beams},()=>{const C=this.randomSelect(y);return[m.data[C],Math.log(y[C])]})}}class u extends o{async sample(c){let d=c.dims.at(-1);this.generation_config.top_k>0&&(d=Math.min(this.generation_config.top_k,d));const[f,m]=await(0,s.topk)(c,d),y=(0,i.softmax)(f.data);return Array.from({length:this.generation_config.num_beams},(C,_)=>[m.data[_],Math.log(y[_])])}}},"./src/generation/stopping_criteria.js":(e,t,n)=>{n.r(t),n.d(t,{EosTokenCriteria:()=>a,InterruptableStoppingCriteria:()=>l,MaxLengthCriteria:()=>o,StoppingCriteria:()=>s,StoppingCriteriaList:()=>i});var r=n("./src/utils/generic.js");class s extends r.Callable{_call(p,c){throw Error("StoppingCriteria needs to be subclassed")}}class i extends r.Callable{constructor(){super(),this.criteria=[]}push(p){this.criteria.push(p)}extend(p){p instanceof i?p=p.criteria:p instanceof s&&(p=[p]),this.criteria.push(...p)}_call(p,c){const d=new Array(p.length).fill(!1);for(const f of this.criteria){const m=f(p,c);for(let y=0;y<d.length;++y)d[y]||(d[y]=m[y])}return d}[Symbol.iterator](){return this.criteria.values()}}class o extends s{constructor(p,c=null){super(),this.max_length=p,this.max_position_embeddings=c}_call(p){return p.map(c=>c.length>=this.max_length)}}class a extends s{constructor(p){super(),Array.isArray(p)||(p=[p]),this.eos_token_id=p}_call(p,c){return p.map(d=>{const f=d.at(-1);return this.eos_token_id.some(m=>f==m)})}}class l extends s{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(p,c){return new Array(p.length).fill(this.interrupted)}}},"./src/generation/streamers.js":(e,t,n)=>{n.r(t),n.d(t,{BaseStreamer:()=>o,TextStreamer:()=>l,WhisperTextStreamer:()=>u});var r=n("./src/utils/core.js"),s=n("./src/tokenizers.js"),i=n("./src/env.js");class o{put(c){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const a=i.apis.IS_PROCESS_AVAILABLE?p=>process.stdout.write(p):p=>console.log(p);class l extends o{constructor(c,{skip_prompt:d=!1,callback_function:f=null,token_callback_function:m=null,skip_special_tokens:y=!0,decode_kwargs:C={},..._}={}){super(),this.tokenizer=c,this.skip_prompt=d,this.callback_function=f??a,this.token_callback_function=m,this.decode_kwargs={skip_special_tokens:y,...C,..._},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(c){var C;if(c.length>1)throw Error("TextStreamer only supports batch size of 1");const d=this.next_tokens_are_prompt;if(d&&(this.next_tokens_are_prompt=!1,this.skip_prompt))return;const f=c[0];(C=this.token_callback_function)==null||C.call(this,f),this.token_cache=(0,r.mergeArrays)(this.token_cache,f);const m=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let y;d||m.endsWith(`
`)?(y=m.slice(this.print_len),this.token_cache=[],this.print_len=0):m.length>0&&(0,s.is_chinese_char)(m.charCodeAt(m.length-1))?(y=m.slice(this.print_len),this.print_len+=y.length):(y=m.slice(this.print_len,m.lastIndexOf(" ")+1),this.print_len+=y.length),this.on_finalized_text(y,!1)}end(){let c;this.token_cache.length>0?(c=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):c="",this.next_tokens_are_prompt=!0,this.on_finalized_text(c,!0)}on_finalized_text(c,d){var f,m;c.length>0&&((f=this.callback_function)==null||f.call(this,c)),d&&this.callback_function===a&&i.apis.IS_PROCESS_AVAILABLE&&((m=this.callback_function)==null||m.call(this,`
`))}}class u extends l{constructor(c,{skip_prompt:d=!1,callback_function:f=null,token_callback_function:m=null,on_chunk_start:y=null,on_chunk_end:C=null,on_finalize:_=null,time_precision:h=.02,skip_special_tokens:w=!0,decode_kwargs:M={}}={}){super(c,{skip_prompt:d,skip_special_tokens:w,callback_function:f,token_callback_function:m,decode_kwargs:M}),this.timestamp_begin=c.timestamp_begin,this.on_chunk_start=y,this.on_chunk_end=C,this.on_finalize=_,this.time_precision=h,this.waiting_for_timestamp=!1}put(c){var f,m;if(c.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const d=c[0];if(d.length===1){const y=Number(d[0])-this.timestamp_begin;if(y>=0){const C=y*this.time_precision;this.waiting_for_timestamp?(f=this.on_chunk_end)==null||f.call(this,C):(m=this.on_chunk_start)==null||m.call(this,C),this.waiting_for_timestamp=!this.waiting_for_timestamp,c=[[]]}}return super.put(c)}end(){var c;super.end(),(c=this.on_finalize)==null||c.call(this)}}},"./src/models.js":(e,t,n)=>{n.r(t),n.d(t,{ASTForAudioClassification:()=>Dc,ASTModel:()=>Ac,ASTPreTrainedModel:()=>El,AlbertForMaskedLM:()=>U,AlbertForQuestionAnswering:()=>A,AlbertForSequenceClassification:()=>me,AlbertModel:()=>Mo,AlbertPreTrainedModel:()=>Vs,AutoModel:()=>zh,AutoModelForAudioClassification:()=>Cx,AutoModelForAudioFrameClassification:()=>$x,AutoModelForAudioTextToText:()=>Bx,AutoModelForCTC:()=>Sx,AutoModelForCausalLM:()=>_x,AutoModelForDepthEstimation:()=>Ox,AutoModelForDocumentQuestionAnswering:()=>Ix,AutoModelForImageClassification:()=>wx,AutoModelForImageFeatureExtraction:()=>zx,AutoModelForImageMatting:()=>Ax,AutoModelForImageSegmentation:()=>Mx,AutoModelForImageTextToText:()=>Rx,AutoModelForImageToImage:()=>Dx,AutoModelForMaskGeneration:()=>Px,AutoModelForMaskedLM:()=>gx,AutoModelForNormalEstimation:()=>Fx,AutoModelForObjectDetection:()=>Tx,AutoModelForPoseEstimation:()=>Lx,AutoModelForQuestionAnswering:()=>yx,AutoModelForSemanticSegmentation:()=>xx,AutoModelForSeq2SeqLM:()=>px,AutoModelForSequenceClassification:()=>cx,AutoModelForSpeechSeq2Seq:()=>fx,AutoModelForTextToSpectrogram:()=>hx,AutoModelForTextToWaveform:()=>mx,AutoModelForTokenClassification:()=>dx,AutoModelForUniversalSegmentation:()=>bx,AutoModelForVision2Seq:()=>vx,AutoModelForXVector:()=>kx,AutoModelForZeroShotObjectDetection:()=>Ex,BartForConditionalGeneration:()=>Jt,BartForSequenceClassification:()=>Vt,BartModel:()=>Lt,BartPretrainedModel:()=>It,BaseModelOutput:()=>be,BeitForImageClassification:()=>qv,BeitModel:()=>Kv,BeitPreTrainedModel:()=>th,BertForMaskedLM:()=>De,BertForQuestionAnswering:()=>je,BertForSequenceClassification:()=>Oe,BertForTokenClassification:()=>Le,BertModel:()=>Ce,BertPreTrainedModel:()=>we,BlenderbotForConditionalGeneration:()=>Sn,BlenderbotModel:()=>Kt,BlenderbotPreTrainedModel:()=>es,BlenderbotSmallForConditionalGeneration:()=>Lr,BlenderbotSmallModel:()=>ts,BlenderbotSmallPreTrainedModel:()=>Xn,BloomForCausalLM:()=>_v,BloomModel:()=>mv,BloomPreTrainedModel:()=>Uf,CLIPModel:()=>Uc,CLIPPreTrainedModel:()=>ei,CLIPSegForImageSegmentation:()=>Rl,CLIPSegModel:()=>zl,CLIPSegPreTrainedModel:()=>xa,CLIPTextModel:()=>Df,CLIPTextModelWithProjection:()=>Wc,CLIPVisionModel:()=>Of,CLIPVisionModelWithProjection:()=>Gc,CamembertForMaskedLM:()=>Gt,CamembertForQuestionAnswering:()=>Ns,CamembertForSequenceClassification:()=>ms,CamembertForTokenClassification:()=>_s,CamembertModel:()=>Bs,CamembertPreTrainedModel:()=>br,CausalLMOutput:()=>$o,CausalLMOutputWithPast:()=>WF,ChineseCLIPModel:()=>Kc,ChineseCLIPPreTrainedModel:()=>Hc,ClapAudioModelWithProjection:()=>H1,ClapModel:()=>W1,ClapPreTrainedModel:()=>rd,ClapTextModelWithProjection:()=>G1,CodeGenForCausalLM:()=>Co,CodeGenModel:()=>Hl,CodeGenPreTrainedModel:()=>Sa,CohereForCausalLM:()=>Jy,CohereModel:()=>Yy,CoherePreTrainedModel:()=>Ff,ConvBertForMaskedLM:()=>$t,ConvBertForQuestionAnswering:()=>Ft,ConvBertForSequenceClassification:()=>Pn,ConvBertForTokenClassification:()=>ht,ConvBertModel:()=>Ht,ConvBertPreTrainedModel:()=>Tt,ConvNextForImageClassification:()=>Nw,ConvNextModel:()=>Bw,ConvNextPreTrainedModel:()=>mh,ConvNextV2ForImageClassification:()=>Vw,ConvNextV2Model:()=>jw,ConvNextV2PreTrainedModel:()=>_h,DPTForDepthEstimation:()=>Mw,DPTModel:()=>ww,DPTPreTrainedModel:()=>ph,DacDecoderModel:()=>OM,DacDecoderOutput:()=>IM,DacEncoderModel:()=>DM,DacEncoderOutput:()=>$M,DacModel:()=>AM,DacPreTrainedModel:()=>cd,DebertaForMaskedLM:()=>et,DebertaForQuestionAnswering:()=>Or,DebertaForSequenceClassification:()=>it,DebertaForTokenClassification:()=>Yt,DebertaModel:()=>Be,DebertaPreTrainedModel:()=>fn,DebertaV2ForMaskedLM:()=>ys,DebertaV2ForQuestionAnswering:()=>ws,DebertaV2ForSequenceClassification:()=>Yr,DebertaV2ForTokenClassification:()=>vs,DebertaV2Model:()=>gs,DebertaV2PreTrainedModel:()=>_r,DecisionTransformerModel:()=>fM,DecisionTransformerPreTrainedModel:()=>pM,DeiTForImageClassification:()=>cw,DeiTModel:()=>uw,DeiTPreTrainedModel:()=>lh,DepthAnythingForDepthEstimation:()=>bw,DepthAnythingPreTrainedModel:()=>xw,DepthProForDepthEstimation:()=>Cw,DepthProPreTrainedModel:()=>Sw,DetrForObjectDetection:()=>Xv,DetrForSegmentation:()=>nh,DetrModel:()=>Qv,DetrObjectDetectionOutput:()=>rh,DetrPreTrainedModel:()=>Xc,DetrSegmentationOutput:()=>Yv,Dinov2ForImageClassification:()=>Ww,Dinov2Model:()=>Uw,Dinov2PreTrainedModel:()=>gh,Dinov2WithRegistersForImageClassification:()=>Hw,Dinov2WithRegistersModel:()=>Gw,Dinov2WithRegistersPreTrainedModel:()=>yh,DistilBertForMaskedLM:()=>Ys,DistilBertForQuestionAnswering:()=>Xs,DistilBertForSequenceClassification:()=>uo,DistilBertForTokenClassification:()=>ar,DistilBertModel:()=>or,DistilBertPreTrainedModel:()=>Jr,DonutSwinModel:()=>Rw,DonutSwinPreTrainedModel:()=>zw,EfficientNetForImageClassification:()=>Z1,EfficientNetModel:()=>J1,EfficientNetPreTrainedModel:()=>Ch,ElectraForMaskedLM:()=>An,ElectraForQuestionAnswering:()=>hs,ElectraForSequenceClassification:()=>Dr,ElectraForTokenClassification:()=>ft,ElectraModel:()=>Bn,ElectraPreTrainedModel:()=>Ct,EsmForMaskedLM:()=>co,EsmForSequenceClassification:()=>Tr,EsmForTokenClassification:()=>po,EsmModel:()=>Mi,EsmPreTrainedModel:()=>qn,ExaoneForCausalLM:()=>B,ExaoneModel:()=>D,ExaonePreTrainedModel:()=>P,FalconForCausalLM:()=>U1,FalconModel:()=>V1,FalconPreTrainedModel:()=>Eh,FastViTForImageClassification:()=>Lv,FastViTModel:()=>Fv,FastViTPreTrainedModel:()=>Xf,Florence2ForConditionalGeneration:()=>Il,Florence2PreTrainedModel:()=>Rc,GLPNForDepthEstimation:()=>Lw,GLPNModel:()=>Fw,GLPNPreTrainedModel:()=>hh,GPT2LMHeadModel:()=>Bl,GPT2Model:()=>qc,GPT2PreTrainedModel:()=>ba,GPTBigCodeForCausalLM:()=>Gl,GPTBigCodeModel:()=>Pa,GPTBigCodePreTrainedModel:()=>Ea,GPTJForCausalLM:()=>Wl,GPTJModel:()=>Ul,GPTJPreTrainedModel:()=>So,GPTNeoForCausalLM:()=>Vl,GPTNeoModel:()=>jl,GPTNeoPreTrainedModel:()=>Nl,GPTNeoXForCausalLM:()=>Po,GPTNeoXModel:()=>Rr,GPTNeoXPreTrainedModel:()=>Ci,Gemma2ForCausalLM:()=>nv,Gemma2Model:()=>tv,Gemma2PreTrainedModel:()=>zf,Gemma3ForCausalLM:()=>sv,Gemma3Model:()=>rv,Gemma3PreTrainedModel:()=>Rf,GemmaForCausalLM:()=>ev,GemmaModel:()=>Zy,GemmaPreTrainedModel:()=>Lf,GlmForCausalLM:()=>g,GlmModel:()=>Xl,GlmPreTrainedModel:()=>$a,GraniteForCausalLM:()=>Qc,GraniteModel:()=>ti,GranitePreTrainedModel:()=>Cn,GroundingDinoForObjectDetection:()=>qw,GroundingDinoPreTrainedModel:()=>Kw,GroupViTModel:()=>Ov,GroupViTPreTrainedModel:()=>Dv,HeliumForCausalLM:()=>Ql,HeliumModel:()=>ql,HeliumPreTrainedModel:()=>ka,HieraForImageClassification:()=>pw,HieraModel:()=>dw,HieraPreTrainedModel:()=>uh,HubertForCTC:()=>T1,HubertForSequenceClassification:()=>E1,HubertModel:()=>b1,HubertPreTrainedModel:()=>$F,IJepaForImageClassification:()=>Tv,IJepaModel:()=>bv,IJepaPreTrainedModel:()=>Kf,Idefics3ForConditionalGeneration:()=>Ei,Idefics3PreTrainedModel:()=>jc,ImageMattingOutput:()=>jx,JAISLMHeadModel:()=>ut,JAISModel:()=>Eo,JAISPreTrainedModel:()=>Ta,JinaCLIPModel:()=>Ma,JinaCLIPPreTrainedModel:()=>Si,JinaCLIPTextModel:()=>Fl,JinaCLIPVisionModel:()=>Ll,LiteWhisperForConditionalGeneration:()=>Fc,LlamaForCausalLM:()=>Kl,LlamaModel:()=>Ca,LlamaPreTrainedModel:()=>ko,LlavaForConditionalGeneration:()=>bo,LlavaOnevisionForConditionalGeneration:()=>$l,LlavaPreTrainedModel:()=>zc,LongT5ForConditionalGeneration:()=>Xe,LongT5Model:()=>We,LongT5PreTrainedModel:()=>Ee,M2M100ForConditionalGeneration:()=>s1,M2M100Model:()=>r1,M2M100PreTrainedModel:()=>Mh,MBartForCausalLM:()=>en,MBartForConditionalGeneration:()=>jn,MBartForSequenceClassification:()=>Vn,MBartModel:()=>tr,MBartPreTrainedModel:()=>un,MPNetForMaskedLM:()=>ho,MPNetForQuestionAnswering:()=>go,MPNetForSequenceClassification:()=>mo,MPNetForTokenClassification:()=>_o,MPNetModel:()=>fo,MPNetPreTrainedModel:()=>Fr,MT5ForConditionalGeneration:()=>_t,MT5Model:()=>tt,MT5PreTrainedModel:()=>Ke,MarianMTModel:()=>n1,MarianModel:()=>t1,MarianPreTrainedModel:()=>wh,MaskFormerForInstanceSegmentation:()=>Ow,MaskFormerModel:()=>Dw,MaskFormerPreTrainedModel:()=>fh,MaskedLMOutput:()=>Yn,Metric3DForDepthEstimation:()=>$w,Metric3DPreTrainedModel:()=>kw,Metric3Dv2ForDepthEstimation:()=>Aw,Metric3Dv2PreTrainedModel:()=>Iw,MgpstrForSceneTextRecognition:()=>yM,MgpstrModelOutput:()=>_M,MgpstrPreTrainedModel:()=>gM,MimiDecoderModel:()=>kM,MimiDecoderOutput:()=>PM,MimiEncoderModel:()=>CM,MimiEncoderOutput:()=>EM,MimiModel:()=>SM,MimiPreTrainedModel:()=>ud,MistralForCausalLM:()=>B1,MistralModel:()=>R1,MistralPreTrainedModel:()=>bh,MobileBertForMaskedLM:()=>Js,MobileBertForQuestionAnswering:()=>Qn,MobileBertForSequenceClassification:()=>Nn,MobileBertModel:()=>lr,MobileBertPreTrainedModel:()=>Zr,MobileLLMForCausalLM:()=>Pe,MobileLLMModel:()=>ce,MobileLLMPreTrainedModel:()=>W,MobileNetV1ForImageClassification:()=>tM,MobileNetV1ForSemanticSegmentation:()=>nM,MobileNetV1Model:()=>eM,MobileNetV1PreTrainedModel:()=>id,MobileNetV2ForImageClassification:()=>sM,MobileNetV2ForSemanticSegmentation:()=>iM,MobileNetV2Model:()=>rM,MobileNetV2PreTrainedModel:()=>od,MobileNetV3ForImageClassification:()=>aM,MobileNetV3ForSemanticSegmentation:()=>lM,MobileNetV3Model:()=>oM,MobileNetV3PreTrainedModel:()=>ad,MobileNetV4ForImageClassification:()=>cM,MobileNetV4ForSemanticSegmentation:()=>dM,MobileNetV4Model:()=>uM,MobileNetV4PreTrainedModel:()=>ld,MobileViTForImageClassification:()=>Nv,MobileViTModel:()=>Bv,MobileViTPreTrainedModel:()=>Yf,MobileViTV2ForImageClassification:()=>Vv,MobileViTV2Model:()=>jv,MobileViTV2PreTrainedModel:()=>Jf,ModelOutput:()=>he,ModernBertForMaskedLM:()=>R,ModernBertForSequenceClassification:()=>ne,ModernBertForTokenClassification:()=>ue,ModernBertModel:()=>re,ModernBertPreTrainedModel:()=>L,Moondream1ForConditionalGeneration:()=>Ti,MoonshineForConditionalGeneration:()=>Cl,MoonshineModel:()=>Lc,MoonshinePreTrainedModel:()=>va,MptForCausalLM:()=>yv,MptModel:()=>gv,MptPreTrainedModel:()=>Wf,MultiModalityCausalLM:()=>mM,MultiModalityPreTrainedModel:()=>hM,MusicgenForCausalLM:()=>OF,MusicgenForConditionalGeneration:()=>$h,MusicgenModel:()=>DF,MusicgenPreTrainedModel:()=>kh,NomicBertModel:()=>Te,NomicBertPreTrainedModel:()=>ve,OPTForCausalLM:()=>wv,OPTModel:()=>vv,OPTPreTrainedModel:()=>Gf,Olmo2ForCausalLM:()=>Ut,Olmo2Model:()=>At,Olmo2PreTrainedModel:()=>vt,OlmoForCausalLM:()=>nt,OlmoModel:()=>Qe,OlmoPreTrainedModel:()=>ze,OpenELMForCausalLM:()=>ov,OpenELMModel:()=>iv,OpenELMPreTrainedModel:()=>Bf,OwlViTForObjectDetection:()=>Wv,OwlViTModel:()=>Uv,OwlViTPreTrainedModel:()=>Zf,Owlv2ForObjectDetection:()=>Hv,Owlv2Model:()=>Gv,Owlv2PreTrainedModel:()=>eh,PaliGemmaForConditionalGeneration:()=>Nc,PaliGemmaPreTrainedModel:()=>Bc,PatchTSMixerForPrediction:()=>xM,PatchTSMixerModel:()=>MM,PatchTSMixerPreTrainedModel:()=>Ah,PatchTSTForPrediction:()=>wM,PatchTSTModel:()=>vM,PatchTSTPreTrainedModel:()=>Ih,Phi3ForCausalLM:()=>hv,Phi3Model:()=>fv,Phi3PreTrainedModel:()=>Vf,Phi3VForCausalLM:()=>Al,Phi3VPreTrainedModel:()=>Vc,PhiForCausalLM:()=>pv,PhiModel:()=>dv,PhiPreTrainedModel:()=>jf,PreTrainedModel:()=>j,PretrainedMixin:()=>zt,PvtForImageClassification:()=>Cv,PvtModel:()=>Sv,PvtPreTrainedModel:()=>qf,PyAnnoteForAudioFrameClassification:()=>c1,PyAnnoteModel:()=>u1,PyAnnotePreTrainedModel:()=>xh,QuestionAnsweringModelOutput:()=>ur,Qwen2ForCausalLM:()=>lv,Qwen2Model:()=>av,Qwen2PreTrainedModel:()=>Nf,Qwen2VLForConditionalGeneration:()=>cv,Qwen2VLPreTrainedModel:()=>uv,RFDetrForObjectDetection:()=>sw,RFDetrModel:()=>rw,RFDetrObjectDetectionOutput:()=>iw,RFDetrPreTrainedModel:()=>oh,RTDetrForObjectDetection:()=>Zv,RTDetrModel:()=>Jv,RTDetrObjectDetectionOutput:()=>Yc,RTDetrPreTrainedModel:()=>sh,RTDetrV2ForObjectDetection:()=>tw,RTDetrV2Model:()=>ew,RTDetrV2ObjectDetectionOutput:()=>nw,RTDetrV2PreTrainedModel:()=>ih,ResNetForImageClassification:()=>hw,ResNetModel:()=>fw,ResNetPreTrainedModel:()=>ch,RoFormerForMaskedLM:()=>Ve,RoFormerForQuestionAnswering:()=>pt,RoFormerForSequenceClassification:()=>Je,RoFormerForTokenClassification:()=>qe,RoFormerModel:()=>$e,RoFormerPreTrainedModel:()=>Ae,RobertaForMaskedLM:()=>Dn,RobertaForQuestionAnswering:()=>bn,RobertaForSequenceClassification:()=>tn,RobertaForTokenClassification:()=>xn,RobertaModel:()=>zr,RobertaPreTrainedModel:()=>Mn,SamImageSegmentationOutput:()=>e1,SamModel:()=>Zw,SamPreTrainedModel:()=>Jw,SapiensForDepthEstimation:()=>Ew,SapiensForNormalEstimation:()=>Pw,SapiensForSemanticSegmentation:()=>Tw,SapiensPreTrainedModel:()=>Zc,SegformerForImageClassification:()=>q1,SegformerForSemanticSegmentation:()=>Q1,SegformerModel:()=>AF,SegformerPreTrainedModel:()=>sd,Seq2SeqLMOutput:()=>UF,SequenceClassifierOutput:()=>Mt,SiglipModel:()=>To,SiglipPreTrainedModel:()=>Dl,SiglipTextModel:()=>Pi,SiglipVisionModel:()=>Ol,SmolVLMForConditionalGeneration:()=>wa,SnacDecoderModel:()=>zM,SnacEncoderModel:()=>LM,SnacModel:()=>FM,SnacPreTrainedModel:()=>dd,SpeechT5ForSpeechToText:()=>D1,SpeechT5ForTextToSpeech:()=>O1,SpeechT5HifiGan:()=>F1,SpeechT5Model:()=>IF,SpeechT5PreTrainedModel:()=>nd,SqueezeBertForMaskedLM:()=>xi,SqueezeBertForQuestionAnswering:()=>wo,SqueezeBertForSequenceClassification:()=>vo,SqueezeBertModel:()=>yo,SqueezeBertPreTrainedModel:()=>js,StableLmForCausalLM:()=>Y1,StableLmModel:()=>X1,StableLmPreTrainedModel:()=>Sh,Starcoder2ForCausalLM:()=>j1,Starcoder2Model:()=>N1,Starcoder2PreTrainedModel:()=>Th,StyleTextToSpeech2Model:()=>A1,StyleTextToSpeech2PreTrainedModel:()=>I1,Swin2SRForImageSuperResolution:()=>vw,Swin2SRModel:()=>yw,Swin2SRPreTrainedModel:()=>dh,SwinForImageClassification:()=>_w,SwinForSemanticSegmentation:()=>gw,SwinModel:()=>mw,SwinPreTrainedModel:()=>Jc,T5ForConditionalGeneration:()=>fe,T5Model:()=>le,T5PreTrainedModel:()=>te,TableTransformerForObjectDetection:()=>aw,TableTransformerModel:()=>ow,TableTransformerObjectDetectionOutput:()=>lw,TableTransformerPreTrainedModel:()=>ah,TokenClassifierOutput:()=>Un,TrOCRForCausalLM:()=>z1,TrOCRPreTrainedModel:()=>L1,UltravoxModel:()=>TM,UltravoxPreTrainedModel:()=>bM,UniSpeechForCTC:()=>h1,UniSpeechForSequenceClassification:()=>m1,UniSpeechModel:()=>f1,UniSpeechPreTrainedModel:()=>ed,UniSpeechSatForAudioFrameClassification:()=>v1,UniSpeechSatForCTC:()=>g1,UniSpeechSatForSequenceClassification:()=>y1,UniSpeechSatModel:()=>_1,UniSpeechSatPreTrainedModel:()=>Yl,ViTForImageClassification:()=>xv,ViTMAEModel:()=>$v,ViTMAEPreTrainedModel:()=>kv,ViTMSNForImageClassification:()=>Av,ViTMSNModel:()=>Iv,ViTMSNPreTrainedModel:()=>Qf,ViTModel:()=>Mv,ViTPreTrainedModel:()=>Hf,VisionEncoderDecoderModel:()=>kl,VitMatteForImageMatting:()=>Rv,VitMattePreTrainedModel:()=>zv,VitPoseForPoseEstimation:()=>Pv,VitPosePreTrainedModel:()=>Ev,VitsModel:()=>Ph,VitsModelOutput:()=>Vx,VitsPreTrainedModel:()=>K1,Wav2Vec2BertForCTC:()=>M1,Wav2Vec2BertForSequenceClassification:()=>x1,Wav2Vec2BertModel:()=>w1,Wav2Vec2BertPreTrainedModel:()=>td,Wav2Vec2ForAudioFrameClassification:()=>l1,Wav2Vec2ForCTC:()=>o1,Wav2Vec2ForSequenceClassification:()=>a1,Wav2Vec2Model:()=>i1,Wav2Vec2PreTrainedModel:()=>ki,WavLMForAudioFrameClassification:()=>$1,WavLMForCTC:()=>S1,WavLMForSequenceClassification:()=>C1,WavLMForXVector:()=>k1,WavLMModel:()=>P1,WavLMPreTrainedModel:()=>Ia,WeSpeakerResNetModel:()=>p1,WeSpeakerResNetPreTrainedModel:()=>d1,WhisperForConditionalGeneration:()=>Sl,WhisperModel:()=>Oc,WhisperPreTrainedModel:()=>Pl,XLMForQuestionAnswering:()=>Pc,XLMForSequenceClassification:()=>Tc,XLMForTokenClassification:()=>Ec,XLMModel:()=>bi,XLMPreTrainedModel:()=>Tn,XLMRobertaForMaskedLM:()=>Cc,XLMRobertaForQuestionAnswering:()=>Ic,XLMRobertaForSequenceClassification:()=>kc,XLMRobertaForTokenClassification:()=>$c,XLMRobertaModel:()=>Sc,XLMRobertaPreTrainedModel:()=>Zs,XLMWithLMHeadModel:()=>xo,XVectorOutput:()=>Nx,YolosForObjectDetection:()=>Xw,YolosModel:()=>Qw,YolosObjectDetectionOutput:()=>Yw,YolosPreTrainedModel:()=>vh});var r=n("./src/configs.js"),s=n("./src/backends/onnx.js"),i=n("./src/utils/dtypes.js"),o=n("./src/utils/generic.js"),a=n("./src/utils/core.js"),l=n("./src/utils/hub.js"),u=n("./src/utils/constants.js"),p=n("./src/generation/logits_process.js"),c=n("./src/generation/configuration_utils.js"),d=n("./src/utils/tensor.js"),f=n("./src/utils/image.js"),m=n("./src/utils/maths.js"),y=n("./src/generation/stopping_criteria.js"),C=n("./src/generation/logits_sampler.js"),_=n("./src/env.js"),h=n("./src/models/whisper/generation_whisper.js"),w=n("./src/models/whisper/common_whisper.js");const M={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5,ImageTextToText:6,Musicgen:7,MultiModality:8,Phi3V:9,AudioTextToText:10,AutoEncoder:11},x=new Map,b=new Map,T=new Map;async function S(E,k,z){var Wn;let ae=((Wn=z.config)==null?void 0:Wn["transformers.js_config"])??{},ge=z.device??ae.device;ge&&typeof ge!="string"&&(ge.hasOwnProperty(k)?ge=ge[k]:(console.warn(`device not specified for "${k}". Using the default device.`),ge=null));const _e=ge??(_.apis.IS_NODE_ENV?"cpu":"wasm"),Ie=(0,s.deviceToExecutionProviders)(_e),Ne=ae.device_config??{};Ne.hasOwnProperty(_e)&&(ae={...ae,...Ne[_e]});let Ge=z.dtype??ae.dtype;if(typeof Ge!="string"&&(Ge&&Ge.hasOwnProperty(k)?Ge=Ge[k]:(Ge=i.DEFAULT_DEVICE_DTYPE_MAPPING[_e]??i.DATA_TYPES.fp32,console.warn(`dtype not specified for "${k}". Using the default dtype (${Ge}) for this device (${_e}).`))),Ge===i.DATA_TYPES.auto){let St=ae.dtype;typeof St!="string"&&(St=St==null?void 0:St[k]),St&&St!==i.DATA_TYPES.auto&&i.DATA_TYPES.hasOwnProperty(St)?Ge=St:Ge=i.DEFAULT_DEVICE_DTYPE_MAPPING[_e]??i.DATA_TYPES.fp32}const Ye=Ge;if(i.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(Ye)){if(Ye===i.DATA_TYPES.fp16&&_e==="webgpu"&&!await(0,i.isWebGpuFp16Supported)())throw new Error(`The device (${_e}) does not support fp16.`)}else throw new Error(`Invalid dtype: ${Ye}. Should be one of: ${Object.keys(i.DATA_TYPES).join(", ")}`);const dt=ae.kv_cache_dtype,yt=dt?typeof dt=="string"?dt:dt[Ye]??"float32":void 0;if(yt&&!["float32","float16"].includes(yt))throw new Error(`Invalid kv_cache_dtype: ${yt}. Should be one of: float32, float16`);const ct={dtype:Ye,kv_cache_dtype:yt},Pt=i.DEFAULT_DTYPE_SUFFIX_MAPPING[Ye],gt=`${k}${Pt}.onnx`,Et=`${z.subfolder??""}/${gt}`,ot={...z.session_options};ot.executionProviders??(ot.executionProviders=Ie);const kt=ae.free_dimension_overrides;kt?ot.freeDimensionOverrides??(ot.freeDimensionOverrides=kt):_e.startsWith("webnn")&&!ot.freeDimensionOverrides&&console.warn(`WebNN does not currently support dynamic shapes and requires 'free_dimension_overrides' to be set in config.json, preferably as a field within config["transformers.js_config"]["device_config"]["${_e}"]. When 'free_dimension_overrides' is not set, you may experience significant performance degradation.`);const qt=_.apis.IS_NODE_ENV&&_.env.useFSCache,nn=(0,l.getModelFile)(E,Et,!0,z,qt),hn=z.use_external_data_format??ae.use_external_data_format;let cn=[];if(hn){let St;typeof hn=="object"?hn.hasOwnProperty(gt)?St=hn[gt]:hn.hasOwnProperty(k)?St=hn[k]:St=!1:St=hn;const On=+St;if(On>l.MAX_EXTERNAL_DATA_CHUNKS)throw new Error(`The number of external data chunks (${On}) exceeds the maximum allowed value (${l.MAX_EXTERNAL_DATA_CHUNKS}).`);for(let Br=0;Br<On;++Br){const Io=`${gt}_data${Br===0?"":"_"+Br}`,gr=`${z.subfolder??""}/${Io}`;cn.push(new Promise(async(ns,pd)=>{const Ao=await(0,l.getModelFile)(E,gr,!0,z,qt);ns(Ao instanceof Uint8Array?{path:Io,data:Ao}:Io)}))}}else ot.externalData!==void 0&&(cn=ot.externalData.map(async St=>{if(typeof St.data=="string"){const On=await(0,l.getModelFile)(E,St.data,!0,z);return{...St,data:On}}return St}));if(cn.length>0){const St=await Promise.all(cn);_.apis.IS_NODE_ENV||(ot.externalData=St)}if(_e==="webgpu"){const St=(0,r.getKeyValueShapes)(z.config,{prefix:"present"});if(Object.keys(St).length>0&&!(0,s.isONNXProxy)()){const On={};for(const Br in St)On[Br]="gpu-buffer";ot.preferredOutputLocation=On}}return{buffer_or_path:await nn,session_options:ot,session_config:ct}}async function $(E,k,z){return Object.fromEntries(await Promise.all(Object.keys(k).map(async ae=>{const{buffer_or_path:ge,session_options:_e,session_config:Ie}=await S(E,k[ae],z),Ne=await(0,s.createInferenceSession)(ge,_e,Ie);return[ae,Ne]})))}async function O(E,k,z){return Object.fromEntries(await Promise.all(Object.keys(k).map(async ae=>{const ge=await(0,l.getModelJSON)(E,k[ae],!1,z);return[ae,ge]})))}function G(E,k){const z=Object.create(null),ae=[];for(const Ie of E.inputNames){const Ne=k[Ie];if(!(Ne instanceof d.Tensor)){ae.push(Ie);continue}z[Ie]=(0,s.isONNXProxy)()?Ne.clone():Ne}if(ae.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${ae.join(", ")}.`);const ge=Object.keys(k).length,_e=E.inputNames.length;if(ge>_e){let Ie=Object.keys(k).filter(Ne=>!E.inputNames.includes(Ne));console.warn(`WARNING: Too many inputs were provided (${ge} > ${_e}). The following inputs will be ignored: "${Ie.join(", ")}".`)}return z}async function H(E,k){const z=G(E,k);try{const ae=Object.fromEntries(Object.entries(z).map(([_e,Ie])=>[_e,Ie.ort_tensor]));let ge=await E.run(ae);return ge=N(ge),ge}catch(ae){const ge=Object.fromEntries(Object.entries(z).map(([_e,{type:Ie,dims:Ne,data:Ge}])=>[_e,{type:Ie,dims:Ne,data:Ge}]));throw console.error(`An error occurred during model execution: "${ae}".`),console.error("Inputs given to model:",ge),ae}}function N(E){for(let k in E)(0,s.isONNXTensor)(E[k])?E[k]=new d.Tensor(E[k]):typeof E[k]=="object"&&N(E[k]);return E}function J(E){if(E instanceof d.Tensor)return E;if(E.length===0)throw Error("items must be non-empty");if(Array.isArray(E[0])){if(E.some(k=>k.length!==E[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new d.Tensor("int64",BigInt64Array.from(E.flat().map(k=>BigInt(k))),[E.length,E[0].length])}else return new d.Tensor("int64",BigInt64Array.from(E.map(k=>BigInt(k))),[1,E.length])}function q(E){return new d.Tensor("bool",[E],[1])}async function X(E,k){let{encoder_outputs:z,input_ids:ae,decoder_input_ids:ge,..._e}=k;if(!z){const Ne=(0,a.pick)(k,E.sessions.model.inputNames);z=(await Y(E,Ne)).last_hidden_state}return _e.input_ids=ge,_e.encoder_hidden_states=z,E.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(_e.encoder_attention_mask=k.attention_mask),await oe(E,_e,!0)}async function Y(E,k){const z=E.sessions.model,ae=(0,a.pick)(k,z.inputNames);if(z.inputNames.includes("inputs_embeds")&&!ae.inputs_embeds){if(!k.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");ae.inputs_embeds=await E.encode_text({input_ids:k.input_ids})}if(z.inputNames.includes("token_type_ids")&&!ae.token_type_ids){if(!ae.input_ids)throw new Error("Both `input_ids` and `token_type_ids` are missing in the model inputs.");ae.token_type_ids=(0,d.zeros_like)(ae.input_ids)}if(z.inputNames.includes("pixel_mask")&&!ae.pixel_mask){if(!ae.pixel_values)throw new Error("Both `pixel_values` and `pixel_mask` are missing in the model inputs.");const ge=ae.pixel_values.dims;ae.pixel_mask=(0,d.ones)([ge[0],ge[2],ge[3]])}return await H(z,ae)}async function K(E,k){const z=await E.encode(k);return await E.decode(z)}async function oe(E,k,z=!1){const ae=E.sessions[z?"decoder_model_merged":"model"],{past_key_values:ge,..._e}=k;if(ae.inputNames.includes("use_cache_branch")&&(_e.use_cache_branch=q(!!ge)),ae.inputNames.includes("position_ids")&&_e.attention_mask&&!_e.position_ids){const Ne=["paligemma","gemma3_text","gemma3"].includes(E.config.model_type)?1:0;_e.position_ids=de(_e,ge,Ne)}E.addPastKeyValues(_e,ge);const Ie=(0,a.pick)(_e,ae.inputNames);return await H(ae,Ie)}function se({modality_token_id:E,inputs_embeds:k,modality_features:z,input_ids:ae,attention_mask:ge}){const _e=ae.tolist().map(Ye=>Ye.reduce((dt,yt,ct)=>(yt==E&&dt.push(ct),dt),[])),Ie=_e.reduce((Ye,dt)=>Ye+dt.length,0),Ne=z.dims[0];if(Ie!==Ne)throw new Error(`Number of tokens and features do not match: tokens: ${Ie}, features ${Ne}`);let Ge=0;for(let Ye=0;Ye<_e.length;++Ye){const dt=_e[Ye],yt=k[Ye];for(let ct=0;ct<dt.length;++ct)yt[dt[ct]].data.set(z[Ge++].data)}return{inputs_embeds:k,attention_mask:ge}}function F({image_token_id:E,inputs_embeds:k,image_features:z,input_ids:ae,attention_mask:ge}){return se({modality_token_id:E,inputs_embeds:k,modality_features:z,input_ids:ae,attention_mask:ge})}function I({audio_token_id:E,inputs_embeds:k,audio_features:z,input_ids:ae,attention_mask:ge}){return se({modality_token_id:E,inputs_embeds:k,modality_features:z,input_ids:ae,attention_mask:ge})}async function V(E,{encode_function:k,merge_function:z,modality_input_name:ae,modality_output_name:ge,input_ids:_e=null,attention_mask:Ie=null,position_ids:Ne=null,inputs_embeds:Ge=null,past_key_values:Ye=null,generation_config:dt=null,logits_processor:yt=null,...ct}){const Pt=ct[ae];if(!Ge){if(Ge=await E.encode_text({input_ids:_e,...ct}),Pt&&_e.dims[1]!==1){const Et=await k({[ae]:Pt,...ct});({inputs_embeds:Ge,attention_mask:Ie}=z({[ge]:Et,inputs_embeds:Ge,input_ids:_e,attention_mask:Ie}))}else if(Ye&&Pt&&_e.dims[1]===1){const Et=_e.dims[1],ot=Object.values(Ye)[0].dims.at(-2);Ie=(0,d.cat)([(0,d.ones)([_e.dims[0],ot]),Ie.slice(null,[Ie.dims[1]-Et,Ie.dims[1]])],1)}}if(!Ne&&E.config.model_type==="qwen2_vl"){const{image_grid_thw:Et,video_grid_thw:ot}=ct;[Ne]=E.get_rope_index(_e,Et,ot,Ie)}return await oe(E,{inputs_embeds:Ge,past_key_values:Ye,attention_mask:Ie,position_ids:Ne,generation_config:dt,logits_processor:yt},!0)}async function ee(E,k){return await V(E,{...k,modality_input_name:"audio_values",modality_output_name:"audio_features",encode_function:E.encode_audio.bind(E),merge_function:E._merge_input_ids_with_audio_features.bind(E)})}async function pe(E,k){return await V(E,{...k,modality_input_name:"pixel_values",modality_output_name:"image_features",encode_function:E.encode_image.bind(E),merge_function:E._merge_input_ids_with_image_features.bind(E)})}function Z(E,k=0){const[z,ae]=E.dims,ge=E.data,_e=new BigInt64Array(ge.length);for(let Ie=0;Ie<z;++Ie){const Ne=Ie*ae;let Ge=BigInt(k);for(let Ye=0;Ye<ae;++Ye){const dt=Ne+Ye;ge[dt]===0n?_e[dt]=BigInt(1):(_e[dt]=Ge,Ge+=ge[dt])}}return{data:_e,dims:E.dims}}function de(E,k=null,z=0){const{input_ids:ae,inputs_embeds:ge,attention_mask:_e}=E,{data:Ie,dims:Ne}=Z(_e,z);let Ge=new d.Tensor("int64",Ie,Ne);if(k){const Ye=-(ae??ge).dims.at(1);Ge=Ge.slice(null,[Ye,null])}return Ge}function Se(E,k,z,ae){if(z.past_key_values){const ge=Object.values(z.past_key_values)[0].dims.at(-2),{input_ids:_e,attention_mask:Ie}=z;if(!(Ie&&Ie.dims[1]>_e.dims[1])){if(ge<_e.dims[1])z.input_ids=_e.slice(null,[ge,null]);else if(E.config.image_token_index!=null&&_e.data.some(Ne=>Ne==E.config.image_token_index)){const Ne=E.config.num_image_tokens;if(!Ne)throw new Error("`num_image_tokens` is missing in the model configuration.");const Ge=_e.dims[1]-(ge-Ne);z.input_ids=_e.slice(null,[-Ge,null]),z.attention_mask=(0,d.ones)([1,ge+Ge])}}}return z}function Re(E,k,z,ae){return z.past_key_values&&(k=k.map(ge=>[ge.at(-1)])),{...z,decoder_input_ids:J(k)}}function ye(E,...k){return E.config.is_encoder_decoder?Re(E,...k):Se(E,...k)}function Q(E,k,z,ae){const ge=!!z.past_key_values;return ae.guidance_scale!==null&&ae.guidance_scale>1&&(ge?z.input_ids=(0,d.cat)([z.input_ids,z.input_ids],0):(z.input_ids=(0,d.cat)([z.input_ids,(0,d.full_like)(z.input_ids,BigInt(ae.pad_token_id))],0),z.attention_mask=(0,d.cat)([z.attention_mask,(0,d.full_like)(z.attention_mask,0n)],0))),(ge||!z.pixel_values)&&(z.pixel_values=(0,d.full)([0,0,3,384,384],1)),ge&&(z.images_seq_mask=new d.Tensor("bool",new Array(1).fill(!0).fill(!1,0,1),[1,1]),z.images_emb_mask=new d.Tensor("bool",new Array(0).fill(!1),[1,1,0])),z}class j extends o.Callable{constructor(z,ae,ge){super();ie(this,"main_input_name","input_ids");ie(this,"forward_params",["input_ids","attention_mask"]);this.config=z,this.sessions=ae,this.configs=ge;const _e=T.get(this.constructor),Ie=x.get(_e);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,Ie){case M.DecoderOnly:this.can_generate=!0,this._forward=oe,this._prepare_inputs_for_generation=Se;break;case M.Seq2Seq:case M.Vision2Seq:case M.Musicgen:this.can_generate=!0,this._forward=X,this._prepare_inputs_for_generation=Re;break;case M.EncoderDecoder:this._forward=X;break;case M.ImageTextToText:this.can_generate=!0,this._forward=pe,this._prepare_inputs_for_generation=ye;break;case M.AudioTextToText:this.can_generate=!0,this._forward=ee,this._prepare_inputs_for_generation=ye;break;case M.Phi3V:this.can_generate=!0,this._prepare_inputs_for_generation=ye;break;case M.MultiModality:this.can_generate=!0,this._prepare_inputs_for_generation=Q;break;case M.AutoEncoder:this._forward=K;break;default:this._forward=Y;break}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){var ae;const z=[];for(const ge of Object.values(this.sessions))(ae=ge==null?void 0:ge.handler)!=null&&ae.dispose&&z.push(ge.handler.dispose());return await Promise.all(z)}static async from_pretrained(z,{progress_callback:ae=null,config:ge=null,cache_dir:_e=null,local_files_only:Ie=!1,revision:Ne="main",model_file_name:Ge=null,subfolder:Ye="onnx",device:dt=null,dtype:yt=null,use_external_data_format:ct=null,session_options:Pt={}}={}){let gt={progress_callback:ae,config:ge,cache_dir:_e,local_files_only:Ie,revision:Ne,model_file_name:Ge,subfolder:Ye,device:dt,dtype:yt,use_external_data_format:ct,session_options:Pt};const Et=T.get(this),ot=x.get(Et);ge=gt.config=await r.AutoConfig.from_pretrained(z,gt);let kt;if(ot===M.DecoderOnly)kt=await Promise.all([$(z,{model:gt.model_file_name??"model"},gt),O(z,{generation_config:"generation_config.json"},gt)]);else if(ot===M.Seq2Seq||ot===M.Vision2Seq)kt=await Promise.all([$(z,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},gt),O(z,{generation_config:"generation_config.json"},gt)]);else if(ot===M.MaskGeneration)kt=await Promise.all([$(z,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},gt)]);else if(ot===M.EncoderDecoder)kt=await Promise.all([$(z,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},gt)]);else if(ot===M.ImageTextToText){const qt={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};ge.is_encoder_decoder&&(qt.model="encoder_model"),kt=await Promise.all([$(z,qt,gt),O(z,{generation_config:"generation_config.json"},gt)])}else if(ot===M.AudioTextToText){const qt={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",decoder_model_merged:"decoder_model_merged"};kt=await Promise.all([$(z,qt,gt),O(z,{generation_config:"generation_config.json"},gt)])}else if(ot===M.Musicgen)kt=await Promise.all([$(z,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},gt),O(z,{generation_config:"generation_config.json"},gt)]);else if(ot===M.MultiModality)kt=await Promise.all([$(z,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},gt),O(z,{generation_config:"generation_config.json"},gt)]);else if(ot===M.Phi3V)kt=await Promise.all([$(z,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"model",vision_encoder:"vision_encoder"},gt),O(z,{generation_config:"generation_config.json"},gt)]);else if(ot===M.AutoEncoder)kt=await Promise.all([$(z,{encoder_model:"encoder_model",decoder_model:"decoder_model"},gt)]);else{if(ot!==M.EncoderOnly){const qt=Et??(ge==null?void 0:ge.model_type);qt!=="custom"&&console.warn(`Model type for '${qt}' not found, assuming encoder-only architecture. Please report this at ${u.GITHUB_ISSUE_URL}.`)}kt=await Promise.all([$(z,{model:gt.model_file_name??"model"},gt)])}return new this(ge,...kt)}async _call(z){return await this.forward(z)}async forward(z){return await this._forward(this,z)}get generation_config(){var z;return((z=this.configs)==null?void 0:z.generation_config)??null}_get_logits_warper(z){const ae=new p.LogitsProcessorList;return z.temperature!==null&&z.temperature!==1&&ae.push(new p.TemperatureLogitsWarper(z.temperature)),z.top_k!==null&&z.top_k!==0&&ae.push(new p.TopKLogitsWarper(z.top_k)),z.top_p!==null&&z.top_p<1&&ae.push(new p.TopPLogitsWarper(z.top_p)),ae}_get_logits_processor(z,ae,ge=null){const _e=new p.LogitsProcessorList;if(z.repetition_penalty!==null&&z.repetition_penalty!==1&&_e.push(new p.RepetitionPenaltyLogitsProcessor(z.repetition_penalty)),z.no_repeat_ngram_size!==null&&z.no_repeat_ngram_size>0&&_e.push(new p.NoRepeatNGramLogitsProcessor(z.no_repeat_ngram_size)),z.bad_words_ids!==null&&_e.push(new p.NoBadWordsLogitsProcessor(z.bad_words_ids,z.eos_token_id)),z.min_length!==null&&z.eos_token_id!==null&&z.min_length>0&&_e.push(new p.MinLengthLogitsProcessor(z.min_length,z.eos_token_id)),z.min_new_tokens!==null&&z.eos_token_id!==null&&z.min_new_tokens>0&&_e.push(new p.MinNewTokensLengthLogitsProcessor(ae,z.min_new_tokens,z.eos_token_id)),z.forced_bos_token_id!==null&&_e.push(new p.ForcedBOSTokenLogitsProcessor(z.forced_bos_token_id)),z.forced_eos_token_id!==null&&_e.push(new p.ForcedEOSTokenLogitsProcessor(z.max_length,z.forced_eos_token_id)),z.begin_suppress_tokens!==null){const Ie=ae>1||z.forced_bos_token_id===null?ae:ae+1;_e.push(new p.SuppressTokensAtBeginLogitsProcessor(z.begin_suppress_tokens,Ie))}return z.guidance_scale!==null&&z.guidance_scale>1&&_e.push(new p.ClassifierFreeGuidanceLogitsProcessor(z.guidance_scale)),ge!==null&&_e.extend(ge),_e}_prepare_generation_config(z,ae,ge=c.GenerationConfig){const _e={...this.config};for(const Ne of["decoder","generator","text_config"])Ne in _e&&Object.assign(_e,_e[Ne]);const Ie=new ge(_e);return Object.assign(Ie,this.generation_config??{}),z&&Object.assign(Ie,z),ae&&Object.assign(Ie,(0,a.pick)(ae,Object.getOwnPropertyNames(Ie))),Ie}_get_stopping_criteria(z,ae=null){const ge=new y.StoppingCriteriaList;return z.max_length!==null&&ge.push(new y.MaxLengthCriteria(z.max_length,this.config.max_position_embeddings??null)),z.eos_token_id!==null&&ge.push(new y.EosTokenCriteria(z.eos_token_id)),ae&&ge.extend(ae),ge}_validate_model_class(){if(!this.can_generate){const z=[Fh,Lh,Oh,Dh],ae=T.get(this.constructor),ge=new Set,_e=this.config.model_type;for(const Ne of z){const Ge=Ne.get(_e);Ge&&ge.add(Ge[0])}let Ie=`The current model class (${ae}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw ge.size>0&&(Ie+=` Please use the following class instead: ${[...ge].join(", ")}`),Error(Ie)}}prepare_inputs_for_generation(...z){return this._prepare_inputs_for_generation(this,...z)}_update_model_kwargs_for_generation({generated_input_ids:z,outputs:ae,model_inputs:ge,is_encoder_decoder:_e}){return ge.past_key_values=this.getPastKeyValues(ae,ge.past_key_values),ge.input_ids=new d.Tensor("int64",z.flat(),[z.length,1]),_e||(ge.attention_mask=(0,d.cat)([ge.attention_mask,(0,d.ones)([ge.attention_mask.dims[0],1])],1)),ge.position_ids=null,ge}_prepare_model_inputs({inputs:z,bos_token_id:ae,model_kwargs:ge}){const _e=(0,a.pick)(ge,this.forward_params),Ie=this.main_input_name;if(Ie in _e){if(z)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else _e[Ie]=z;return{inputs_tensor:_e[Ie],model_inputs:_e,model_input_name:Ie}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:z,model_inputs:ae,model_input_name:ge,generation_config:_e}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!ae.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:Ne,pixel_values:Ge,attention_mask:Ye,...dt}=ae,yt=await this._prepare_inputs_embeds(ae);ae={...dt,...(0,a.pick)(yt,["inputs_embeds","attention_mask"])}}let{last_hidden_state:Ie}=await Y(this,ae);if(_e.guidance_scale!==null&&_e.guidance_scale>1)Ie=(0,d.cat)([Ie,(0,d.full_like)(Ie,0)],0),"attention_mask"in ae&&(ae.attention_mask=(0,d.cat)([ae.attention_mask,(0,d.zeros_like)(ae.attention_mask)],0));else if(ae.decoder_input_ids){const Ne=J(ae.decoder_input_ids).dims[0];if(Ne!==Ie.dims[0]){if(Ie.dims[0]!==1)throw new Error(`The encoder outputs have a different batch size (${Ie.dims[0]}) than the decoder inputs (${Ne}).`);Ie=(0,d.cat)(Array.from({length:Ne},()=>Ie),0)}}return ae.encoder_outputs=Ie,ae}_prepare_decoder_input_ids_for_generation({batch_size:z,model_input_name:ae,model_kwargs:ge,decoder_start_token_id:_e,bos_token_id:Ie,generation_config:Ne}){let{decoder_input_ids:Ge,...Ye}=ge;if(!(Ge instanceof d.Tensor)){if(Ge)Array.isArray(Ge[0])||(Ge=Array.from({length:z},()=>Ge));else if(_e??(_e=Ie),this.config.model_type==="musicgen")Ge=Array.from({length:z*this.config.decoder.num_codebooks},()=>[_e]);else if(Array.isArray(_e)){if(_e.length!==z)throw new Error(`\`decoder_start_token_id\` expcted to have length ${z} but got ${_e.length}`);Ge=_e}else Ge=Array.from({length:z},()=>[_e]);Ge=J(Ge)}return ge.decoder_attention_mask=(0,d.ones_like)(Ge),{input_ids:Ge,model_inputs:Ye}}async generate({inputs:z=null,generation_config:ae=null,logits_processor:ge=null,stopping_criteria:_e=null,streamer:Ie=null,...Ne}){this._validate_model_class(),ae=this._prepare_generation_config(ae,Ne);let{inputs_tensor:Ge,model_inputs:Ye,model_input_name:dt}=this._prepare_model_inputs({inputs:z,model_kwargs:Ne});const yt=this.config.is_encoder_decoder;yt&&("encoder_outputs"in Ye||(Ye=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:Ge,model_inputs:Ye,model_input_name:dt,generation_config:ae})));let ct;yt?{input_ids:ct,model_inputs:Ye}=this._prepare_decoder_input_ids_for_generation({batch_size:Ye[dt].dims.at(0),model_input_name:dt,model_kwargs:Ye,decoder_start_token_id:ae.decoder_start_token_id,bos_token_id:ae.bos_token_id,generation_config:ae}):ct=Ye[dt];let Pt=ct.dims.at(-1);ae.max_new_tokens!==null&&(ae.max_length=Pt+ae.max_new_tokens);const gt=this._get_logits_processor(ae,Pt,ge),Et=this._get_stopping_criteria(ae,_e),ot=Ye[dt].dims.at(0),kt=C.LogitsSampler.getSampler(ae),qt=new Array(ot).fill(0),nn=ct.tolist();Ie&&Ie.put(nn);let hn,cn={};for(;;){if(Ye=this.prepare_inputs_for_generation(nn,Ye,ae),hn=await this.forward(Ye),ae.output_attentions&&ae.return_dict_in_generate){const gr=this.getAttentions(hn);for(const ns in gr)ns in cn||(cn[ns]=[]),cn[ns].push(gr[ns])}const St=hn.logits.slice(null,-1,null),On=gt(nn,St),Br=[];for(let gr=0;gr<On.dims.at(0);++gr){const ns=On[gr],pd=await kt(ns);for(const[Ao,fd]of pd){const hd=BigInt(Ao);qt[gr]+=fd,nn[gr].push(hd),Br.push([hd]);break}}if(Ie&&Ie.put(Br),Et(nn).every(gr=>gr))break;Ye=this._update_model_kwargs_for_generation({generated_input_ids:Br,outputs:hn,model_inputs:Ye,is_encoder_decoder:yt})}Ie&&Ie.end();const kn=this.getPastKeyValues(hn,Ye.past_key_values,!0),Wn=new d.Tensor("int64",nn.flat(),[nn.length,nn[0].length]);if(ae.return_dict_in_generate)return{sequences:Wn,past_key_values:kn,...cn};for(const St of Object.values(hn))St.location==="gpu-buffer"&&St.dispose();return Wn}getPastKeyValues(z,ae,ge=!1){const _e=Object.create(null);for(const Ie in z)if(Ie.startsWith("present")){const Ne=Ie.replace("present","past_key_values"),Ge=Ie.includes("encoder");if(Ge&&ae?_e[Ne]=ae[Ne]:_e[Ne]=z[Ie],ae&&(!Ge||ge)){const Ye=ae[Ne];Ye.location==="gpu-buffer"&&Ye.dispose()}}return _e}getAttentions(z){const ae={};for(const ge of["cross_attentions","encoder_attentions","decoder_attentions"])for(const _e in z)_e.startsWith(ge)&&(ge in ae||(ae[ge]=[]),ae[ge].push(z[_e]));return ae}addPastKeyValues(z,ae){var ge,_e,Ie;if(ae)Object.assign(z,ae);else{const Ne=this.sessions.decoder_model_merged??this.sessions.model,Ge=((ge=Ne==null?void 0:Ne.config)==null?void 0:ge.kv_cache_dtype)??"float32",Ye=Ge==="float16"?new d.DataTypeMap.float16:[],dt=((Ie=(_e=z[this.main_input_name]??z.attention_mask)==null?void 0:_e.dims)==null?void 0:Ie[0])??1,yt=(0,r.getKeyValueShapes)(this.config,{batch_size:dt});for(const ct in yt)z[ct]=new d.Tensor(Ge,Ye,yt[ct])}}async encode_image({pixel_values:z}){const ae=(await H(this.sessions.vision_encoder,{pixel_values:z})).image_features;return this.config.num_image_tokens||(console.warn(`The number of image tokens was not set in the model configuration. Setting it to the number of features detected by the vision encoder (${ae.dims[1]}).`),this.config.num_image_tokens=ae.dims[1]),ae}async encode_text({input_ids:z}){return(await H(this.sessions.embed_tokens,{input_ids:z})).inputs_embeds}async encode_audio({audio_values:z}){return(await H(this.sessions.audio_encoder,{audio_values:z})).audio_features}}class he{}class be extends he{constructor({last_hidden_state:k,hidden_states:z=null,attentions:ae=null}){super(),this.last_hidden_state=k,this.hidden_states=z,this.attentions=ae}}class we extends j{}class Ce extends we{}class De extends we{async _call(k){return new Yn(await super._call(k))}}class Oe extends we{async _call(k){return new Mt(await super._call(k))}}class Le extends we{async _call(k){return new Un(await super._call(k))}}class je extends we{async _call(k){return new ur(await super._call(k))}}class L extends j{}class re extends L{}class R extends L{async _call(k){return new Yn(await super._call(k))}}class ne extends L{async _call(k){return new Mt(await super._call(k))}}class ue extends L{async _call(k){return new Un(await super._call(k))}}class ve extends j{}class Te extends ve{}class Ae extends j{}class $e extends Ae{}class Ve extends Ae{async _call(k){return new Yn(await super._call(k))}}class Je extends Ae{async _call(k){return new Mt(await super._call(k))}}class qe extends Ae{async _call(k){return new Un(await super._call(k))}}class pt extends Ae{async _call(k){return new ur(await super._call(k))}}class Tt extends j{}class Ht extends Tt{}class $t extends Tt{async _call(k){return new Yn(await super._call(k))}}class Pn extends Tt{async _call(k){return new Mt(await super._call(k))}}class ht extends Tt{async _call(k){return new Un(await super._call(k))}}class Ft extends Tt{async _call(k){return new ur(await super._call(k))}}class Ct extends j{}class Bn extends Ct{}class An extends Ct{async _call(k){return new Yn(await super._call(k))}}class Dr extends Ct{async _call(k){return new Mt(await super._call(k))}}class ft extends Ct{async _call(k){return new Un(await super._call(k))}}class hs extends Ct{async _call(k){return new ur(await super._call(k))}}class br extends j{}class Bs extends br{}class Gt extends br{async _call(k){return new Yn(await super._call(k))}}class ms extends br{async _call(k){return new Mt(await super._call(k))}}class _s extends br{async _call(k){return new Un(await super._call(k))}}class Ns extends br{async _call(k){return new ur(await super._call(k))}}class fn extends j{}class Be extends fn{}class et extends fn{async _call(k){return new Yn(await super._call(k))}}class it extends fn{async _call(k){return new Mt(await super._call(k))}}class Yt extends fn{async _call(k){return new Un(await super._call(k))}}class Or extends fn{async _call(k){return new ur(await super._call(k))}}class _r extends j{}class gs extends _r{}class ys extends _r{async _call(k){return new Yn(await super._call(k))}}class Yr extends _r{async _call(k){return new Mt(await super._call(k))}}class vs extends _r{async _call(k){return new Un(await super._call(k))}}class ws extends _r{async _call(k){return new ur(await super._call(k))}}class Jr extends j{}class or extends Jr{}class uo extends Jr{async _call(k){return new Mt(await super._call(k))}}class ar extends Jr{async _call(k){return new Un(await super._call(k))}}class Xs extends Jr{async _call(k){return new ur(await super._call(k))}}class Ys extends Jr{async _call(k){return new Yn(await super._call(k))}}class qn extends j{}class Mi extends qn{}class co extends qn{async _call(k){return new Yn(await super._call(k))}}class Tr extends qn{async _call(k){return new Mt(await super._call(k))}}class po extends qn{async _call(k){return new Un(await super._call(k))}}class Zr extends j{}class lr extends Zr{}class Js extends Zr{async _call(k){return new Yn(await super._call(k))}}class Nn extends Zr{async _call(k){return new Mt(await super._call(k))}}class Qn extends Zr{async _call(k){return new ur(await super._call(k))}}class Fr extends j{}class fo extends Fr{}class ho extends Fr{async _call(k){return new Yn(await super._call(k))}}class mo extends Fr{async _call(k){return new Mt(await super._call(k))}}class _o extends Fr{async _call(k){return new Un(await super._call(k))}}class go extends Fr{async _call(k){return new ur(await super._call(k))}}class js extends j{}class yo extends js{}class xi extends js{async _call(k){return new Yn(await super._call(k))}}class vo extends js{async _call(k){return new Mt(await super._call(k))}}class wo extends js{async _call(k){return new ur(await super._call(k))}}class Vs extends j{}class Mo extends Vs{}class me extends Vs{async _call(k){return new Mt(await super._call(k))}}class A extends Vs{async _call(k){return new ur(await super._call(k))}}class U extends Vs{async _call(k){return new Yn(await super._call(k))}}class te extends j{constructor(){super(...arguments);ie(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class le extends te{}class fe extends te{}class Ee extends j{}class We extends Ee{}class Xe extends Ee{}class Ke extends j{}class tt extends Ke{}class _t extends Ke{}class It extends j{}class Lt extends It{}class Jt extends It{}class Vt extends It{async _call(k){return new Mt(await super._call(k))}}class un extends j{}class tr extends un{}class jn extends un{}class Vn extends un{async _call(k){return new Mt(await super._call(k))}}class en extends un{}class es extends j{}class Kt extends es{}class Sn extends es{}class Xn extends j{}class ts extends Xn{}class Lr extends Xn{}class Mn extends j{}class zr extends Mn{}class Dn extends Mn{async _call(k){return new Yn(await super._call(k))}}class tn extends Mn{async _call(k){return new Mt(await super._call(k))}}class xn extends Mn{async _call(k){return new Un(await super._call(k))}}class bn extends Mn{async _call(k){return new ur(await super._call(k))}}class Tn extends j{}class bi extends Tn{}class xo extends Tn{async _call(k){return new Yn(await super._call(k))}}class Tc extends Tn{async _call(k){return new Mt(await super._call(k))}}class Ec extends Tn{async _call(k){return new Un(await super._call(k))}}class Pc extends Tn{async _call(k){return new ur(await super._call(k))}}class Zs extends j{}class Sc extends Zs{}class Cc extends Zs{async _call(k){return new Yn(await super._call(k))}}class kc extends Zs{async _call(k){return new Mt(await super._call(k))}}class $c extends Zs{async _call(k){return new Un(await super._call(k))}}class Ic extends Zs{async _call(k){return new ur(await super._call(k))}}class El extends j{}class Ac extends El{}class Dc extends El{}class Pl extends j{constructor(){super(...arguments);ie(this,"requires_attention_mask",!1);ie(this,"main_input_name","input_features");ie(this,"forward_params",["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class Oc extends Pl{}class Sl extends Pl{_prepare_generation_config(k,z){return super._prepare_generation_config(k,z,h.WhisperGenerationConfig)}_retrieve_init_tokens(k){const z=[k.decoder_start_token_id];let ae=k.language;const ge=k.task;if(k.is_multilingual){ae||(console.warn("No language specified - defaulting to English (en)."),ae="en");const Ie=`<|${(0,w.whisper_language_to_code)(ae)}|>`;z.push(k.lang_to_id[Ie]),z.push(k.task_to_id[ge??"transcribe"])}else if(ae||ge)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!k.return_timestamps&&k.no_timestamps_token_id&&z.at(-1)!==k.no_timestamps_token_id?z.push(k.no_timestamps_token_id):k.return_timestamps&&z.at(-1)===k.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),z.pop()),z.filter(_e=>_e!=null)}async generate({inputs:k=null,generation_config:z=null,logits_processor:ae=null,stopping_criteria:ge=null,..._e}){z=this._prepare_generation_config(z,_e);const Ie=_e.decoder_input_ids??this._retrieve_init_tokens(z);if(z.return_timestamps&&(ae??(ae=new p.LogitsProcessorList),ae.push(new p.WhisperTimeStampLogitsProcessor(z,Ie))),z.begin_suppress_tokens&&(ae??(ae=new p.LogitsProcessorList),ae.push(new p.SuppressTokensAtBeginLogitsProcessor(z.begin_suppress_tokens,Ie.length))),z.return_token_timestamps){if(!z.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");z.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),z.output_attentions=!0,z.return_dict_in_generate=!0}const Ne=await super.generate({inputs:k,generation_config:z,logits_processor:ae,decoder_input_ids:Ie,..._e});return z.return_token_timestamps&&(Ne.token_timestamps=this._extract_token_timestamps(Ne,z.alignment_heads,z.num_frames)),Ne}_extract_token_timestamps(k,z,ae=null,ge=.02){if(!k.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");ae==null&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let _e=this.config.median_filter_width;_e===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),_e=7);const Ie=k.cross_attentions,Ne=Array.from({length:this.config.decoder_layers},(Et,ot)=>(0,d.cat)(Ie.map(kt=>kt[ot]),2)),Ge=(0,d.stack)(z.map(([Et,ot])=>{if(Et>=Ne.length)throw new Error(`Layer index ${Et} is out of bounds for cross attentions (length ${Ne.length}).`);return ae?Ne[Et].slice(null,ot,null,[0,ae]):Ne[Et].slice(null,ot)})).transpose(1,0,2,3),[Ye,dt]=(0,d.std_mean)(Ge,-2,0,!0),yt=Ge.clone();for(let Et=0;Et<yt.dims[0];++Et){const ot=yt[Et];for(let kt=0;kt<ot.dims[0];++kt){const qt=ot[kt],nn=Ye[Et][kt][0].data,hn=dt[Et][kt][0].data;for(let cn=0;cn<qt.dims[0];++cn){let kn=qt[cn].data;for(let Wn=0;Wn<kn.length;++Wn)kn[Wn]=(kn[Wn]-hn[Wn])/nn[Wn];kn.set((0,m.medianFilter)(kn,_e))}}}const ct=[(0,d.mean)(yt,1)],Pt=k.sequences.dims,gt=new d.Tensor("float32",new Float32Array(Pt[0]*Pt[1]),Pt);for(let Et=0;Et<Pt[0];++Et){const ot=ct[Et].neg().squeeze_(0),[kt,qt]=(0,m.dynamic_time_warping)(ot.tolist()),nn=Array.from({length:kt.length-1},(kn,Wn)=>kt[Wn+1]-kt[Wn]),hn=(0,a.mergeArrays)([1],nn).map(kn=>!!kn),cn=[];for(let kn=0;kn<hn.length;++kn)hn[kn]&&cn.push(qt[kn]*ge);gt[Et].data.set(cn,1)}return gt}}class Fc extends Sl{}class va extends j{constructor(){super(...arguments);ie(this,"requires_attention_mask",!1);ie(this,"main_input_name","input_values");ie(this,"forward_params",["input_values","decoder_input_ids","past_key_values"])}}class Lc extends va{}class Cl extends va{}class kl extends j{constructor(){super(...arguments);ie(this,"main_input_name","pixel_values");ie(this,"forward_params",["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"])}}class zc extends j{constructor(){super(...arguments);ie(this,"forward_params",["input_ids","attention_mask","pixel_values","position_ids","past_key_values"])}}class bo extends zc{_merge_input_ids_with_image_features({inputs_embeds:k,image_features:z,input_ids:ae,attention_mask:ge}){const _e=this.config.image_token_index,Ne=ae.tolist().map(ct=>ct.findIndex(Pt=>Pt==_e)),Ge=Ne.every(ct=>ct===-1),Ye=Ne.every(ct=>ct!==-1);if(!Ge&&!Ye)throw new Error("Every input should contain either 0 or 1 image token.");if(Ge)return{inputs_embeds:k,attention_mask:ge};const dt=[],yt=[];for(let ct=0;ct<Ne.length;++ct){const Pt=Ne[ct],gt=k[ct],Et=z[ct],ot=ge[ct];dt.push((0,d.cat)([gt.slice([0,Pt]),Et,gt.slice([Pt+1,gt.dims[0]])],0)),yt.push((0,d.cat)([ot.slice([0,Pt]),(0,d.ones)([Et.dims[0]]),ot.slice([Pt+1,ot.dims[0]])],0))}return{inputs_embeds:(0,d.stack)(dt,0),attention_mask:(0,d.stack)(yt,0)}}}class $l extends bo{}class Ti extends bo{}class Rc extends j{constructor(){super(...arguments);ie(this,"forward_params",["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"]);ie(this,"main_input_name","inputs_embeds")}}class Il extends Rc{_merge_input_ids_with_image_features({inputs_embeds:k,image_features:z,input_ids:ae,attention_mask:ge}){return{inputs_embeds:(0,d.cat)([z,k],1),attention_mask:(0,d.cat)([(0,d.ones)(z.dims.slice(0,2)),ge],1)}}async _prepare_inputs_embeds({input_ids:k,pixel_values:z,inputs_embeds:ae,attention_mask:ge}){if(!k&&!z)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let _e,Ie;return k&&(_e=await this.encode_text({input_ids:k})),z&&(Ie=await this.encode_image({pixel_values:z})),_e&&Ie?{inputs_embeds:ae,attention_mask:ge}=this._merge_input_ids_with_image_features({inputs_embeds:_e,image_features:Ie,input_ids:k,attention_mask:ge}):ae=_e||Ie,{inputs_embeds:ae,attention_mask:ge}}async forward({input_ids:k,pixel_values:z,attention_mask:ae,decoder_input_ids:ge,decoder_attention_mask:_e,encoder_outputs:Ie,past_key_values:Ne,inputs_embeds:Ge,decoder_inputs_embeds:Ye}){if(Ge||({inputs_embeds:Ge,attention_mask:ae}=await this._prepare_inputs_embeds({input_ids:k,pixel_values:z,inputs_embeds:Ge,attention_mask:ae})),!Ie){let{last_hidden_state:ct}=await Y(this,{inputs_embeds:Ge,attention_mask:ae});Ie=ct}if(!Ye){if(!ge)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");Ye=await this.encode_text({input_ids:ge})}return await oe(this,{inputs_embeds:Ye,attention_mask:_e,encoder_attention_mask:ae,encoder_hidden_states:Ie,past_key_values:Ne},!0)}}class Bc extends j{constructor(){super(...arguments);ie(this,"forward_params",["input_ids","attention_mask","pixel_values","position_ids","past_key_values"])}}class Nc extends Bc{_merge_input_ids_with_image_features(k){const z=k.image_features.dims.at(-1),ae=k.image_features.view(-1,z);return F({image_token_id:this.config.image_token_index,...k,image_features:ae})}}class jc extends j{constructor(){super(...arguments);ie(this,"forward_params",["input_ids","attention_mask","pixel_values","pixel_attention_mask","position_ids","past_key_values"])}}class Ei extends jc{async encode_image({pixel_values:k,pixel_attention_mask:z}){return(await H(this.sessions.vision_encoder,{pixel_values:k,pixel_attention_mask:z})).image_features}_merge_input_ids_with_image_features(k){const z=k.image_features.dims.at(-1),ae=k.image_features.view(-1,z);return F({image_token_id:this.config.image_token_id,...k,image_features:ae})}}class wa extends Ei{}class Vc extends j{constructor(){super(...arguments);ie(this,"forward_params",["input_ids","inputs_embeds","attention_mask","position_ids","pixel_values","image_sizes","past_key_values"])}}class Al extends Vc{async forward({input_ids:k=null,attention_mask:z=null,pixel_values:ae=null,image_sizes:ge=null,position_ids:_e=null,inputs_embeds:Ie=null,past_key_values:Ne=null,generation_config:Ge=null,logits_processor:Ye=null,...dt}){if(!Ie){let ct;if(ae&&k.dims[1]!==1){if(!ge)throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");({image_features:ct}=await H(this.sessions.vision_encoder,{pixel_values:ae,image_sizes:ge}))}else{const Pt=this.config.normalized_config.hidden_size;ct=new d.Tensor("float32",[],[0,Pt])}({inputs_embeds:Ie}=await H(this.sessions.prepare_inputs_embeds,{input_ids:k,image_features:ct}))}return await oe(this,{inputs_embeds:Ie,past_key_values:Ne,attention_mask:z,position_ids:_e,generation_config:Ge,logits_processor:Ye},!1)}}class ei extends j{}class Uc extends ei{}class Df extends ei{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"text_model"})}}class Wc extends ei{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"text_model"})}}class Of extends ei{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"vision_model"})}}class Gc extends ei{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"vision_model"})}}class Dl extends j{}class To extends Dl{}class Pi extends Dl{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"text_model"})}}class Ol extends ei{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"vision_model"})}}class Hc extends j{}class Kc extends Hc{}class Si extends j{}class Ma extends Si{async forward(k){const z=!k.input_ids,ae=!k.pixel_values;if(z&&ae)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(z&&(k.input_ids=(0,d.ones)([k.pixel_values.dims[0],1])),ae){const{image_size:Ye}=this.config.vision_config;k.pixel_values=(0,d.full)([0,3,Ye,Ye],0)}const{text_embeddings:ge,image_embeddings:_e,l2norm_text_embeddings:Ie,l2norm_image_embeddings:Ne}=await super.forward(k),Ge={};return z||(Ge.text_embeddings=ge,Ge.l2norm_text_embeddings=Ie),ae||(Ge.image_embeddings=_e,Ge.l2norm_image_embeddings=Ne),Ge}}class Fl extends Si{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"text_model"})}}class Ll extends Si{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"vision_model"})}}class xa extends j{}class zl extends xa{}class Rl extends xa{}class ba extends j{}class qc extends ba{}class Bl extends ba{}class Ta extends j{}class Eo extends Ta{}class ut extends Ta{}class Nl extends j{}class jl extends Nl{}class Vl extends Nl{}class Ci extends j{}class Rr extends Ci{}class Po extends Ci{}class So extends j{}class Ul extends So{}class Wl extends So{}class Ea extends j{}class Pa extends Ea{}class Gl extends Ea{}class Sa extends j{}class Hl extends Sa{}class Co extends Sa{}class ko extends j{}class Ca extends ko{}class Kl extends ko{}class ka extends j{}class ql extends ka{}class Ql extends ka{}class $a extends j{}class Xl extends $a{}class g extends $a{}class P extends j{}class D extends P{}class B extends P{}class W extends j{}class ce extends W{}class Pe extends W{}class ze extends j{}class Qe extends ze{}class nt extends ze{}class vt extends j{}class At extends vt{}class Ut extends vt{}class Cn extends j{}class ti extends Cn{}class Qc extends Cn{}class Ff extends j{}class Yy extends Ff{}class Jy extends Ff{}class Lf extends j{}class Zy extends Lf{}class ev extends Lf{}class zf extends j{}class tv extends zf{}class nv extends zf{}class Rf extends j{}class rv extends Rf{}class sv extends Rf{}class Bf extends j{}class iv extends Bf{}class ov extends Bf{}class Nf extends j{}class av extends Nf{}class lv extends Nf{}class uv extends j{constructor(){super(...arguments);ie(this,"forward_params",["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"])}}class cv extends uv{get_rope_index(k,z,ae,ge){const{vision_config:_e,image_token_id:Ie,video_token_id:Ne,vision_start_token_id:Ge}=this.config,Ye=_e.spatial_merge_size??2,dt=[];if(z||ae){let yt=k.tolist();ge||(ge=(0,d.ones_like)(k));const ct=ge.tolist(),Pt=Array.from({length:3},qt=>Array.from({length:k.dims[0]},nn=>Array.from({length:k.dims[1]},hn=>1))),gt=z?z.tolist():[],Et=ae?ae.tolist():[];let ot=0,kt=0;for(let qt=0;qt<yt.length;++qt){const nn=yt[qt].filter((rn,Fn)=>ct[qt][Fn]==1),cn=nn.reduce((rn,Fn,$i)=>(Fn==Ge&&rn.push($i),rn),[]).map(rn=>nn[rn+1]),kn=cn.filter(rn=>rn==Ie).length,Wn=cn.filter(rn=>rn==Ne).length;let St=[],On=0,Br=kn,Io=Wn;for(let rn=0;rn<cn.length;++rn){const Fn=nn.findIndex((Oo,Ms)=>Ms>On&&Oo==Ie),$i=nn.findIndex((Oo,Ms)=>Ms>On&&Oo==Ne),Do=Br>0&&Fn!==-1?Fn:nn.length+1,Da=Io>0&&$i!==-1?$i:nn.length+1;let md,Rh,Bh,Nh;Do<Da?([Rh,Bh,Nh]=gt[ot],++ot,--Br,md=Do):([Rh,Bh,Nh]=Et[kt],++kt,--Io,md=Da);const[GF,jh,_d]=[Number(Rh),Math.floor(Number(Bh)/Ye),Math.floor(Number(Nh)/Ye)],Vh=md-On,Ux=St.length>0?(0,m.max)(St.at(-1))[0]+1:0;St.push(Array.from({length:3*Vh},(Oo,Ms)=>Ux+Ms%Vh));const Uh=Vh+Ux,gd=GF*jh*_d,HF=Array.from({length:gd},(Oo,Ms)=>Uh+Math.floor(Ms/(jh*_d))),KF=Array.from({length:gd},(Oo,Ms)=>Uh+Math.floor(Ms/_d)%jh),qF=Array.from({length:gd},(Oo,Ms)=>Uh+Ms%_d);St.push([HF,KF,qF].flat()),On=md+gd}if(On<nn.length){const rn=St.length>0?(0,m.max)(St.at(-1))[0]+1:0,Fn=nn.length-On;St.push(Array.from({length:3*Fn},($i,Do)=>rn+Do%Fn))}const gr=St.reduce((rn,Fn)=>rn+Fn.length,0),ns=new Array(gr);let pd=0;for(let rn=0;rn<3;++rn)for(let Fn=0;Fn<St.length;++Fn){const $i=St[Fn],Do=$i.length/3;for(let Da=rn*Do;Da<(rn+1)*Do;++Da)ns[pd++]=$i[Da]}let Ao=0;const fd=ct[qt];for(let rn=0;rn<fd.length;++rn)if(fd[rn]==1){for(let Fn=0;Fn<3;++Fn)Pt[Fn][qt][rn]=ns[Fn*gr/3+Ao];++Ao}const hd=(0,m.max)(ns)[0];dt.push(hd+1-yt[qt].length)}return[new d.Tensor("int64",Pt.flat(1/0),[3,k.dims[0],k.dims[1]]),new d.Tensor("int64",dt,[dt.length,1])]}else if(ge){const{data:yt,dims:ct}=Z(ge),Pt=BigInt64Array.from({length:3*yt.length},(Et,ot)=>yt[ot%yt.length]),gt=Array.from({length:ct[0]},(Et,ot)=>(0,m.max)(yt.subarray(ct[1]*ot,ct[1]*(ot+1)))[0]+1n+BigInt(ct[1]));return[new d.Tensor("int64",Pt,[3,...ct]),new d.Tensor("int64",gt,[gt.length,1])]}else{const[yt,ct]=k.dims,Pt=BigInt64Array.from({length:3*yt*ct},(gt,Et)=>BigInt(Math.floor(Et%ct/yt)));return[new d.Tensor("int64",Pt,[3,...k.dims]),(0,d.zeros)([yt,1])]}}async encode_image({pixel_values:k,image_grid_thw:z}){return(await H(this.sessions.vision_encoder,{pixel_values:k,grid_thw:z})).image_features}_merge_input_ids_with_image_features(k){return F({image_token_id:this.config.image_token_id,...k})}prepare_inputs_for_generation(k,z,ae){if(z.attention_mask&&!z.position_ids)if(!z.past_key_values)[z.position_ids,z.rope_deltas]=this.get_rope_index(z.input_ids,z.image_grid_thw,z.video_grid_thw,z.attention_mask);else{z.pixel_values=null;const ge=BigInt(Object.values(z.past_key_values)[0].dims.at(-2)),_e=z.rope_deltas.map(Ie=>ge+Ie);z.position_ids=(0,d.stack)([_e,_e,_e],0)}return z}}class jf extends j{}class dv extends jf{}class pv extends jf{}class Vf extends j{}class fv extends Vf{}class hv extends Vf{}class Uf extends j{}class mv extends Uf{}class _v extends Uf{}class Wf extends j{}class gv extends Wf{}class yv extends Wf{}class Gf extends j{}class vv extends Gf{}class wv extends Gf{}class Hf extends j{}class Mv extends Hf{}class xv extends Hf{async _call(k){return new Mt(await super._call(k))}}class Kf extends j{}class bv extends Kf{}class Tv extends Kf{async _call(k){return new Mt(await super._call(k))}}class Ev extends j{}class Pv extends Ev{}class qf extends j{}class Sv extends qf{}class Cv extends qf{async _call(k){return new Mt(await super._call(k))}}class kv extends j{}class $v extends kv{}class Qf extends j{}class Iv extends Qf{}class Av extends Qf{async _call(k){return new Mt(await super._call(k))}}class Dv extends j{}class Ov extends Dv{}class Xf extends j{}class Fv extends Xf{}class Lv extends Xf{async _call(k){return new Mt(await super._call(k))}}class zv extends j{}class Rv extends zv{async _call(k){return new jx(await super._call(k))}}class Yf extends j{}class Bv extends Yf{}class Nv extends Yf{async _call(k){return new Mt(await super._call(k))}}class Jf extends j{}class jv extends Jf{}class Vv extends Jf{async _call(k){return new Mt(await super._call(k))}}class Zf extends j{}class Uv extends Zf{}class Wv extends Zf{}class eh extends j{}class Gv extends eh{}class Hv extends eh{}class th extends j{}class Kv extends th{}class qv extends th{async _call(k){return new Mt(await super._call(k))}}class Xc extends j{}class Qv extends Xc{}class Xv extends Xc{async _call(k){return new rh(await super._call(k))}}class nh extends Xc{async _call(k){return new Yv(await super._call(k))}}class rh extends he{constructor({logits:k,pred_boxes:z}){super(),this.logits=k,this.pred_boxes=z}}class Yv extends he{constructor({logits:k,pred_boxes:z,pred_masks:ae}){super(),this.logits=k,this.pred_boxes=z,this.pred_masks=ae}}class sh extends j{}class Jv extends sh{}class Zv extends sh{async _call(k){return new Yc(await super._call(k))}}class Yc extends he{constructor({logits:k,pred_boxes:z}){super(),this.logits=k,this.pred_boxes=z}}class ih extends j{}class ew extends ih{}class tw extends ih{async _call(k){return new nw(await super._call(k))}}class nw extends Yc{}class oh extends j{}class rw extends oh{}class sw extends oh{async _call(k){return new iw(await super._call(k))}}class iw extends Yc{}class ah extends j{}class ow extends ah{}class aw extends ah{async _call(k){return new lw(await super._call(k))}}class lw extends rh{}class lh extends j{}class uw extends lh{}class cw extends lh{async _call(k){return new Mt(await super._call(k))}}class uh extends j{}class dw extends uh{}class pw extends uh{async _call(k){return new Mt(await super._call(k))}}class ch extends j{}class fw extends ch{}class hw extends ch{async _call(k){return new Mt(await super._call(k))}}class Jc extends j{}class mw extends Jc{}class _w extends Jc{async _call(k){return new Mt(await super._call(k))}}class gw extends Jc{}class dh extends j{}class yw extends dh{}class vw extends dh{}class ph extends j{}class ww extends ph{}class Mw extends ph{}class xw extends j{}class bw extends xw{}class Zc extends j{}class Tw extends Zc{}class Ew extends Zc{}class Pw extends Zc{}class Sw extends j{}class Cw extends Sw{}class kw extends j{}class $w extends kw{}class Iw extends j{}class Aw extends Iw{}class fh extends j{}class Dw extends fh{}class Ow extends fh{}class hh extends j{}class Fw extends hh{}class Lw extends hh{}class zw extends j{}class Rw extends zw{}class mh extends j{}class Bw extends mh{}class Nw extends mh{async _call(k){return new Mt(await super._call(k))}}class _h extends j{}class jw extends _h{}class Vw extends _h{async _call(k){return new Mt(await super._call(k))}}class gh extends j{}class Uw extends gh{}class Ww extends gh{async _call(k){return new Mt(await super._call(k))}}class yh extends j{}class Gw extends yh{}class Hw extends yh{async _call(k){return new Mt(await super._call(k))}}class Kw extends j{}class qw extends Kw{}class vh extends j{}class Qw extends vh{}class Xw extends vh{async _call(k){return new Yw(await super._call(k))}}class Yw extends he{constructor({logits:k,pred_boxes:z}){super(),this.logits=k,this.pred_boxes=z}}class Jw extends j{}class Zw extends Jw{async get_image_embeddings({pixel_values:k}){return await Y(this,{pixel_values:k})}async forward(k){if((!k.image_embeddings||!k.image_positional_embeddings)&&(k={...k,...await this.get_image_embeddings(k)}),!k.input_labels&&k.input_points){const ae=k.input_points.dims.slice(0,-1),ge=ae.reduce((_e,Ie)=>_e*Ie,1);k.input_labels=new d.Tensor("int64",new BigInt64Array(ge).fill(1n),ae)}const z={image_embeddings:k.image_embeddings,image_positional_embeddings:k.image_positional_embeddings};return k.input_points&&(z.input_points=k.input_points),k.input_labels&&(z.input_labels=k.input_labels),k.input_boxes&&(z.input_boxes=k.input_boxes),await H(this.sessions.prompt_encoder_mask_decoder,z)}async _call(k){return new e1(await super._call(k))}}class e1 extends he{constructor({iou_scores:k,pred_masks:z}){super(),this.iou_scores=k,this.pred_masks=z}}class wh extends j{}class t1 extends wh{}class n1 extends wh{}class Mh extends j{}class r1 extends Mh{}class s1 extends Mh{}class ki extends j{}class i1 extends ki{}class o1 extends ki{async _call(k){return new $o(await super._call(k))}}class a1 extends ki{async _call(k){return new Mt(await super._call(k))}}class l1 extends ki{async _call(k){return new Un(await super._call(k))}}class xh extends j{}class u1 extends xh{}class c1 extends xh{async _call(k){return new Un(await super._call(k))}}class d1 extends j{}class p1 extends d1{}class ed extends j{}class f1 extends ed{}class h1 extends ed{async _call(k){return new $o(await super._call(k))}}class m1 extends ed{async _call(k){return new Mt(await super._call(k))}}class Yl extends j{}class _1 extends Yl{}class g1 extends Yl{async _call(k){return new $o(await super._call(k))}}class y1 extends Yl{async _call(k){return new Mt(await super._call(k))}}class v1 extends Yl{async _call(k){return new Un(await super._call(k))}}class td extends j{}class w1 extends td{}class M1 extends td{async _call(k){return new $o(await super._call(k))}}class x1 extends td{async _call(k){return new Mt(await super._call(k))}}class $F extends j{}class b1 extends ki{}class T1 extends ki{async _call(k){return new $o(await super._call(k))}}class E1 extends ki{async _call(k){return new Mt(await super._call(k))}}class Ia extends j{}class P1 extends Ia{}class S1 extends Ia{async _call(k){return new $o(await super._call(k))}}class C1 extends Ia{async _call(k){return new Mt(await super._call(k))}}class k1 extends Ia{async _call(k){return new Nx(await super._call(k))}}class $1 extends Ia{async _call(k){return new Un(await super._call(k))}}class I1 extends j{}class A1 extends I1{}class nd extends j{}class IF extends nd{}class D1 extends nd{}class O1 extends nd{async generate_speech(k,z,{threshold:ae=.5,minlenratio:ge=0,maxlenratio:_e=20,vocoder:Ie=null}={}){const Ne={input_ids:k},{encoder_outputs:Ge,encoder_attention_mask:Ye}=await Y(this,Ne),dt=Ge.dims[1]/this.config.reduction_factor,yt=Math.floor(dt*_e),ct=Math.floor(dt*ge),Pt=this.config.num_mel_bins;let gt=[],Et=null,ot=null,kt=0;for(;;){++kt;const hn=q(!!ot);let cn;ot?cn=ot.output_sequence_out:cn=new d.Tensor("float32",new Float32Array(Pt),[1,1,Pt]);let kn={use_cache_branch:hn,output_sequence:cn,encoder_attention_mask:Ye,speaker_embeddings:z,encoder_hidden_states:Ge};this.addPastKeyValues(kn,Et),ot=await H(this.sessions.decoder_model_merged,kn),Et=this.getPastKeyValues(ot,Et);const{prob:Wn,spectrum:St}=ot;if(gt.push(St),kt>=ct&&(Array.from(Wn.data).filter(On=>On>=ae).length>0||kt>=yt))break}const qt=(0,d.cat)(gt),{waveform:nn}=await H(Ie.sessions.model,{spectrogram:qt});return{spectrogram:qt,waveform:nn}}}class F1 extends j{constructor(){super(...arguments);ie(this,"main_input_name","spectrogram")}}class L1 extends j{}class z1 extends L1{}class bh extends j{}class R1 extends bh{}class B1 extends bh{}class Th extends j{}class N1 extends Th{}class j1 extends Th{}class Eh extends j{}class V1 extends Eh{}class U1 extends Eh{}class rd extends j{}class W1 extends rd{}class G1 extends rd{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"text_model"})}}class H1 extends rd{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"audio_model"})}}class K1 extends j{}class Ph extends K1{async _call(k){return new Vx(await super._call(k))}}class sd extends j{}class AF extends sd{}class q1 extends sd{}class Q1 extends sd{}class Sh extends j{}class X1 extends Sh{}class Y1 extends Sh{}class Ch extends j{}class J1 extends Ch{}class Z1 extends Ch{async _call(k){return new Mt(await super._call(k))}}class kh extends j{}class DF extends kh{}class OF extends kh{}class $h extends j{constructor(){super(...arguments);ie(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}_apply_and_filter_by_delay_pattern_mask(z){const[ae,ge]=z.dims,_e=this.config.decoder.num_codebooks,Ie=ge-_e;let Ne=0;for(let dt=0;dt<z.size;++dt){if(z.data[dt]===this.config.decoder.pad_token_id)continue;const yt=dt%ge,ct=Math.floor(dt/ge)%_e,Pt=yt-ct;Pt>0&&Pt<=Ie&&(z.data[Ne++]=z.data[dt])}const Ge=Math.floor(ae/_e),Ye=Ne/(Ge*_e);return new d.Tensor(z.type,z.data.slice(0,Ne),[Ge,_e,Ye])}prepare_inputs_for_generation(z,ae,ge){let _e=structuredClone(z);for(let Ne=0;Ne<_e.length;++Ne)for(let Ge=0;Ge<_e[Ne].length;++Ge)Ne%this.config.decoder.num_codebooks>=Ge&&(_e[Ne][Ge]=BigInt(this.config.decoder.pad_token_id));return ge.guidance_scale!==null&&ge.guidance_scale>1&&(_e=_e.concat(_e)),super.prepare_inputs_for_generation(_e,ae,ge)}async generate(z){const ae=await super.generate(z),ge=this._apply_and_filter_by_delay_pattern_mask(ae).unsqueeze_(0),{audio_values:_e}=await H(this.sessions.encodec_decode,{audio_codes:ge});return _e}}class id extends j{}class eM extends id{}class tM extends id{async _call(k){return new Mt(await super._call(k))}}class nM extends id{}class od extends j{}class rM extends od{}class sM extends od{async _call(k){return new Mt(await super._call(k))}}class iM extends od{}class ad extends j{}class oM extends ad{}class aM extends ad{async _call(k){return new Mt(await super._call(k))}}class lM extends ad{}class ld extends j{}class uM extends ld{}class cM extends ld{async _call(k){return new Mt(await super._call(k))}}class dM extends ld{}class pM extends j{}class fM extends pM{}class hM extends j{}class mM extends hM{constructor(...z){super(...z);ie(this,"forward_params",["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"]);this._generation_mode="text"}async forward(z){const ae=this._generation_mode??"text";let ge;if(ae==="text"||!z.past_key_values){const Ye=this.sessions.prepare_inputs_embeds,dt=(0,a.pick)(z,Ye.inputNames);ge=await H(Ye,dt)}else{const Ye=this.sessions.gen_img_embeds,dt=(0,a.pick)({image_ids:z.input_ids},Ye.inputNames);ge=await H(Ye,dt)}const _e={...z,...ge},Ie=await oe(this,_e),Ne=this.sessions[ae==="text"?"lm_head":"gen_head"];if(!Ne)throw new Error(`Unable to find "${Ne}" generation head`);const Ge=await H(Ne,(0,a.pick)(Ie,Ne.inputNames));return{...ge,...Ie,...Ge}}async generate(z){return this._generation_mode="text",super.generate(z)}async generate_images(z){this._generation_mode="image";const ae=(z.inputs??z[this.main_input_name]).dims[1],_e=(await super.generate(z)).slice(null,[ae,null]),Ie=this.sessions.image_decode,{decoded_image:Ne}=await H(Ie,{generated_tokens:_e}),Ge=Ne.add_(1).mul_(255/2).clamp_(0,255).to("uint8"),Ye=[];for(const dt of Ge){const yt=f.RawImage.fromTensor(dt);Ye.push(yt)}return Ye}}class _M extends he{constructor({char_logits:k,bpe_logits:z,wp_logits:ae}){super(),this.char_logits=k,this.bpe_logits=z,this.wp_logits=ae}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class gM extends j{}class yM extends gM{async _call(k){return new _M(await super._call(k))}}class Ih extends j{}class vM extends Ih{}class wM extends Ih{}class Ah extends j{}class MM extends Ah{}class xM extends Ah{}class bM extends j{constructor(){super(...arguments);ie(this,"forward_params",["input_ids","attention_mask","position_ids","audio_values","past_key_values"])}}class TM extends bM{_merge_input_ids_with_audio_features(k){const z=k.audio_features.dims.at(-1),ae=k.audio_features.view(-1,z);return I({audio_token_id:this.config.ignore_index,...k,audio_features:ae})}}class ud extends j{constructor(){super(...arguments);ie(this,"main_input_name","input_values");ie(this,"forward_params",["input_values"])}}class EM extends he{constructor({audio_codes:k}){super(),this.audio_codes=k}}class PM extends he{constructor({audio_values:k}){super(),this.audio_values=k}}class SM extends ud{async encode(k){return new EM(await H(this.sessions.encoder_model,k))}async decode(k){return new PM(await H(this.sessions.decoder_model,k))}}class CM extends ud{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"encoder_model"})}}class kM extends ud{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"decoder_model"})}}class cd extends j{constructor(){super(...arguments);ie(this,"main_input_name","input_values");ie(this,"forward_params",["input_values"])}}class $M extends he{constructor({audio_codes:k}){super(),this.audio_codes=k}}class IM extends he{constructor({audio_values:k}){super(),this.audio_values=k}}class AM extends cd{async encode(k){return new $M(await H(this.sessions.encoder_model,k))}async decode(k){return new IM(await H(this.sessions.decoder_model,k))}}class DM extends cd{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"encoder_model"})}}class OM extends cd{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"decoder_model"})}}class dd extends j{constructor(){super(...arguments);ie(this,"main_input_name","input_values");ie(this,"forward_params",["input_values"])}}class FM extends dd{async encode(k){return await H(this.sessions.encoder_model,k)}async decode(k){return await H(this.sessions.decoder_model,k)}}class LM extends dd{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"encoder_model"})}}class zM extends dd{static async from_pretrained(k,z={}){return super.from_pretrained(k,{...z,model_file_name:z.model_file_name??"decoder_model"})}}class zt{static async from_pretrained(k,{progress_callback:z=null,config:ae=null,cache_dir:ge=null,local_files_only:_e=!1,revision:Ie="main",model_file_name:Ne=null,subfolder:Ge="onnx",device:Ye=null,dtype:dt=null,use_external_data_format:yt=null,session_options:ct={}}={}){const Pt={progress_callback:z,config:ae,cache_dir:ge,local_files_only:_e,revision:Ie,model_file_name:Ne,subfolder:Ge,device:Ye,dtype:dt,use_external_data_format:yt,session_options:ct};if(Pt.config=await r.AutoConfig.from_pretrained(k,Pt),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);const gt=Pt.config.model_type;for(const Et of this.MODEL_CLASS_MAPPINGS){let ot=Et.get(gt);if(!ot){for(const kt of Et.values())if(kt[0]===gt){ot=kt;break}if(!ot)continue}return await ot[1].from_pretrained(k,Pt)}if(this.BASE_IF_FAIL)return ux.has(gt)||console.warn(`Unknown model class "${gt}", attempting to construct from base class.`),await j.from_pretrained(k,Pt);throw Error(`Unsupported model type: ${gt}`)}}ie(zt,"MODEL_CLASS_MAPPINGS",null),ie(zt,"BASE_IF_FAIL",!1);const FF=new Map([["bert",["BertModel",Ce]],["modernbert",["ModernBertModel",re]],["nomic_bert",["NomicBertModel",Te]],["roformer",["RoFormerModel",$e]],["electra",["ElectraModel",Bn]],["esm",["EsmModel",Mi]],["convbert",["ConvBertModel",Ht]],["camembert",["CamembertModel",Bs]],["deberta",["DebertaModel",Be]],["deberta-v2",["DebertaV2Model",gs]],["mpnet",["MPNetModel",fo]],["albert",["AlbertModel",Mo]],["distilbert",["DistilBertModel",or]],["roberta",["RobertaModel",zr]],["xlm",["XLMModel",bi]],["xlm-roberta",["XLMRobertaModel",Sc]],["clap",["ClapModel",W1]],["clip",["CLIPModel",Uc]],["clipseg",["CLIPSegModel",zl]],["chinese_clip",["ChineseCLIPModel",Kc]],["siglip",["SiglipModel",To]],["jina_clip",["JinaCLIPModel",Ma]],["mobilebert",["MobileBertModel",lr]],["squeezebert",["SqueezeBertModel",yo]],["wav2vec2",["Wav2Vec2Model",i1]],["wav2vec2-bert",["Wav2Vec2BertModel",w1]],["unispeech",["UniSpeechModel",f1]],["unispeech-sat",["UniSpeechSatModel",_1]],["hubert",["HubertModel",b1]],["wavlm",["WavLMModel",P1]],["audio-spectrogram-transformer",["ASTModel",Ac]],["vits",["VitsModel",Ph]],["pyannote",["PyAnnoteModel",u1]],["wespeaker-resnet",["WeSpeakerResNetModel",p1]],["detr",["DetrModel",Qv]],["rt_detr",["RTDetrModel",Jv]],["rt_detr_v2",["RTDetrV2Model",ew]],["rf_detr",["RFDetrModel",rw]],["table-transformer",["TableTransformerModel",ow]],["vit",["ViTModel",Mv]],["ijepa",["IJepaModel",bv]],["pvt",["PvtModel",Sv]],["vit_msn",["ViTMSNModel",Iv]],["vit_mae",["ViTMAEModel",$v]],["groupvit",["GroupViTModel",Ov]],["fastvit",["FastViTModel",Fv]],["mobilevit",["MobileViTModel",Bv]],["mobilevitv2",["MobileViTV2Model",jv]],["owlvit",["OwlViTModel",Uv]],["owlv2",["Owlv2Model",Gv]],["beit",["BeitModel",Kv]],["deit",["DeiTModel",uw]],["hiera",["HieraModel",dw]],["convnext",["ConvNextModel",Bw]],["convnextv2",["ConvNextV2Model",jw]],["dinov2",["Dinov2Model",Uw]],["dinov2_with_registers",["Dinov2WithRegistersModel",Gw]],["resnet",["ResNetModel",fw]],["swin",["SwinModel",mw]],["swin2sr",["Swin2SRModel",yw]],["donut-swin",["DonutSwinModel",Rw]],["yolos",["YolosModel",Qw]],["dpt",["DPTModel",ww]],["glpn",["GLPNModel",Fw]],["hifigan",["SpeechT5HifiGan",F1]],["efficientnet",["EfficientNetModel",J1]],["decision_transformer",["DecisionTransformerModel",fM]],["patchtst",["PatchTSTForPrediction",vM]],["patchtsmixer",["PatchTSMixerForPrediction",MM]],["mobilenet_v1",["MobileNetV1Model",eM]],["mobilenet_v2",["MobileNetV2Model",rM]],["mobilenet_v3",["MobileNetV3Model",oM]],["mobilenet_v4",["MobileNetV4Model",uM]],["maskformer",["MaskFormerModel",Dw]],["mgp-str",["MgpstrForSceneTextRecognition",yM]],["style_text_to_speech_2",["StyleTextToSpeech2Model",A1]]]),LF=new Map([["t5",["T5Model",le]],["longt5",["LongT5Model",We]],["mt5",["MT5Model",tt]],["bart",["BartModel",Lt]],["mbart",["MBartModel",tr]],["marian",["MarianModel",t1]],["whisper",["WhisperModel",Oc]],["m2m_100",["M2M100Model",r1]],["blenderbot",["BlenderbotModel",Kt]],["blenderbot-small",["BlenderbotSmallModel",ts]]]),zF=new Map([["mimi",["MimiModel",SM]],["dac",["DacModel",AM]],["snac",["SnacModel",FM]]]),RF=new Map([["bloom",["BloomModel",mv]],["jais",["JAISModel",Eo]],["gpt2",["GPT2Model",qc]],["gptj",["GPTJModel",Ul]],["gpt_bigcode",["GPTBigCodeModel",Pa]],["gpt_neo",["GPTNeoModel",jl]],["gpt_neox",["GPTNeoXModel",Rr]],["codegen",["CodeGenModel",Hl]],["llama",["LlamaModel",Ca]],["exaone",["ExaoneModel",D]],["olmo",["OlmoModel",Qe]],["olmo2",["Olmo2Model",At]],["mobilellm",["MobileLLMModel",ce]],["granite",["GraniteModel",ti]],["cohere",["CohereModel",Yy]],["gemma",["GemmaModel",Zy]],["gemma2",["Gemma2Model",tv]],["gemma3_text",["Gemma3Model",rv]],["helium",["HeliumModel",ql]],["glm",["GlmModel",Xl]],["openelm",["OpenELMModel",iv]],["qwen2",["Qwen2Model",av]],["phi",["PhiModel",dv]],["phi3",["Phi3Model",fv]],["mpt",["MptModel",gv]],["opt",["OPTModel",vv]],["mistral",["MistralModel",R1]],["starcoder2",["Starcoder2Model",N1]],["falcon",["FalconModel",V1]],["stablelm",["StableLmModel",X1]]]),Dh=new Map([["speecht5",["SpeechT5ForSpeechToText",D1]],["whisper",["WhisperForConditionalGeneration",Sl]],["lite-whisper",["LiteWhisperForConditionalGeneration",Fc]],["moonshine",["MoonshineForConditionalGeneration",Cl]]]),RM=new Map([["speecht5",["SpeechT5ForTextToSpeech",O1]]]),BM=new Map([["vits",["VitsModel",Ph]],["musicgen",["MusicgenForConditionalGeneration",$h]]]),NM=new Map([["bert",["BertForSequenceClassification",Oe]],["modernbert",["ModernBertForSequenceClassification",ne]],["roformer",["RoFormerForSequenceClassification",Je]],["electra",["ElectraForSequenceClassification",Dr]],["esm",["EsmForSequenceClassification",Tr]],["convbert",["ConvBertForSequenceClassification",Pn]],["camembert",["CamembertForSequenceClassification",ms]],["deberta",["DebertaForSequenceClassification",it]],["deberta-v2",["DebertaV2ForSequenceClassification",Yr]],["mpnet",["MPNetForSequenceClassification",mo]],["albert",["AlbertForSequenceClassification",me]],["distilbert",["DistilBertForSequenceClassification",uo]],["roberta",["RobertaForSequenceClassification",tn]],["xlm",["XLMForSequenceClassification",Tc]],["xlm-roberta",["XLMRobertaForSequenceClassification",kc]],["bart",["BartForSequenceClassification",Vt]],["mbart",["MBartForSequenceClassification",Vn]],["mobilebert",["MobileBertForSequenceClassification",Nn]],["squeezebert",["SqueezeBertForSequenceClassification",vo]]]),jM=new Map([["bert",["BertForTokenClassification",Le]],["modernbert",["ModernBertForTokenClassification",ue]],["roformer",["RoFormerForTokenClassification",qe]],["electra",["ElectraForTokenClassification",ft]],["esm",["EsmForTokenClassification",po]],["convbert",["ConvBertForTokenClassification",ht]],["camembert",["CamembertForTokenClassification",_s]],["deberta",["DebertaForTokenClassification",Yt]],["deberta-v2",["DebertaV2ForTokenClassification",vs]],["mpnet",["MPNetForTokenClassification",_o]],["distilbert",["DistilBertForTokenClassification",ar]],["roberta",["RobertaForTokenClassification",xn]],["xlm",["XLMForTokenClassification",Ec]],["xlm-roberta",["XLMRobertaForTokenClassification",$c]]]),Oh=new Map([["t5",["T5ForConditionalGeneration",fe]],["longt5",["LongT5ForConditionalGeneration",Xe]],["mt5",["MT5ForConditionalGeneration",_t]],["bart",["BartForConditionalGeneration",Jt]],["mbart",["MBartForConditionalGeneration",jn]],["marian",["MarianMTModel",n1]],["m2m_100",["M2M100ForConditionalGeneration",s1]],["blenderbot",["BlenderbotForConditionalGeneration",Sn]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",Lr]]]),Fh=new Map([["bloom",["BloomForCausalLM",_v]],["gpt2",["GPT2LMHeadModel",Bl]],["jais",["JAISLMHeadModel",ut]],["gptj",["GPTJForCausalLM",Wl]],["gpt_bigcode",["GPTBigCodeForCausalLM",Gl]],["gpt_neo",["GPTNeoForCausalLM",Vl]],["gpt_neox",["GPTNeoXForCausalLM",Po]],["codegen",["CodeGenForCausalLM",Co]],["llama",["LlamaForCausalLM",Kl]],["exaone",["ExaoneForCausalLM",B]],["olmo",["OlmoForCausalLM",nt]],["olmo2",["Olmo2ForCausalLM",Ut]],["mobilellm",["MobileLLMForCausalLM",Pe]],["granite",["GraniteForCausalLM",Qc]],["cohere",["CohereForCausalLM",Jy]],["gemma",["GemmaForCausalLM",ev]],["gemma2",["Gemma2ForCausalLM",nv]],["gemma3_text",["Gemma3ForCausalLM",sv]],["helium",["HeliumForCausalLM",Ql]],["glm",["GlmForCausalLM",g]],["openelm",["OpenELMForCausalLM",ov]],["qwen2",["Qwen2ForCausalLM",lv]],["phi",["PhiForCausalLM",pv]],["phi3",["Phi3ForCausalLM",hv]],["mpt",["MptForCausalLM",yv]],["opt",["OPTForCausalLM",wv]],["mbart",["MBartForCausalLM",en]],["mistral",["MistralForCausalLM",B1]],["starcoder2",["Starcoder2ForCausalLM",j1]],["falcon",["FalconForCausalLM",U1]],["trocr",["TrOCRForCausalLM",z1]],["stablelm",["StableLmForCausalLM",Y1]],["phi3_v",["Phi3VForCausalLM",Al]]]),BF=new Map([["multi_modality",["MultiModalityCausalLM",mM]]]),VM=new Map([["bert",["BertForMaskedLM",De]],["modernbert",["ModernBertForMaskedLM",R]],["roformer",["RoFormerForMaskedLM",Ve]],["electra",["ElectraForMaskedLM",An]],["esm",["EsmForMaskedLM",co]],["convbert",["ConvBertForMaskedLM",$t]],["camembert",["CamembertForMaskedLM",Gt]],["deberta",["DebertaForMaskedLM",et]],["deberta-v2",["DebertaV2ForMaskedLM",ys]],["mpnet",["MPNetForMaskedLM",ho]],["albert",["AlbertForMaskedLM",U]],["distilbert",["DistilBertForMaskedLM",Ys]],["roberta",["RobertaForMaskedLM",Dn]],["xlm",["XLMWithLMHeadModel",xo]],["xlm-roberta",["XLMRobertaForMaskedLM",Cc]],["mobilebert",["MobileBertForMaskedLM",Js]],["squeezebert",["SqueezeBertForMaskedLM",xi]]]),UM=new Map([["bert",["BertForQuestionAnswering",je]],["roformer",["RoFormerForQuestionAnswering",pt]],["electra",["ElectraForQuestionAnswering",hs]],["convbert",["ConvBertForQuestionAnswering",Ft]],["camembert",["CamembertForQuestionAnswering",Ns]],["deberta",["DebertaForQuestionAnswering",Or]],["deberta-v2",["DebertaV2ForQuestionAnswering",ws]],["mpnet",["MPNetForQuestionAnswering",go]],["albert",["AlbertForQuestionAnswering",A]],["distilbert",["DistilBertForQuestionAnswering",Xs]],["roberta",["RobertaForQuestionAnswering",bn]],["xlm",["XLMForQuestionAnswering",Pc]],["xlm-roberta",["XLMRobertaForQuestionAnswering",Ic]],["mobilebert",["MobileBertForQuestionAnswering",Qn]],["squeezebert",["SqueezeBertForQuestionAnswering",wo]]]),Lh=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",kl]],["idefics3",["Idefics3ForConditionalGeneration",Ei]],["smolvlm",["SmolVLMForConditionalGeneration",wa]]]),WM=new Map([["llava",["LlavaForConditionalGeneration",bo]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",$l]],["moondream1",["Moondream1ForConditionalGeneration",Ti]],["florence2",["Florence2ForConditionalGeneration",Il]],["qwen2-vl",["Qwen2VLForConditionalGeneration",cv]],["idefics3",["Idefics3ForConditionalGeneration",Ei]],["smolvlm",["SmolVLMForConditionalGeneration",wa]],["paligemma",["PaliGemmaForConditionalGeneration",Nc]]]),GM=new Map([["ultravox",["UltravoxModel",TM]]]),NF=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",kl]]]),HM=new Map([["vit",["ViTForImageClassification",xv]],["ijepa",["IJepaForImageClassification",Tv]],["pvt",["PvtForImageClassification",Cv]],["vit_msn",["ViTMSNForImageClassification",Av]],["fastvit",["FastViTForImageClassification",Lv]],["mobilevit",["MobileViTForImageClassification",Nv]],["mobilevitv2",["MobileViTV2ForImageClassification",Vv]],["beit",["BeitForImageClassification",qv]],["deit",["DeiTForImageClassification",cw]],["hiera",["HieraForImageClassification",pw]],["convnext",["ConvNextForImageClassification",Nw]],["convnextv2",["ConvNextV2ForImageClassification",Vw]],["dinov2",["Dinov2ForImageClassification",Ww]],["dinov2_with_registers",["Dinov2WithRegistersForImageClassification",Hw]],["resnet",["ResNetForImageClassification",hw]],["swin",["SwinForImageClassification",_w]],["segformer",["SegformerForImageClassification",q1]],["efficientnet",["EfficientNetForImageClassification",Z1]],["mobilenet_v1",["MobileNetV1ForImageClassification",tM]],["mobilenet_v2",["MobileNetV2ForImageClassification",sM]],["mobilenet_v3",["MobileNetV3ForImageClassification",aM]],["mobilenet_v4",["MobileNetV4ForImageClassification",cM]]]),KM=new Map([["detr",["DetrForObjectDetection",Xv]],["rt_detr",["RTDetrForObjectDetection",Zv]],["rt_detr_v2",["RTDetrV2ForObjectDetection",tw]],["rf_detr",["RFDetrForObjectDetection",sw]],["table-transformer",["TableTransformerForObjectDetection",aw]],["yolos",["YolosForObjectDetection",Xw]]]),qM=new Map([["owlvit",["OwlViTForObjectDetection",Wv]],["owlv2",["Owlv2ForObjectDetection",Hv]],["grounding-dino",["GroundingDinoForObjectDetection",qw]]]),Aa=new Map([["detr",["DetrForSegmentation",nh]],["clipseg",["CLIPSegForImageSegmentation",Rl]]]),QM=new Map([["segformer",["SegformerForSemanticSegmentation",Q1]],["sapiens",["SapiensForSemanticSegmentation",Tw]],["swin",["SwinForSemanticSegmentation",gw]],["mobilenet_v1",["MobileNetV1ForSemanticSegmentation",nM]],["mobilenet_v2",["MobileNetV2ForSemanticSegmentation",iM]],["mobilenet_v3",["MobileNetV3ForSemanticSegmentation",lM]],["mobilenet_v4",["MobileNetV4ForSemanticSegmentation",dM]]]),XM=new Map([["detr",["DetrForSegmentation",nh]],["maskformer",["MaskFormerForInstanceSegmentation",Ow]]]),YM=new Map([["sam",["SamModel",Zw]]]),JM=new Map([["wav2vec2",["Wav2Vec2ForCTC",o1]],["wav2vec2-bert",["Wav2Vec2BertForCTC",M1]],["unispeech",["UniSpeechForCTC",h1]],["unispeech-sat",["UniSpeechSatForCTC",g1]],["wavlm",["WavLMForCTC",S1]],["hubert",["HubertForCTC",T1]]]),ZM=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",a1]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",x1]],["unispeech",["UniSpeechForSequenceClassification",m1]],["unispeech-sat",["UniSpeechSatForSequenceClassification",y1]],["wavlm",["WavLMForSequenceClassification",C1]],["hubert",["HubertForSequenceClassification",E1]],["audio-spectrogram-transformer",["ASTForAudioClassification",Dc]]]),ex=new Map([["wavlm",["WavLMForXVector",k1]]]),tx=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",v1]],["wavlm",["WavLMForAudioFrameClassification",$1]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",l1]],["pyannote",["PyAnnoteForAudioFrameClassification",c1]]]),nx=new Map([["vitmatte",["VitMatteForImageMatting",Rv]]]),jF=new Map([["patchtst",["PatchTSTForPrediction",wM]],["patchtsmixer",["PatchTSMixerForPrediction",xM]]]),rx=new Map([["swin2sr",["Swin2SRForImageSuperResolution",vw]]]),sx=new Map([["dpt",["DPTForDepthEstimation",Mw]],["depth_anything",["DepthAnythingForDepthEstimation",bw]],["glpn",["GLPNForDepthEstimation",Lw]],["sapiens",["SapiensForDepthEstimation",Ew]],["depth_pro",["DepthProForDepthEstimation",Cw]],["metric3d",["Metric3DForDepthEstimation",$w]],["metric3dv2",["Metric3Dv2ForDepthEstimation",Aw]]]),ix=new Map([["sapiens",["SapiensForNormalEstimation",Pw]]]),ox=new Map([["vitpose",["VitPoseForPoseEstimation",Pv]]]),ax=new Map([["clip",["CLIPVisionModelWithProjection",Gc]],["siglip",["SiglipVisionModel",Ol]],["jina_clip",["JinaCLIPVisionModel",Ll]]]),lx=[[FF,M.EncoderOnly],[LF,M.EncoderDecoder],[RF,M.DecoderOnly],[zF,M.AutoEncoder],[NM,M.EncoderOnly],[jM,M.EncoderOnly],[Oh,M.Seq2Seq],[Dh,M.Seq2Seq],[Fh,M.DecoderOnly],[BF,M.MultiModality],[VM,M.EncoderOnly],[UM,M.EncoderOnly],[Lh,M.Vision2Seq],[WM,M.ImageTextToText],[GM,M.AudioTextToText],[HM,M.EncoderOnly],[Aa,M.EncoderOnly],[XM,M.EncoderOnly],[QM,M.EncoderOnly],[nx,M.EncoderOnly],[jF,M.EncoderOnly],[rx,M.EncoderOnly],[sx,M.EncoderOnly],[ix,M.EncoderOnly],[ox,M.EncoderOnly],[KM,M.EncoderOnly],[qM,M.EncoderOnly],[YM,M.MaskGeneration],[JM,M.EncoderOnly],[ZM,M.EncoderOnly],[RM,M.Seq2Seq],[BM,M.EncoderOnly],[ex,M.EncoderOnly],[tx,M.EncoderOnly],[ax,M.EncoderOnly]];for(const[E,k]of lx)for(const[z,ae]of E.values())x.set(z,k),T.set(ae,z),b.set(z,ae);const VF=[["MusicgenForConditionalGeneration",$h,M.Musicgen],["Phi3VForCausalLM",Al,M.Phi3V],["CLIPTextModelWithProjection",Wc,M.EncoderOnly],["SiglipTextModel",Pi,M.EncoderOnly],["JinaCLIPTextModel",Fl,M.EncoderOnly],["ClapTextModelWithProjection",G1,M.EncoderOnly],["ClapAudioModelWithProjection",H1,M.EncoderOnly],["DacEncoderModel",DM,M.EncoderOnly],["DacDecoderModel",OM,M.EncoderOnly],["MimiEncoderModel",CM,M.EncoderOnly],["MimiDecoderModel",kM,M.EncoderOnly],["SnacEncoderModel",LM,M.EncoderOnly],["SnacDecoderModel",zM,M.EncoderOnly]];for(const[E,k,z]of VF)x.set(E,z),T.set(k,E),b.set(E,k);const ux=new Map([["modnet",Aa],["birefnet",Aa],["isnet",Aa],["ben",Aa]]);for(const[E,k]of ux.entries())k.set(E,["PreTrainedModel",j]),x.set(E,M.EncoderOnly),T.set(j,E),b.set(E,j);class zh extends zt{}ie(zh,"MODEL_CLASS_MAPPINGS",lx.map(k=>k[0])),ie(zh,"BASE_IF_FAIL",!0);class cx extends zt{}ie(cx,"MODEL_CLASS_MAPPINGS",[NM]);class dx extends zt{}ie(dx,"MODEL_CLASS_MAPPINGS",[jM]);class px extends zt{}ie(px,"MODEL_CLASS_MAPPINGS",[Oh]);class fx extends zt{}ie(fx,"MODEL_CLASS_MAPPINGS",[Dh]);class hx extends zt{}ie(hx,"MODEL_CLASS_MAPPINGS",[RM]);class mx extends zt{}ie(mx,"MODEL_CLASS_MAPPINGS",[BM]);class _x extends zt{}ie(_x,"MODEL_CLASS_MAPPINGS",[Fh]);class gx extends zt{}ie(gx,"MODEL_CLASS_MAPPINGS",[VM]);class yx extends zt{}ie(yx,"MODEL_CLASS_MAPPINGS",[UM]);class vx extends zt{}ie(vx,"MODEL_CLASS_MAPPINGS",[Lh]);class wx extends zt{}ie(wx,"MODEL_CLASS_MAPPINGS",[HM]);class Mx extends zt{}ie(Mx,"MODEL_CLASS_MAPPINGS",[Aa]);class xx extends zt{}ie(xx,"MODEL_CLASS_MAPPINGS",[QM]);class bx extends zt{}ie(bx,"MODEL_CLASS_MAPPINGS",[XM]);class Tx extends zt{}ie(Tx,"MODEL_CLASS_MAPPINGS",[KM]);class Ex extends zt{}ie(Ex,"MODEL_CLASS_MAPPINGS",[qM]);class Px extends zt{}ie(Px,"MODEL_CLASS_MAPPINGS",[YM]);class Sx extends zt{}ie(Sx,"MODEL_CLASS_MAPPINGS",[JM]);class Cx extends zt{}ie(Cx,"MODEL_CLASS_MAPPINGS",[ZM]);class kx extends zt{}ie(kx,"MODEL_CLASS_MAPPINGS",[ex]);class $x extends zt{}ie($x,"MODEL_CLASS_MAPPINGS",[tx]);class Ix extends zt{}ie(Ix,"MODEL_CLASS_MAPPINGS",[NF]);class Ax extends zt{}ie(Ax,"MODEL_CLASS_MAPPINGS",[nx]);class Dx extends zt{}ie(Dx,"MODEL_CLASS_MAPPINGS",[rx]);class Ox extends zt{}ie(Ox,"MODEL_CLASS_MAPPINGS",[sx]);class Fx extends zt{}ie(Fx,"MODEL_CLASS_MAPPINGS",[ix]);class Lx extends zt{}ie(Lx,"MODEL_CLASS_MAPPINGS",[ox]);class zx extends zt{}ie(zx,"MODEL_CLASS_MAPPINGS",[ax]);class Rx extends zt{}ie(Rx,"MODEL_CLASS_MAPPINGS",[WM]);class Bx extends zt{}ie(Bx,"MODEL_CLASS_MAPPINGS",[GM]);class UF extends he{constructor({logits:k,past_key_values:z,encoder_outputs:ae,decoder_attentions:ge=null,cross_attentions:_e=null}){super(),this.logits=k,this.past_key_values=z,this.encoder_outputs=ae,this.decoder_attentions=ge,this.cross_attentions=_e}}class Mt extends he{constructor({logits:k,...z}){super(),this.logits=k;const ae=Object.values(z);ae.length>0&&(this.attentions=ae)}}class Nx extends he{constructor({logits:k,embeddings:z}){super(),this.logits=k,this.embeddings=z}}class Un extends he{constructor({logits:k}){super(),this.logits=k}}class Yn extends he{constructor({logits:k}){super(),this.logits=k}}class ur extends he{constructor({start_logits:k,end_logits:z}){super(),this.start_logits=k,this.end_logits=z}}class $o extends he{constructor({logits:k}){super(),this.logits=k}}class WF extends he{constructor({logits:k,past_key_values:z}){super(),this.logits=k,this.past_key_values=z}}class jx extends he{constructor({alphas:k}){super(),this.alphas=k}}class Vx extends he{constructor({waveform:k,spectrogram:z}){super(),this.waveform=k,this.spectrogram=z}}},"./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js":(e,t,n)=>{n.r(t),n.d(t,{ASTFeatureExtractor:()=>i});var r=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var s=n("./src/utils/audio.js");class i extends r.FeatureExtractor{constructor(a){super(a);const l=this.config.sampling_rate,u=(0,s.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(l/2),l,null,"kaldi",!0);this.mel_filters=u,this.window=(0,s.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(a,l){return(0,s.spectrogram)(a,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:l,transpose:!0})}async _call(a){(0,r.validate_audio_inputs)(a,"ASTFeatureExtractor");const l=await this._extract_fbank_features(a,this.config.max_length);if(this.config.do_normalize){const u=this.std*2,p=l.data;for(let c=0;c<p.length;++c)p[c]=(p[c]-this.mean)/u}return{input_values:l.unsqueeze_(0)}}}},"./src/models/auto/feature_extraction_auto.js":(e,t,n)=>{n.r(t),n.d(t,{AutoFeatureExtractor:()=>o});var r=n("./src/utils/constants.js"),s=n("./src/utils/hub.js");n("./src/base/feature_extraction_utils.js");var i=n("./src/models/feature_extractors.js");class o{static async from_pretrained(l,u={}){const p=await(0,s.getModelJSON)(l,r.FEATURE_EXTRACTOR_NAME,!0,u),c=p.feature_extractor_type,d=i[c];if(!d)throw new Error(`Unknown feature_extractor_type: '${c}'. Please report this at ${r.GITHUB_ISSUE_URL}.`);return new d(p)}}},"./src/models/auto/image_processing_auto.js":(e,t,n)=>{n.r(t),n.d(t,{AutoImageProcessor:()=>a});var r=n("./src/utils/constants.js"),s=n("./src/utils/hub.js"),i=n("./src/base/image_processors_utils.js"),o=n("./src/models/image_processors.js");class a{static async from_pretrained(u,p={}){const c=await(0,s.getModelJSON)(u,r.IMAGE_PROCESSOR_NAME,!0,p),d=c.image_processor_type??c.feature_extractor_type;let f=o[d];return f||(d!==void 0&&console.warn(`Image processor type '${d}' not found, assuming base ImageProcessor. Please report this at ${r.GITHUB_ISSUE_URL}.`),f=i.ImageProcessor),new f(c)}}},"./src/models/auto/processing_auto.js":(e,t,n)=>{n.r(t),n.d(t,{AutoProcessor:()=>u});var r=n("./src/utils/constants.js"),s=n("./src/utils/hub.js"),i=n("./src/base/processing_utils.js"),o=n("./src/models/processors.js"),a=n("./src/models/image_processors.js"),l=n("./src/models/feature_extractors.js");class u{static async from_pretrained(c,d={}){const f=await(0,s.getModelJSON)(c,r.IMAGE_PROCESSOR_NAME,!0,d),{image_processor_type:m,feature_extractor_type:y,processor_class:C}=f;if(C&&o[C])return o[C].from_pretrained(c,d);if(!m&&!y)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const _={};if(m){const w=a[m];if(!w)throw new Error(`Unknown image_processor_type: '${m}'.`);_.image_processor=new w(f)}if(y){const w=a[y];if(w)_.image_processor=new w(f);else{const M=l[y];if(!M)throw new Error(`Unknown feature_extractor_type: '${y}'.`);_.feature_extractor=new M(f)}}const h={};return new i.Processor(h,_)}}},"./src/models/beit/image_processing_beit.js":(e,t,n)=>{n.r(t),n.d(t,{BeitFeatureExtractor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/bit/image_processing_bit.js":(e,t,n)=>{n.r(t),n.d(t,{BitImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/chinese_clip/image_processing_chinese_clip.js":(e,t,n)=>{n.r(t),n.d(t,{ChineseCLIPFeatureExtractor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/clap/feature_extraction_clap.js":(e,t,n)=>{n.r(t),n.d(t,{ClapFeatureExtractor:()=>i});var r=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var s=n("./src/utils/audio.js");class i extends r.FeatureExtractor{constructor(a){super(a),this.mel_filters=(0,s.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,s.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,s.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(a,l,u,p){let c;const d=a.length-l;if(d>0)if(u==="rand_trunc"){const f=Math.floor(Math.random()*(d+1));a=a.subarray(f,f+l),c=await this._extract_fbank_features(a,this.mel_filters_slaney,this.config.nb_max_samples)}else throw new Error(`Truncation strategy "${u}" not implemented`);else{if(d<0){let f=new Float64Array(l);if(f.set(a),p==="repeat")for(let m=a.length;m<l;m+=a.length)f.set(a.subarray(0,Math.min(a.length,l-m)),m);else if(p==="repeatpad")for(let m=a.length;m<-d;m+=a.length)f.set(a,m);a=f}if(u==="fusion")throw new Error(`Truncation strategy "${u}" not implemented`);c=await this._extract_fbank_features(a,this.mel_filters_slaney,this.config.nb_max_samples)}return c.unsqueeze_(0)}async _extract_fbank_features(a,l,u=null){return(0,s.spectrogram)(a,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:l,log_mel:"dB",max_num_frames:u,do_pad:!1,transpose:!0})}async _call(a,{max_length:l=null}={}){return(0,r.validate_audio_inputs)(a,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(a,l??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}},"./src/models/clip/image_processing_clip.js":(e,t,n)=>{n.r(t),n.d(t,{CLIPFeatureExtractor:()=>i,CLIPImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class i extends s{}},"./src/models/convnext/image_processing_convnext.js":(e,t,n)=>{n.r(t),n.d(t,{ConvNextFeatureExtractor:()=>i,ConvNextImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{constructor(a){super(a),this.crop_pct=this.config.crop_pct??224/256}async resize(a){var u;const l=(u=this.size)==null?void 0:u.shortest_edge;if(l===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(l<384){const p=Math.floor(l/this.crop_pct),[c,d]=this.get_resize_output_image_size(a,{shortest_edge:p});a=await a.resize(c,d,{resample:this.resample}),a=await a.center_crop(l,l)}else a=await a.resize(l,l,{resample:this.resample});return a}}class i extends s{}},"./src/models/dac/feature_extraction_dac.js":(e,t,n)=>{n.r(t),n.d(t,{DacFeatureExtractor:()=>s});var r=n("./src/models/encodec/feature_extraction_encodec.js");class s extends r.EncodecFeatureExtractor{}},"./src/models/deit/image_processing_deit.js":(e,t,n)=>{n.r(t),n.d(t,{DeiTFeatureExtractor:()=>i,DeiTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class i extends s{}},"./src/models/detr/image_processing_detr.js":(e,t,n)=>{n.r(t),n.d(t,{DetrFeatureExtractor:()=>o,DetrImageProcessor:()=>i});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class i extends r.ImageProcessor{async _call(l){const u=await super._call(l),p=[u.pixel_values.dims[0],64,64],c=(0,s.full)(p,1n);return{...u,pixel_mask:c}}post_process_object_detection(...l){return(0,r.post_process_object_detection)(...l)}post_process_panoptic_segmentation(...l){return(0,r.post_process_panoptic_segmentation)(...l)}post_process_instance_segmentation(...l){return(0,r.post_process_instance_segmentation)(...l)}}class o extends i{}},"./src/models/donut/image_processing_donut.js":(e,t,n)=>{n.r(t),n.d(t,{DonutFeatureExtractor:()=>i,DonutImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{pad_image(a,l,u,p={}){const[c,d,f]=l;let m=this.image_mean;Array.isArray(this.image_mean)||(m=new Array(f).fill(m));let y=this.image_std;Array.isArray(y)||(y=new Array(f).fill(m));const C=m.map((_,h)=>-_/y[h]);return super.pad_image(a,l,u,{center:!0,constant_values:C,...p})}}class i extends s{}},"./src/models/dpt/image_processing_dpt.js":(e,t,n)=>{n.r(t),n.d(t,{DPTFeatureExtractor:()=>i,DPTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class i extends s{}},"./src/models/efficientnet/image_processing_efficientnet.js":(e,t,n)=>{n.r(t),n.d(t,{EfficientNetImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{constructor(o){super(o),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(a=>a*a))}}},"./src/models/encodec/feature_extraction_encodec.js":(e,t,n)=>{n.r(t),n.d(t,{EncodecFeatureExtractor:()=>i});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js");class i extends r.FeatureExtractor{async _call(a){(0,r.validate_audio_inputs)(a,"EncodecFeatureExtractor"),a instanceof Float64Array&&(a=new Float32Array(a));const l=this.config.feature_size;if(a.length%l!==0)throw new Error(`The length of the audio data must be a multiple of the number of channels (${l}).`);const u=[1,l,a.length/l];return{input_values:new s.Tensor("float32",a,u)}}}},"./src/models/feature_extractors.js":(e,t,n)=>{n.r(t),n.d(t,{ASTFeatureExtractor:()=>r.ASTFeatureExtractor,ClapFeatureExtractor:()=>i.ClapFeatureExtractor,DacFeatureExtractor:()=>o.DacFeatureExtractor,EncodecFeatureExtractor:()=>s.EncodecFeatureExtractor,ImageFeatureExtractor:()=>y.ImageProcessor,MoonshineFeatureExtractor:()=>a.MoonshineFeatureExtractor,PyAnnoteFeatureExtractor:()=>l.PyAnnoteFeatureExtractor,SeamlessM4TFeatureExtractor:()=>u.SeamlessM4TFeatureExtractor,SnacFeatureExtractor:()=>p.SnacFeatureExtractor,SpeechT5FeatureExtractor:()=>c.SpeechT5FeatureExtractor,Wav2Vec2FeatureExtractor:()=>d.Wav2Vec2FeatureExtractor,WeSpeakerFeatureExtractor:()=>f.WeSpeakerFeatureExtractor,WhisperFeatureExtractor:()=>m.WhisperFeatureExtractor});var r=n("./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js"),s=n("./src/models/encodec/feature_extraction_encodec.js"),i=n("./src/models/clap/feature_extraction_clap.js"),o=n("./src/models/dac/feature_extraction_dac.js"),a=n("./src/models/moonshine/feature_extraction_moonshine.js"),l=n("./src/models/pyannote/feature_extraction_pyannote.js"),u=n("./src/models/seamless_m4t/feature_extraction_seamless_m4t.js"),p=n("./src/models/snac/feature_extraction_snac.js"),c=n("./src/models/speecht5/feature_extraction_speecht5.js"),d=n("./src/models/wav2vec2/feature_extraction_wav2vec2.js"),f=n("./src/models/wespeaker/feature_extraction_wespeaker.js"),m=n("./src/models/whisper/feature_extraction_whisper.js"),y=n("./src/base/image_processors_utils.js")},"./src/models/florence2/processing_florence2.js":(e,t,n)=>{n.r(t),n.d(t,{Florence2Processor:()=>o});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),i=n("./src/tokenizers.js");class o extends r.Processor{constructor(l,u){super(l,u);const{tasks_answer_post_processing_type:p,task_prompts_without_inputs:c,task_prompts_with_input:d}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(p??{})),this.task_prompts_without_inputs=new Map(Object.entries(c??{})),this.task_prompts_with_input=new Map(Object.entries(d??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(l){typeof l=="string"&&(l=[l]);const u=[];for(const p of l)if(this.task_prompts_without_inputs.has(p))u.push(this.task_prompts_without_inputs.get(p));else{for(const[c,d]of this.task_prompts_with_input)if(p.includes(c)){u.push(d.replaceAll("{input}",p).replaceAll(c,""));break}u.length!==l.length&&u.push(p)}return u}post_process_generation(l,u,p){const c=this.tasks_answer_post_processing_type.get(u)??"pure_text";l=l.replaceAll("<s>","").replaceAll("</s>","");let d;switch(c){case"pure_text":d=l;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const f=c==="ocr"?"quad_boxes":"bboxes",m=l.matchAll(this.regexes[f]),y=[],C=[];for(const[_,h,...w]of m)y.push(h?h.trim():y.at(-1)??""),C.push(w.map((M,x)=>(Number(M)+.5)/this.size_per_bin*p[x%2]));d={labels:y,[f]:C};break;default:throw new Error(`Task "${u}" (of type "${c}") not yet implemented.`)}return{[u]:d}}async _call(l,u=null,p={}){if(!l&&!u)throw new Error("Either text or images must be provided");const c=await this.image_processor(l,p),d=u?this.tokenizer(u,p):{};return{...c,...d}}}ie(o,"tokenizer_class",i.AutoTokenizer),ie(o,"image_processor_class",s.AutoImageProcessor)},"./src/models/glpn/image_processing_glpn.js":(e,t,n)=>{n.r(t),n.d(t,{GLPNFeatureExtractor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/grounding_dino/image_processing_grounding_dino.js":(e,t,n)=>{n.r(t),n.d(t,{GroundingDinoImageProcessor:()=>i});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class i extends r.ImageProcessor{async _call(a){const l=await super._call(a),u=l.pixel_values.dims,p=(0,s.ones)([u[0],u[2],u[3]]);return{...l,pixel_mask:p}}}},"./src/models/grounding_dino/processing_grounding_dino.js":(e,t,n)=>{n.r(t),n.d(t,{GroundingDinoProcessor:()=>l});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),i=n("./src/tokenizers.js"),o=n("./src/base/image_processors_utils.js");function a(u,p){const d=u.dims.at(-1)-1,f=u.tolist();f.fill(!1,0,1),f.fill(!1,d);const m=p.tolist();return f.map((y,C)=>y?C:null).filter(y=>y!==null).map(y=>m[y])}class l extends r.Processor{async _call(p,c,d={}){const f=p?await this.image_processor(p,d):{};return{...c?this.tokenizer(c,d):{},...f}}post_process_grounded_object_detection(p,c,{box_threshold:d=.25,text_threshold:f=.25,target_sizes:m=null}={}){const{logits:y,pred_boxes:C}=p,_=y.dims[0];if(m!==null&&m.length!==_)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const h=y.dims.at(1),w=y.sigmoid(),M=w.max(-1).tolist(),x=C.tolist().map(T=>T.map(S=>(0,o.center_to_corners_format)(S))),b=[];for(let T=0;T<_;++T){const S=m!==null?m[T]:null;S!==null&&(x[T]=x[T].map(N=>N.map((J,q)=>J*S[(q+1)%2])));const $=M[T],O=[],G=[],H=[];for(let N=0;N<h;++N){const J=$[N];if(J<=d)continue;const q=x[T][N],X=w[T][N];O.push(J),H.push(q);const Y=a(X.gt(f),c[T]);G.push(Y)}b.push({scores:O,boxes:H,labels:this.batch_decode(G)})}return b}}ie(l,"tokenizer_class",i.AutoTokenizer),ie(l,"image_processor_class",s.AutoImageProcessor)},"./src/models/idefics3/image_processing_idefics3.js":(e,t,n)=>{n.r(t),n.d(t,{Idefics3ImageProcessor:()=>i});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class i extends r.ImageProcessor{constructor(a){super(a),this.do_image_splitting=a.do_image_splitting??!0,this.max_image_size=a.max_image_size}get_resize_for_vision_encoder(a,l){let[u,p]=a.dims.slice(-2);const c=p/u;return p>=u?(p=Math.ceil(p/l)*l,u=Math.floor(p/c),u=Math.ceil(u/l)*l):(u=Math.ceil(u/l)*l,p=Math.floor(u*c),p=Math.ceil(p/l)*l),{height:u,width:p}}async _call(a,{do_image_splitting:l=null,return_row_col_info:u=!1}={}){let p;if(!Array.isArray(a))p=[[a]];else{if(a.length===0||!a[0])throw new Error("No images provided.");Array.isArray(a[0])?p=a:p=[a]}let c=[],d=[],f=[];const m=[],y=[];for(const T of p){let S=await Promise.all(T.map(G=>this.preprocess(G)));m.push(...S.map(G=>G.original_size)),y.push(...S.map(G=>G.reshaped_input_size)),S.forEach(G=>G.pixel_values.unsqueeze_(0));const{longest_edge:$}=this.max_image_size;let O;if(l??this.do_image_splitting){let G=new Array(S.length),H=new Array(S.length);O=await Promise.all(S.map(async(N,J)=>{const q=this.get_resize_for_vision_encoder(N.pixel_values,$),X=await(0,s.interpolate_4d)(N.pixel_values,{size:[q.height,q.width]}),{frames:Y,num_splits_h:K,num_splits_w:oe}=await this.split_image(X,this.max_image_size);return G[J]=K,H[J]=oe,(0,s.cat)(Y,0)})),d.push(G),f.push(H)}else{const G=[$,$];O=await Promise.all(S.map(H=>(0,s.interpolate_4d)(H.pixel_values,{size:G}))),d.push(new Array(S.length).fill(0)),f.push(new Array(S.length).fill(0))}c.push((0,s.cat)(O,0))}const C=c.length,[_,h,w,M]=c[0].dims;let x,b;if(C===1)x=c[0].unsqueeze_(0),b=(0,s.full)([C,_,w,M],!0);else{const T=Math.max(...c.map(O=>O.dims.at(0)));b=(0,s.full)([C,T,w,M],!0);const S=b.data,$=T*w*M;for(let O=0;O<C;++O){const G=c[O].dims[0];if(G<T){c[O]=(0,s.cat)([c[O],(0,s.full)([T-G,h,w,M],0)],0);const H=O*$+G*w*M,N=(O+1)*$;S.fill(!1,H,N)}}x=(0,s.stack)(c,0)}return{pixel_values:x,pixel_attention_mask:b,original_sizes:m,reshaped_input_sizes:y,...u?{rows:d,cols:f}:{}}}async split_image(a,{longest_edge:l}){const u=l,p=l,c=[],[d,f]=a.dims.slice(-2);let m=0,y=0;if(d>u||f>p){m=Math.ceil(d/u),y=Math.ceil(f/p);const C=Math.ceil(d/m),_=Math.ceil(f/y);for(let M=0;M<m;++M)for(let x=0;x<y;++x){let b,T,S,$;M===m-1?(T=d-C,$=d):(T=M*C,$=(M+1)*C),x===y-1?(b=f-_,S=f):(b=x*_,S=(x+1)*_);const O=[T,b],G=[$,S],H=await(0,s.slice)(a,O,G,[2,3]);c.push(H)}const h=u,w=p;(d!==h||f!==w)&&(a=await(0,s.interpolate_4d)(a,{size:[h,w]}))}return c.push(a),{frames:c,num_splits_h:m,num_splits_w:y}}}},"./src/models/idefics3/processing_idefics3.js":(e,t,n)=>{n.r(t),n.d(t,{Idefics3Processor:()=>p});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),i=n("./src/tokenizers.js");n("./src/utils/image.js");var o=n("./src/utils/core.js");function a(c,d,f,m,y,C){let _="";for(let h=0;h<d;++h){for(let w=0;w<f;++w)_+=m+`<row_${h+1}_col_${w+1}>`+y.repeat(c);_+=`
`}return _+=`
${m}${C}`+y.repeat(c)+`${m}`,_}function l(c,d,f,m){return`${d}${m}`+f.repeat(c)+`${d}`}function u(c,d,f,m,y,C){return c===0&&d===0?l(f,m,y,C):a(f,c,d,m,y,C)}class p extends r.Processor{constructor(){super(...arguments);ie(this,"fake_image_token","<fake_token_around_image>");ie(this,"image_token","<image>");ie(this,"global_img_token","<global-img>")}async _call(f,m=null,y={}){y.return_row_col_info??(y.return_row_col_info=!0);let C;m&&(C=await this.image_processor(m,y)),Array.isArray(f)||(f=[f]);const _=C.rows??[new Array(f.length).fill(0)],h=C.cols??[new Array(f.length).fill(0)],w=this.config.image_seq_len,M=[],x=[];for(let T=0;T<f.length;++T){const S=f[T],$=_[T],O=h[T];M.push((0,o.count)(S,this.image_token));const G=$.map((J,q)=>u(J,O[q],w,this.fake_image_token,this.image_token,this.global_img_token)),H=S.split(this.image_token);if(H.length===0)throw new Error("The image token should be present in the text.");let N=H[0];for(let J=0;J<G.length;++J)N+=G[J]+H[J+1];x.push(N)}return{...this.tokenizer(x),...C}}}ie(p,"image_processor_class",s.AutoImageProcessor),ie(p,"tokenizer_class",i.AutoTokenizer),ie(p,"uses_processor_config",!0)},"./src/models/image_processors.js":(e,t,n)=>{n.r(t),n.d(t,{BeitFeatureExtractor:()=>r.BeitFeatureExtractor,BitImageProcessor:()=>s.BitImageProcessor,CLIPFeatureExtractor:()=>o.CLIPFeatureExtractor,CLIPImageProcessor:()=>o.CLIPImageProcessor,ChineseCLIPFeatureExtractor:()=>i.ChineseCLIPFeatureExtractor,ConvNextFeatureExtractor:()=>a.ConvNextFeatureExtractor,ConvNextImageProcessor:()=>a.ConvNextImageProcessor,DPTFeatureExtractor:()=>c.DPTFeatureExtractor,DPTImageProcessor:()=>c.DPTImageProcessor,DeiTFeatureExtractor:()=>l.DeiTFeatureExtractor,DeiTImageProcessor:()=>l.DeiTImageProcessor,DetrFeatureExtractor:()=>u.DetrFeatureExtractor,DetrImageProcessor:()=>u.DetrImageProcessor,DonutFeatureExtractor:()=>p.DonutFeatureExtractor,DonutImageProcessor:()=>p.DonutImageProcessor,EfficientNetImageProcessor:()=>d.EfficientNetImageProcessor,GLPNFeatureExtractor:()=>f.GLPNFeatureExtractor,GroundingDinoImageProcessor:()=>m.GroundingDinoImageProcessor,Idefics3ImageProcessor:()=>y.Idefics3ImageProcessor,JinaCLIPImageProcessor:()=>_.JinaCLIPImageProcessor,LlavaOnevisionImageProcessor:()=>h.LlavaOnevisionImageProcessor,Mask2FormerImageProcessor:()=>w.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>M.MaskFormerFeatureExtractor,MaskFormerImageProcessor:()=>M.MaskFormerImageProcessor,MobileNetV1FeatureExtractor:()=>x.MobileNetV1FeatureExtractor,MobileNetV1ImageProcessor:()=>x.MobileNetV1ImageProcessor,MobileNetV2FeatureExtractor:()=>b.MobileNetV2FeatureExtractor,MobileNetV2ImageProcessor:()=>b.MobileNetV2ImageProcessor,MobileNetV3FeatureExtractor:()=>T.MobileNetV3FeatureExtractor,MobileNetV3ImageProcessor:()=>T.MobileNetV3ImageProcessor,MobileNetV4FeatureExtractor:()=>S.MobileNetV4FeatureExtractor,MobileNetV4ImageProcessor:()=>S.MobileNetV4ImageProcessor,MobileViTFeatureExtractor:()=>$.MobileViTFeatureExtractor,MobileViTImageProcessor:()=>$.MobileViTImageProcessor,NougatImageProcessor:()=>O.NougatImageProcessor,OwlViTFeatureExtractor:()=>H.OwlViTFeatureExtractor,OwlViTImageProcessor:()=>H.OwlViTImageProcessor,Owlv2ImageProcessor:()=>G.Owlv2ImageProcessor,Phi3VImageProcessor:()=>N.Phi3VImageProcessor,PvtImageProcessor:()=>J.PvtImageProcessor,Qwen2VLImageProcessor:()=>q.Qwen2VLImageProcessor,RTDetrImageProcessor:()=>X.RTDetrImageProcessor,SamImageProcessor:()=>Y.SamImageProcessor,SegformerFeatureExtractor:()=>K.SegformerFeatureExtractor,SegformerImageProcessor:()=>K.SegformerImageProcessor,SiglipImageProcessor:()=>oe.SiglipImageProcessor,SmolVLMImageProcessor:()=>se.SmolVLMImageProcessor,Swin2SRImageProcessor:()=>F.Swin2SRImageProcessor,VLMImageProcessor:()=>C.VLMImageProcessor,ViTFeatureExtractor:()=>I.ViTFeatureExtractor,ViTImageProcessor:()=>I.ViTImageProcessor,VitMatteImageProcessor:()=>V.VitMatteImageProcessor,VitPoseImageProcessor:()=>ee.VitPoseImageProcessor,YolosFeatureExtractor:()=>pe.YolosFeatureExtractor,YolosImageProcessor:()=>pe.YolosImageProcessor});var r=n("./src/models/beit/image_processing_beit.js"),s=n("./src/models/bit/image_processing_bit.js"),i=n("./src/models/chinese_clip/image_processing_chinese_clip.js"),o=n("./src/models/clip/image_processing_clip.js"),a=n("./src/models/convnext/image_processing_convnext.js"),l=n("./src/models/deit/image_processing_deit.js"),u=n("./src/models/detr/image_processing_detr.js"),p=n("./src/models/donut/image_processing_donut.js"),c=n("./src/models/dpt/image_processing_dpt.js"),d=n("./src/models/efficientnet/image_processing_efficientnet.js"),f=n("./src/models/glpn/image_processing_glpn.js"),m=n("./src/models/grounding_dino/image_processing_grounding_dino.js"),y=n("./src/models/idefics3/image_processing_idefics3.js"),C=n("./src/models/janus/image_processing_janus.js"),_=n("./src/models/jina_clip/image_processing_jina_clip.js"),h=n("./src/models/llava_onevision/image_processing_llava_onevision.js"),w=n("./src/models/mask2former/image_processing_mask2former.js"),M=n("./src/models/maskformer/image_processing_maskformer.js"),x=n("./src/models/mobilenet_v1/image_processing_mobilenet_v1.js"),b=n("./src/models/mobilenet_v2/image_processing_mobilenet_v2.js"),T=n("./src/models/mobilenet_v3/image_processing_mobilenet_v3.js"),S=n("./src/models/mobilenet_v4/image_processing_mobilenet_v4.js"),$=n("./src/models/mobilevit/image_processing_mobilevit.js"),O=n("./src/models/nougat/image_processing_nougat.js"),G=n("./src/models/owlv2/image_processing_owlv2.js"),H=n("./src/models/owlvit/image_processing_owlvit.js"),N=n("./src/models/phi3_v/image_processing_phi3_v.js"),J=n("./src/models/pvt/image_processing_pvt.js"),q=n("./src/models/qwen2_vl/image_processing_qwen2_vl.js"),X=n("./src/models/rt_detr/image_processing_rt_detr.js"),Y=n("./src/models/sam/image_processing_sam.js"),K=n("./src/models/segformer/image_processing_segformer.js"),oe=n("./src/models/siglip/image_processing_siglip.js"),se=n("./src/models/smolvlm/image_processing_smolvlm.js"),F=n("./src/models/swin2sr/image_processing_swin2sr.js"),I=n("./src/models/vit/image_processing_vit.js"),V=n("./src/models/vitmatte/image_processing_vitmatte.js"),ee=n("./src/models/vitpose/image_processing_vitpose.js"),pe=n("./src/models/yolos/image_processing_yolos.js")},"./src/models/janus/image_processing_janus.js":(e,t,n)=>{n.r(t),n.d(t,{VLMImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{constructor(o){super({do_pad:!0,pad_size:{width:o.image_size,height:o.image_size},...o}),this.constant_values=this.config.background_color.map(a=>a*this.rescale_factor)}pad_image(o,a,l,u){return super.pad_image(o,a,l,{constant_values:this.constant_values,center:!0,...u})}}},"./src/models/janus/processing_janus.js":(e,t,n)=>{n.r(t),n.d(t,{VLChatProcessor:()=>u});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),i=n("./src/tokenizers.js"),o=n("./src/utils/core.js"),a=n("./src/utils/tensor.js"),l=n("./src/utils/image.js");class u extends r.Processor{constructor(c,d){super(c,d),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(c,{images:d=null,chat_template:f="default"}={}){d?Array.isArray(d)||(d=[d]):d=await Promise.all(c.filter(O=>O.images).flatMap(O=>O.images).map(O=>l.RawImage.read(O)));const m=this.tokenizer,y=m.apply_chat_template(c,{tokenize:!1,add_generation_prompt:!0,chat_template:f}),C=O=>m.encode(O,{add_special_tokens:!1}),_=y.split(this.image_tag),h=_.length-1;if(d.length!==h)throw new Error(`Number of images provided (${d.length}) does not match number of "${this.image_tag}" image tags (${h})`);const[w,M,x]=m.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let b=C(_[0]),T=new Array(b.length).fill(!1);for(let O=1;O<_.length;++O){const G=new Array(this.num_image_tokens).fill(w),H=C(_[O]);b=(0,o.mergeArrays)(b,[M],G,[x],H);const N=new Array(this.num_image_tokens).fill(!0);T=(0,o.mergeArrays)(T,[!1],N,[!1],new Array(H.length).fill(!1))}const S=[1,b.length],$={input_ids:new a.Tensor("int64",b,S),attention_mask:new a.Tensor("int64",new Array(b.length).fill(1),S),images_seq_mask:new a.Tensor("bool",T,S),images_emb_mask:new a.Tensor("bool",new Array(h*this.num_image_tokens).fill(!0),[1,h,this.num_image_tokens])};if(d&&d.length>0){const O=await this.image_processor(d);return O.pixel_values.unsqueeze_(0),{...$,...O}}return $}}ie(u,"image_processor_class",s.AutoImageProcessor),ie(u,"tokenizer_class",i.AutoTokenizer),ie(u,"uses_processor_config",!0)},"./src/models/jina_clip/image_processing_jina_clip.js":(e,t,n)=>{n.r(t),n.d(t,{JinaCLIPImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{constructor(o){const{resize_mode:a,fill_color:l,interpolation:u,size:p,...c}=o,d=a==="squash"?{width:p,height:p}:a==="shortest"?{shortest_edge:p}:{longest_edge:p},f=u==="bicubic"?3:2;super({...c,size:d,resample:f,do_center_crop:!0,crop_size:p,do_normalize:!0})}}},"./src/models/jina_clip/processing_jina_clip.js":(e,t,n)=>{n.r(t),n.d(t,{JinaCLIPProcessor:()=>o});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),i=n("./src/tokenizers.js");class o extends r.Processor{async _call(l=null,u=null,p={}){if(!l&&!u)throw new Error("Either text or images must be provided");const c=l?this.tokenizer(l,p):{},d=u?await this.image_processor(u,p):{};return{...c,...d}}}ie(o,"tokenizer_class",i.AutoTokenizer),ie(o,"image_processor_class",s.AutoImageProcessor)},"./src/models/llava_onevision/image_processing_llava_onevision.js":(e,t,n)=>{n.r(t),n.d(t,{LlavaOnevisionImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/mask2former/image_processing_mask2former.js":(e,t,n)=>{n.r(t),n.d(t,{Mask2FormerImageProcessor:()=>s});var r=n("./src/models/maskformer/image_processing_maskformer.js");class s extends r.MaskFormerImageProcessor{}},"./src/models/maskformer/image_processing_maskformer.js":(e,t,n)=>{n.r(t),n.d(t,{MaskFormerFeatureExtractor:()=>i,MaskFormerImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_panoptic_segmentation(...a){return(0,r.post_process_panoptic_segmentation)(...a)}post_process_instance_segmentation(...a){return(0,r.post_process_instance_segmentation)(...a)}}class i extends s{}},"./src/models/mgp_str/processing_mgp_str.js":(e,t,n)=>{n.r(t),n.d(t,{MgpstrProcessor:()=>l});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),i=n("./src/tokenizers.js"),o=n("./src/utils/maths.js");const a={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class l extends r.Processor{get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(p,c){if(!a.hasOwnProperty(c))throw new Error(`Format ${c} is not supported.`);const[d,f]=a[c],m=this[d].bind(this),[y,C]=p.dims,_=[],h=[],w=p.tolist();for(let x=0;x<y;++x){const b=w[x],T=[],S=[];for(let O=1;O<C;++O){const[G,H]=(0,o.max)((0,o.softmax)(b[O]));if(S.push(G),H==f)break;T.push(H)}const $=S.length>0?S.reduce((O,G)=>O*G,1):0;h.push(T),_.push($)}return[m(h),_]}char_decode(p){return this.char_tokenizer.batch_decode(p).map(c=>c.replaceAll(" ",""))}bpe_decode(p){return this.bpe_tokenizer.batch_decode(p)}wp_decode(p){return this.wp_tokenizer.batch_decode(p).map(c=>c.replaceAll(" ",""))}batch_decode([p,c,d]){const[f,m]=this._decode_helper(p,"char"),[y,C]=this._decode_helper(c,"bpe"),[_,h]=this._decode_helper(d,"wp"),w=[],M=[];for(let x=0;x<f.length;++x){const[b,T]=(0,o.max)([m[x],C[x],h[x]]);w.push([f[x],y[x],_[x]][T]),M.push(b)}return{generated_text:w,scores:M,char_preds:f,bpe_preds:y,wp_preds:_}}static async from_pretrained(...p){const c=await super.from_pretrained(...p),d=await i.AutoTokenizer.from_pretrained("Xenova/gpt2"),f=await i.AutoTokenizer.from_pretrained("Xenova/bert-base-uncased");return c.components={image_processor:c.image_processor,char_tokenizer:c.tokenizer,bpe_tokenizer:d,wp_tokenizer:f},c}async _call(p,c=null){const d=await this.image_processor(p);return c&&(d.labels=this.tokenizer(c).input_ids),d}}ie(l,"tokenizer_class",i.AutoTokenizer),ie(l,"image_processor_class",s.AutoImageProcessor)},"./src/models/mobilenet_v1/image_processing_mobilenet_v1.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV1FeatureExtractor:()=>i,MobileNetV1ImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class i extends s{}},"./src/models/mobilenet_v2/image_processing_mobilenet_v2.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV2FeatureExtractor:()=>i,MobileNetV2ImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class i extends s{}},"./src/models/mobilenet_v3/image_processing_mobilenet_v3.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV3FeatureExtractor:()=>i,MobileNetV3ImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class i extends s{}},"./src/models/mobilenet_v4/image_processing_mobilenet_v4.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV4FeatureExtractor:()=>i,MobileNetV4ImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class i extends s{}},"./src/models/mobilevit/image_processing_mobilevit.js":(e,t,n)=>{n.r(t),n.d(t,{MobileViTFeatureExtractor:()=>i,MobileViTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class i extends s{}},"./src/models/moonshine/feature_extraction_moonshine.js":(e,t,n)=>{n.r(t),n.d(t,{MoonshineFeatureExtractor:()=>i});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js");class i extends r.FeatureExtractor{async _call(a){(0,r.validate_audio_inputs)(a,"MoonshineFeatureExtractor"),a instanceof Float64Array&&(a=new Float32Array(a));const l=[1,a.length];return{input_values:new s.Tensor("float32",a,l)}}}},"./src/models/moonshine/processing_moonshine.js":(e,t,n)=>{n.r(t),n.d(t,{MoonshineProcessor:()=>o});var r=n("./src/models/auto/feature_extraction_auto.js"),s=n("./src/tokenizers.js"),i=n("./src/base/processing_utils.js");class o extends i.Processor{async _call(l){return await this.feature_extractor(l)}}ie(o,"tokenizer_class",s.AutoTokenizer),ie(o,"feature_extractor_class",r.AutoFeatureExtractor)},"./src/models/nougat/image_processing_nougat.js":(e,t,n)=>{n.r(t),n.d(t,{NougatImageProcessor:()=>s});var r=n("./src/models/donut/image_processing_donut.js");class s extends r.DonutImageProcessor{}},"./src/models/owlv2/image_processing_owlv2.js":(e,t,n)=>{n.r(t),n.d(t,{Owlv2ImageProcessor:()=>s});var r=n("./src/models/owlvit/image_processing_owlvit.js");class s extends r.OwlViTImageProcessor{}},"./src/models/owlvit/image_processing_owlvit.js":(e,t,n)=>{n.r(t),n.d(t,{OwlViTFeatureExtractor:()=>i,OwlViTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_object_detection(...a){return(0,r.post_process_object_detection)(...a)}}class i extends s{}},"./src/models/owlvit/processing_owlvit.js":(e,t,n)=>{n.r(t),n.d(t,{OwlViTProcessor:()=>o});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),i=n("./src/tokenizers.js");class o extends r.Processor{}ie(o,"tokenizer_class",i.AutoTokenizer),ie(o,"image_processor_class",s.AutoImageProcessor)},"./src/models/paligemma/processing_paligemma.js":(e,t,n)=>{n.r(t),n.d(t,{PaliGemmaProcessor:()=>l});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),i=n("./src/tokenizers.js");const o="<image>";function a(u,p,c,d,f){return`${d.repeat(c*f)}${p}${u}
`}class l extends r.Processor{async _call(p,c=null,d={}){c||(console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model."),c=""),Array.isArray(p)||(p=[p]),Array.isArray(c)||(c=[c]);const f=this.tokenizer.bos_token,m=this.image_processor.config.image_seq_length;let y;c.some(h=>h.includes(o))?y=c.map(h=>{const w=h.replaceAll(o,o.repeat(m)),M=w.lastIndexOf(o),x=M===-1?0:M+o.length;return w.slice(0,x)+f+w.slice(x)+`
`}):(console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special image tokens in the text, as many tokens as there are images per each text. It is recommended to add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images each text has and add special tokens."),y=c.map(h=>a(h,f,m,o,p.length)));const C=this.tokenizer(y,d);return{...await this.image_processor(p,d),...C}}}ie(l,"tokenizer_class",i.AutoTokenizer),ie(l,"image_processor_class",s.AutoImageProcessor),ie(l,"uses_processor_config",!1)},"./src/models/phi3_v/image_processing_phi3_v.js":(e,t,n)=>{n.r(t),n.d(t,{Phi3VImageProcessor:()=>p});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");const i=336,o=[2,3],{ceil:a,floor:l,sqrt:u}=Math;class p extends r.ImageProcessor{constructor(d){super({...d,do_normalize:!0,do_pad:!0,pad_size:"custom",do_convert_rgb:!0,do_resize:!0}),this._num_crops=d.num_crops}calc_num_image_tokens_from_image_size(d,f){const{num_img_tokens:m}=this.config;return l((l(f/i)*l(d/i)+1)*m+1+(l(f/i)+1)*u(m))}get_resize_output_image_size(d,f){const m=this._num_crops,[y,C]=d.size;let _=y/C,h=1;for(;h*Math.ceil(h/_)<=m;)h+=1;h-=1;const w=Math.floor(h*336),M=Math.floor(w/_);return[w,M]}pad_image(d,f,m,y={}){const[C,_]=f,h=i*a(C/i),w=i*a(_/i),M=[1,1,1].map((x,b)=>(x-this.image_mean[b])/this.image_std[b]);return super.pad_image(d,f,{width:w,height:h},{center:!0,constant_values:M,...y})}async _call(d,{num_crops:f=null}={}){if(this._num_crops=f??(f=this.config.num_crops),f<4||u(f)%1!==0)throw new Error("num_crops must be a square number >= 4");Array.isArray(d)||(d=[d]);const m=d.length,y=await Promise.all(d.map(T=>this.preprocess(T))),C=y.map(T=>T.original_size),_=y.map(T=>T.reshaped_input_size),h=[];for(const{pixel_values:T}of y){T.unsqueeze_(0);const[S,$]=T.dims.slice(-2),O=await(0,s.interpolate_4d)(T,{size:[i,i],mode:"bicubic"});if(f>0){const G=[],H=u(f),N=l($/H),J=l(S/H);for(let X=0;X<H;++X)for(let Y=0;Y<H;++Y){let K,oe,se,F;X===H-1?(oe=S-J,F=S):(oe=X*J,F=(X+1)*J),Y===H-1?(K=$-N,se=$):(K=Y*N,se=(Y+1)*N);const I=[oe,K],V=[F,se],ee=await(0,s.slice)(T,I,V,o);G.push(ee)}const q=await(0,s.interpolate_4d)((0,s.cat)(G,0),{size:[i,i],mode:"bicubic"});h.push((0,s.cat)([O,q],0))}else h.push(O)}const w=(0,s.stack)(h,0),M=_.map(T=>T.map(S=>i*a(S/i))),x=new s.Tensor("int64",M.flat(),[m,2]),b=M.map(([T,S])=>this.calc_num_image_tokens_from_image_size(S,T));return{pixel_values:w,original_sizes:C,reshaped_input_sizes:_,image_sizes:x,num_img_tokens:b}}}},"./src/models/phi3_v/processing_phi3_v.js":(e,t,n)=>{n.r(t),n.d(t,{Phi3VProcessor:()=>l});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),i=n("./src/tokenizers.js");n("./src/utils/image.js");const o="<|image|>",a=/<\|image_\d+\|>/g;class l extends r.Processor{async _call(p,c=null,{padding:d=!0,truncation:f=!0,num_crops:m=null}={}){Array.isArray(p)||(p=[p]);let y,C;if(c){C=await this.image_processor(c,{num_crops:m});const{num_img_tokens:_}=C,h=p.map((M,x)=>M.split(a).join(o.repeat(_[x])));y=this.tokenizer(h,{padding:d,truncation:f});const w=this.tokenizer.model.convert_tokens_to_ids([o])[0];y.input_ids.map_(M=>M==w?-M:M)}else y=this.tokenizer(p);return{...y,...C}}}ie(l,"image_processor_class",s.AutoImageProcessor),ie(l,"tokenizer_class",i.AutoTokenizer)},"./src/models/processors.js":(e,t,n)=>{n.r(t),n.d(t,{Florence2Processor:()=>r.Florence2Processor,GroundingDinoProcessor:()=>s.GroundingDinoProcessor,Idefics3Processor:()=>i.Idefics3Processor,JinaCLIPProcessor:()=>a.JinaCLIPProcessor,MgpstrProcessor:()=>l.MgpstrProcessor,MoonshineProcessor:()=>u.MoonshineProcessor,OwlViTProcessor:()=>p.OwlViTProcessor,PaliGemmaProcessor:()=>d.PaliGemmaProcessor,Phi3VProcessor:()=>c.Phi3VProcessor,PyAnnoteProcessor:()=>f.PyAnnoteProcessor,Qwen2VLProcessor:()=>m.Qwen2VLProcessor,SamProcessor:()=>y.SamProcessor,SmolVLMProcessor:()=>C.SmolVLMProcessor,SpeechT5Processor:()=>_.SpeechT5Processor,UltravoxProcessor:()=>h.UltravoxProcessor,VLChatProcessor:()=>o.VLChatProcessor,Wav2Vec2Processor:()=>w.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>M.Wav2Vec2ProcessorWithLM,WhisperProcessor:()=>x.WhisperProcessor});var r=n("./src/models/florence2/processing_florence2.js"),s=n("./src/models/grounding_dino/processing_grounding_dino.js"),i=n("./src/models/idefics3/processing_idefics3.js"),o=n("./src/models/janus/processing_janus.js"),a=n("./src/models/jina_clip/processing_jina_clip.js"),l=n("./src/models/mgp_str/processing_mgp_str.js"),u=n("./src/models/moonshine/processing_moonshine.js"),p=n("./src/models/owlvit/processing_owlvit.js"),c=n("./src/models/phi3_v/processing_phi3_v.js"),d=n("./src/models/paligemma/processing_paligemma.js"),f=n("./src/models/pyannote/processing_pyannote.js"),m=n("./src/models/qwen2_vl/processing_qwen2_vl.js"),y=n("./src/models/sam/processing_sam.js"),C=n("./src/models/smolvlm/processing_smolvlm.js"),_=n("./src/models/speecht5/processing_speecht5.js"),h=n("./src/models/ultravox/processing_ultravox.js"),w=n("./src/models/wav2vec2/processing_wav2vec2.js"),M=n("./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js"),x=n("./src/models/whisper/processing_whisper.js")},"./src/models/pvt/image_processing_pvt.js":(e,t,n)=>{n.r(t),n.d(t,{PvtImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/pyannote/feature_extraction_pyannote.js":(e,t,n)=>{n.r(t),n.d(t,{PyAnnoteFeatureExtractor:()=>o});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js"),i=n("./src/utils/maths.js");class o extends r.FeatureExtractor{async _call(l){(0,r.validate_audio_inputs)(l,"PyAnnoteFeatureExtractor"),l instanceof Float64Array&&(l=new Float32Array(l));const u=[1,1,l.length];return{input_values:new s.Tensor("float32",l,u)}}samples_to_frames(l){return(l-this.config.offset)/this.config.step}post_process_speaker_diarization(l,u){const p=u/this.samples_to_frames(u)/this.config.sampling_rate,c=[];for(const d of l.tolist()){const f=[];let m=-1;for(let y=0;y<d.length;++y){const C=(0,i.softmax)(d[y]),[_,h]=(0,i.max)(C),[w,M]=[y,y+1];h!==m?(m=h,f.push({id:h,start:w,end:M,score:_})):(f.at(-1).end=M,f.at(-1).score+=_)}c.push(f.map(({id:y,start:C,end:_,score:h})=>({id:y,start:C*p,end:_*p,confidence:h/(_-C)})))}return c}}},"./src/models/pyannote/processing_pyannote.js":(e,t,n)=>{n.r(t),n.d(t,{PyAnnoteProcessor:()=>i});var r=n("./src/base/processing_utils.js"),s=n("./src/models/pyannote/feature_extraction_pyannote.js");class i extends r.Processor{async _call(a){return await this.feature_extractor(a)}post_process_speaker_diarization(...a){return this.feature_extractor.post_process_speaker_diarization(...a)}get sampling_rate(){return this.feature_extractor.config.sampling_rate}}ie(i,"feature_extractor_class",s.PyAnnoteFeatureExtractor)},"./src/models/qwen2_vl/image_processing_qwen2_vl.js":(e,t,n)=>{n.r(t),n.d(t,{Qwen2VLImageProcessor:()=>i});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class i extends r.ImageProcessor{async _call(a,...l){const{pixel_values:u,original_sizes:p,reshaped_input_sizes:c}=await super._call(a,...l);let d=u;const{temporal_patch_size:f,merge_size:m,patch_size:y}=this.config;d.dims[0]===1&&(d=(0,s.cat)(Array.from({length:f},()=>d),0));const C=d.dims[0]/f,_=d.dims[1],h=Math.floor(d.dims[2]/y),w=Math.floor(d.dims[3]/y),M=d.view(C,f,_,Math.floor(h/m),m,y,Math.floor(w/m),m,y).permute(0,3,6,4,7,2,1,5,8).view(C*h*w,_*f*y*y),x=new s.Tensor("int64",[C,h,w],[1,3]);return{pixel_values:M,image_grid_thw:x,original_sizes:p,reshaped_input_sizes:c}}}},"./src/models/qwen2_vl/processing_qwen2_vl.js":(e,t,n)=>{n.r(t),n.d(t,{Qwen2VLProcessor:()=>o});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),i=n("./src/tokenizers.js");n("./src/utils/image.js");class o extends r.Processor{async _call(l,u=null,...p){Array.isArray(l)||(l=[l]);let c,d;if(u&&(c=await this.image_processor(u),d=c.image_grid_thw),d){let m=this.image_processor.config.merge_size**2,y=0;const C=d.tolist();l=l.map(_=>{for(;_.includes("<|image_pad|>");){const h=Number(C[y++].reduce((w,M)=>w*M,1n));_=_.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(h/m)))}return _.replaceAll("<|placeholder|>","<|image_pad|>")})}return{...this.tokenizer(l),...c}}}ie(o,"image_processor_class",s.AutoImageProcessor),ie(o,"tokenizer_class",i.AutoTokenizer)},"./src/models/rt_detr/image_processing_rt_detr.js":(e,t,n)=>{n.r(t),n.d(t,{RTDetrImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_object_detection(...o){return(0,r.post_process_object_detection)(...o)}}},"./src/models/sam/image_processing_sam.js":(e,t,n)=>{n.r(t),n.d(t,{SamImageProcessor:()=>o});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/core.js"),i=n("./src/utils/tensor.js");class o extends r.ImageProcessor{reshape_input_points(l,u,p,c=!1){l=structuredClone(l);let d=(0,s.calculateDimensions)(l);if(d.length===3)c||(d=[1,...d]),l=[l];else if(d.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let f=0;f<l.length;++f){let m=u[f],y=p[f],C=[y[0]/m[0],y[1]/m[1]];for(let _=0;_<l[f].length;++_)for(let h=0;h<l[f][_].length;++h)for(let w=0;w<l[f][_][h].length;++w)l[f][_][h][w]*=C[w%2]}return new i.Tensor("float32",Float32Array.from(l.flat(1/0)),d)}add_input_labels(l,u){let p=(0,s.calculateDimensions)(l);if(p.length===2)p=[1,...p],l=[l];else if(p.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(p.some((c,d)=>c!==u.dims[d]))throw Error(`The first ${p.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new i.Tensor("int64",l.flat(1/0).map(BigInt),p)}async _call(l,{input_points:u=null,input_labels:p=null,input_boxes:c=null}={}){const d=await super._call(l);if(u&&(d.input_points=this.reshape_input_points(u,d.original_sizes,d.reshaped_input_sizes)),p){if(!d.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");d.input_labels=this.add_input_labels(p,d.input_points)}return c&&(d.input_boxes=this.reshape_input_points(c,d.original_sizes,d.reshaped_input_sizes,!0)),d}async post_process_masks(l,u,p,{mask_threshold:c=0,binarize:d=!0,pad_size:f=null}={}){const m=[];f=f??this.pad_size;const y=[f.height,f.width];for(let C=0;C<u.length;++C){const _=u[C],h=p[C];let w=await(0,i.interpolate_4d)(l[C],{mode:"bilinear",size:y});if(w=w.slice(null,null,[0,h[0]],[0,h[1]]),w=await(0,i.interpolate_4d)(w,{mode:"bilinear",size:_}),d){const M=w.data,x=new Uint8Array(M.length);for(let b=0;b<M.length;++b)M[b]>c&&(x[b]=1);w=new i.Tensor("bool",x,w.dims)}m.push(w)}return m}generate_crop_boxes(l,u,{crop_n_layers:p=0,overlap_ratio:c=512/1500,points_per_crop:d=32,crop_n_points_downscale_factor:f=1}={}){}}},"./src/models/sam/processing_sam.js":(e,t,n)=>{n.r(t),n.d(t,{SamProcessor:()=>i});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js");class i extends r.Processor{async _call(...a){return await this.image_processor(...a)}post_process_masks(...a){return this.image_processor.post_process_masks(...a)}reshape_input_points(...a){return this.image_processor.reshape_input_points(...a)}}ie(i,"image_processor_class",s.AutoImageProcessor)},"./src/models/seamless_m4t/feature_extraction_seamless_m4t.js":(e,t,n)=>{n.r(t),n.d(t,{SeamlessM4TFeatureExtractor:()=>o});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js"),i=n("./src/utils/audio.js");class o extends r.FeatureExtractor{constructor(l){super(l);const u=this.config.sampling_rate,p=(0,i.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(u/2),u,null,"kaldi",!0);this.mel_filters=p,this.window=(0,i.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(l,u){return l=l.map(p=>p*32768),(0,i.spectrogram)(l,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:u,transpose:!0})}async _call(l,{padding:u=!0,pad_to_multiple_of:p=2,do_normalize_per_mel_bins:c=!0,return_attention_mask:d=!0}={}){(0,r.validate_audio_inputs)(l,"SeamlessM4TFeatureExtractor");let f=await this._extract_fbank_features(l,this.config.max_length);if(c){const[x,b]=f.dims,T=f.data;for(let S=0;S<b;++S){let $=0;for(let N=0;N<x;++N)$+=T[N*b+S];const O=$/x;let G=0;for(let N=0;N<x;++N)G+=(T[N*b+S]-O)**2;G/=x-1;const H=Math.sqrt(G+1e-7);for(let N=0;N<x;++N){const J=N*b+S;T[J]=(T[J]-O)/H}}}let m;if(u){const[x,b]=f.dims,T=f.data,S=x%p;if(S>0){const $=new Float32Array(b*(x+S));$.set(T),$.fill(this.config.padding_value,T.length);const O=x+S;f=new s.Tensor(f.type,$,[O,b]),d&&(m=new s.Tensor("int64",new BigInt64Array(O),[1,O]),m.data.fill(1n,0,x))}}const[y,C]=f.dims,_=this.config.stride;if(y%_!==0)throw new Error(`The number of frames (${y}) must be a multiple of the stride (${_}).`);const w=f.view(1,Math.floor(y/_),C*_),M={input_features:w};if(d){const x=w.dims[1],b=new BigInt64Array(x);if(m){const T=m.data;for(let S=1,$=0;S<y;S+=_,++$)b[$]=T[S]}else b.fill(1n);M.attention_mask=new s.Tensor("int64",b,[1,x])}return M}}},"./src/models/segformer/image_processing_segformer.js":(e,t,n)=>{n.r(t),n.d(t,{SegformerFeatureExtractor:()=>i,SegformerImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_semantic_segmentation(...a){return(0,r.post_process_semantic_segmentation)(...a)}}class i extends s{}},"./src/models/siglip/image_processing_siglip.js":(e,t,n)=>{n.r(t),n.d(t,{SiglipImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/smolvlm/image_processing_smolvlm.js":(e,t,n)=>{n.r(t),n.d(t,{SmolVLMImageProcessor:()=>r.Idefics3ImageProcessor});var r=n("./src/models/idefics3/image_processing_idefics3.js")},"./src/models/smolvlm/processing_smolvlm.js":(e,t,n)=>{n.r(t),n.d(t,{SmolVLMProcessor:()=>r.Idefics3Processor});var r=n("./src/models/idefics3/processing_idefics3.js")},"./src/models/snac/feature_extraction_snac.js":(e,t,n)=>{n.r(t),n.d(t,{SnacFeatureExtractor:()=>s});var r=n("./src/models/dac/feature_extraction_dac.js");class s extends r.DacFeatureExtractor{}},"./src/models/speecht5/feature_extraction_speecht5.js":(e,t,n)=>{n.r(t),n.d(t,{SpeechT5FeatureExtractor:()=>s});var r=n("./src/base/feature_extraction_utils.js");class s extends r.FeatureExtractor{}},"./src/models/speecht5/processing_speecht5.js":(e,t,n)=>{n.r(t),n.d(t,{SpeechT5Processor:()=>o});var r=n("./src/base/processing_utils.js"),s=n("./src/tokenizers.js"),i=n("./src/models/auto/feature_extraction_auto.js");class o extends r.Processor{async _call(l){return await this.feature_extractor(l)}}ie(o,"tokenizer_class",s.AutoTokenizer),ie(o,"feature_extractor_class",i.AutoFeatureExtractor)},"./src/models/swin2sr/image_processing_swin2sr.js":(e,t,n)=>{n.r(t),n.d(t,{Swin2SRImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{pad_image(o,a,l,u={}){const[p,c,d]=a;return super.pad_image(o,a,{width:c+(l-c%l)%l,height:p+(l-p%l)%l},{mode:"symmetric",center:!1,constant_values:-1,...u})}}},"./src/models/ultravox/processing_ultravox.js":(e,t,n)=>{n.r(t),n.d(t,{UltravoxProcessor:()=>o});var r=n("./src/models/auto/feature_extraction_auto.js"),s=n("./src/tokenizers.js"),i=n("./src/base/processing_utils.js");class o extends i.Processor{async _call(l,u=null,p={}){if(Array.isArray(l))throw new Error("Batched inputs are not supported yet.");let c={};if(u){const f=u.length,{input_features:m}=await this.feature_extractor(u,{...p,max_length:f}),y=Math.round(f/this.config.encoder_ds_factor+1e-4),C=1+Math.ceil(y/this.config.stack_factor);c.audio_token_len=[C],c.audio_values=m;const _=this.config.audio_placeholder;if(!l.includes(_))throw new Error(`The input text does not contain the image token ${_}.`);l=l.replaceAll(_,_.repeat(C))}return{...this.tokenizer(l,{add_special_tokens:!1,...p}),...c}}}ie(o,"tokenizer_class",s.AutoTokenizer),ie(o,"feature_extractor_class",r.AutoFeatureExtractor),ie(o,"uses_processor_config",!0)},"./src/models/vit/image_processing_vit.js":(e,t,n)=>{n.r(t),n.d(t,{ViTFeatureExtractor:()=>i,ViTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class i extends s{}},"./src/models/vitmatte/image_processing_vitmatte.js":(e,t,n)=>{n.r(t),n.d(t,{VitMatteImageProcessor:()=>i});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class i extends r.ImageProcessor{async _call(a,l){Array.isArray(a)||(a=[a]),Array.isArray(l)||(l=[l]);const u=await Promise.all(a.map(d=>this.preprocess(d))),p=await Promise.all(l.map(d=>this.preprocess(d,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,s.stack)(u.map((d,f)=>(0,s.cat)([d.pixel_values,p[f].pixel_values],0)),0),original_sizes:u.map(d=>d.original_size),reshaped_input_sizes:u.map(d=>d.reshaped_input_size)}}}},"./src/models/vitpose/image_processing_vitpose.js":(e,t,n)=>{n.r(t),n.d(t,{VitPoseImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_pose_estimation(o,a,{threshold:l=null}={}){const u=o.tolist(),[p,c,d,f]=o.dims,m=[];for(let y=0;y<p;++y){const C=u[y],_=a[y],h=[];for(let w=0;w<_.length;++w){const M=_[w],x=[],b=[],T=[],S=M.at(-2)/f,$=M.at(-1)/d;for(let O=0;O<C.length;++O){let[G,H]=[0,0],N=0,J=-1/0;const q=C[O];for(let Y=0;Y<q.length;++Y){const K=q[Y];for(let oe=0;oe<K.length;++oe){const se=K[oe];N+=se,J=Math.max(J,se),G+=(oe+.5)*se,H+=Y*se}}if(l!=null&&J<l)continue;const X=[S*G/N,$*H/N];x.push(X),T.push(O),b.push(J)}h.push({bbox:M,scores:b,labels:T,keypoints:x})}m.push(h)}return m}}},"./src/models/wav2vec2/feature_extraction_wav2vec2.js":(e,t,n)=>{n.r(t),n.d(t,{Wav2Vec2FeatureExtractor:()=>i});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js");class i extends r.FeatureExtractor{_zero_mean_unit_var_norm(a){const u=a.reduce((c,d)=>c+d,0)/a.length,p=a.reduce((c,d)=>c+(d-u)**2,0)/a.length;return a.map(c=>(c-u)/Math.sqrt(p+1e-7))}async _call(a){(0,r.validate_audio_inputs)(a,"Wav2Vec2FeatureExtractor"),a instanceof Float64Array&&(a=new Float32Array(a));let l=a;this.config.do_normalize&&(l=this._zero_mean_unit_var_norm(l));const u=[1,l.length];return{input_values:new s.Tensor("float32",l,u),attention_mask:new s.Tensor("int64",new BigInt64Array(l.length).fill(1n),u)}}}},"./src/models/wav2vec2/processing_wav2vec2.js":(e,t,n)=>{n.r(t),n.d(t,{Wav2Vec2Processor:()=>o});var r=n("./src/tokenizers.js"),s=n("./src/models/auto/feature_extraction_auto.js"),i=n("./src/base/processing_utils.js");class o extends i.Processor{async _call(l){return await this.feature_extractor(l)}}ie(o,"tokenizer_class",r.AutoTokenizer),ie(o,"feature_extractor_class",s.AutoFeatureExtractor)},"./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js":(e,t,n)=>{n.r(t),n.d(t,{Wav2Vec2ProcessorWithLM:()=>o});var r=n("./src/tokenizers.js"),s=n("./src/models/auto/feature_extraction_auto.js"),i=n("./src/base/processing_utils.js");class o extends i.Processor{async _call(l){return await this.feature_extractor(l)}}ie(o,"tokenizer_class",r.AutoTokenizer),ie(o,"feature_extractor_class",s.AutoFeatureExtractor)},"./src/models/wespeaker/feature_extraction_wespeaker.js":(e,t,n)=>{n.r(t),n.d(t,{WeSpeakerFeatureExtractor:()=>i});var r=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var s=n("./src/utils/audio.js");class i extends r.FeatureExtractor{constructor(a){super(a);const l=this.config.sampling_rate,u=(0,s.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(l/2),l,null,"kaldi",!0);this.mel_filters=u,this.window=(0,s.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(a){return a=a.map(l=>l*32768),(0,s.spectrogram)(a,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(a){(0,r.validate_audio_inputs)(a,"WeSpeakerFeatureExtractor");const l=(await this._extract_fbank_features(a)).unsqueeze_(0);if(this.config.fbank_centering_span===null){const u=l.mean(1).data,p=l.data,[c,d,f]=l.dims;for(let m=0;m<c;++m){const y=m*d*f,C=m*f;for(let _=0;_<d;++_){const h=y+_*f;for(let w=0;w<f;++w)p[h+w]-=u[C+w]}}}return{input_features:l}}}},"./src/models/whisper/common_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WHISPER_LANGUAGE_MAPPING:()=>s,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>i,whisper_language_to_code:()=>o});const r=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],s=new Map(r),i=new Map([...r.map(([a,l])=>[l,a]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function o(a){a=a.toLowerCase();let l=i.get(a);if(l===void 0){const u=a.match(/^<\|([a-z]{2})\|>$/);if(u&&(a=u[1]),s.has(a))l=a;else{const c=a.length===2?s.keys():s.values();throw new Error(`Language "${a}" is not supported. Must be one of: ${JSON.stringify(Array.from(c))}`)}}return l}},"./src/models/whisper/feature_extraction_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WhisperFeatureExtractor:()=>o});var r=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var s=n("./src/utils/audio.js"),i=n("./src/utils/maths.js");class o extends r.FeatureExtractor{constructor(l){var u;super(l),(u=this.config).mel_filters??(u.mel_filters=(0,s.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney")),this.window=(0,s.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(l){const u=await(0,s.spectrogram)(l,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:Math.min(Math.floor(l.length/this.config.hop_length),this.config.nb_max_frames)}),p=u.data,c=(0,i.max)(p)[0];for(let d=0;d<p.length;++d)p[d]=(Math.max(p[d],c-8)+4)/4;return u}async _call(l,{max_length:u=null}={}){(0,r.validate_audio_inputs)(l,"WhisperFeatureExtractor");let p;const c=u??this.config.n_samples;return l.length>c?(l.length>this.config.n_samples&&console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),p=l.slice(0,c)):(p=new Float32Array(c),p.set(l)),{input_features:(await this._extract_fbank_features(p)).unsqueeze_(0)}}}},"./src/models/whisper/generation_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WhisperGenerationConfig:()=>s});var r=n("./src/generation/configuration_utils.js");class s extends r.GenerationConfig{constructor(){super(...arguments);ie(this,"return_timestamps",null);ie(this,"return_token_timestamps",null);ie(this,"num_frames",null);ie(this,"alignment_heads",null);ie(this,"task",null);ie(this,"language",null);ie(this,"no_timestamps_token_id",null);ie(this,"prompt_ids",null);ie(this,"is_multilingual",null);ie(this,"lang_to_id",null);ie(this,"task_to_id",null);ie(this,"max_initial_timestamp_index",1)}}},"./src/models/whisper/processing_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WhisperProcessor:()=>o});var r=n("./src/models/auto/feature_extraction_auto.js"),s=n("./src/tokenizers.js"),i=n("./src/base/processing_utils.js");class o extends i.Processor{async _call(l){return await this.feature_extractor(l)}}ie(o,"tokenizer_class",s.AutoTokenizer),ie(o,"feature_extractor_class",r.AutoFeatureExtractor)},"./src/models/yolos/image_processing_yolos.js":(e,t,n)=>{n.r(t),n.d(t,{YolosFeatureExtractor:()=>i,YolosImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_object_detection(...a){return(0,r.post_process_object_detection)(...a)}}class i extends s{}},"./src/ops/registry.js":(e,t,n)=>{n.r(t),n.d(t,{TensorOpRegistry:()=>l});var r=n("./src/backends/onnx.js"),s=n("./src/utils/tensor.js"),i=n("./src/env.js");const o=i.apis.IS_BROWSER_ENV||i.apis.IS_WEBWORKER_ENV,a=async(u,p,c)=>{const d=await(0,r.createInferenceSession)(new Uint8Array(u),p);let f=Promise.resolve();return async m=>{const y=(0,r.isONNXProxy)(),C=Object.fromEntries(Object.entries(m).map(([h,w])=>[h,(y?w.clone():w).ort_tensor])),_=await(f=o?f.then(()=>d.run(C)):d.run(C));return Array.isArray(c)?c.map(h=>new s.Tensor(_[h])):new s.Tensor(_[c])}};class l{static get nearest_interpolate_4d(){return this._nearest_interpolate_4d||(this._nearest_interpolate_4d=a([8,10,18,0,58,129,1,10,41,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,18,10,4,109,111,100,101,34,7,110,101,97,114,101,115,116,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,21],this.session_options,"y")),this._nearest_interpolate_4d}static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=a([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=a([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=a([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=a([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=a([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=a([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}static get slice(){return this._slice||(this._slice=a([8,7,18,0,58,96,10,25,10,1,120,10,1,115,10,1,101,10,1,97,10,1,116,18,1,121,34,5,83,108,105,99,101,18,1,114,90,9,10,1,120,18,4,10,2,8,1,90,9,10,1,115,18,4,10,2,8,7,90,9,10,1,101,18,4,10,2,8,7,90,9,10,1,97,18,4,10,2,8,7,90,9,10,1,116,18,4,10,2,8,7,98,9,10,1,121,18,4,10,2,8,1,66,2,16,13],this.session_options,"y")),this._slice}}ie(l,"session_options",{})},"./src/pipelines.js":(e,t,n)=>{n.r(t),n.d(t,{AudioClassificationPipeline:()=>H,AutomaticSpeechRecognitionPipeline:()=>J,BackgroundRemovalPipeline:()=>K,DepthEstimationPipeline:()=>pe,DocumentQuestionAnsweringPipeline:()=>I,FeatureExtractionPipeline:()=>O,FillMaskPipeline:()=>w,ImageClassificationPipeline:()=>X,ImageFeatureExtractionPipeline:()=>G,ImageSegmentationPipeline:()=>Y,ImageToImagePipeline:()=>ee,ImageToTextPipeline:()=>q,ObjectDetectionPipeline:()=>se,Pipeline:()=>y,QuestionAnsweringPipeline:()=>h,SummarizationPipeline:()=>x,Text2TextGenerationPipeline:()=>M,TextClassificationPipeline:()=>C,TextGenerationPipeline:()=>S,TextToAudioPipeline:()=>V,TokenClassificationPipeline:()=>_,TranslationPipeline:()=>b,ZeroShotAudioClassificationPipeline:()=>N,ZeroShotClassificationPipeline:()=>$,ZeroShotImageClassificationPipeline:()=>oe,ZeroShotObjectDetectionPipeline:()=>F,pipeline:()=>Se});var r=n("./src/tokenizers.js"),s=n("./src/models.js"),i=n("./src/models/auto/processing_auto.js");n("./src/base/processing_utils.js");var o=n("./src/utils/generic.js"),a=n("./src/utils/core.js"),l=n("./src/utils/maths.js"),u=n("./src/utils/audio.js"),p=n("./src/utils/tensor.js"),c=n("./src/utils/image.js");async function d(ye){return Array.isArray(ye)||(ye=[ye]),await Promise.all(ye.map(Q=>c.RawImage.read(Q)))}async function f(ye,Q){return Array.isArray(ye)||(ye=[ye]),await Promise.all(ye.map(j=>typeof j=="string"||j instanceof URL?(0,u.read_audio)(j,Q):j instanceof Float64Array?new Float32Array(j):j))}function m(ye,Q){Q&&(ye=ye.map(Ce=>Ce|0));const[j,he,be,we]=ye;return{xmin:j,ymin:he,xmax:be,ymax:we}}class y extends o.Callable{constructor({task:Q,model:j,tokenizer:he=null,processor:be=null}){super(),this.task=Q,this.model=j,this.tokenizer=he,this.processor=be}async dispose(){await this.model.dispose()}}class C extends y{constructor(Q){super(Q)}async _call(Q,{top_k:j=1}={}){const he=this.tokenizer(Q,{padding:!0,truncation:!0}),be=await this.model(he),we=this.model.config.problem_type==="multi_label_classification"?Oe=>Oe.sigmoid():Oe=>new p.Tensor("float32",(0,l.softmax)(Oe.data),Oe.dims),Ce=this.model.config.id2label,De=[];for(const Oe of be.logits){const Le=we(Oe),je=await(0,p.topk)(Le,j),L=je[0].tolist(),R=je[1].tolist().map((ne,ue)=>({label:Ce?Ce[ne]:`LABEL_${ne}`,score:L[ue]}));j===1?De.push(...R):De.push(R)}return Array.isArray(Q)||j===1?De:De[0]}}class _ extends y{constructor(Q){super(Q)}async _call(Q,{ignore_labels:j=["O"]}={}){const he=Array.isArray(Q),be=this.tokenizer(he?Q:[Q],{padding:!0,truncation:!0}),Ce=(await this.model(be)).logits,De=this.model.config.id2label,Oe=[];for(let Le=0;Le<Ce.dims[0];++Le){const je=be.input_ids[Le],L=Ce[Le],re=[];for(let R=0;R<L.dims[0];++R){const ne=L[R],ue=(0,l.max)(ne.data)[1],ve=De?De[ue]:`LABEL_${ue}`;if(j.includes(ve))continue;const Te=this.tokenizer.decode([je[R].item()],{skip_special_tokens:!0});if(Te==="")continue;const Ae=(0,l.softmax)(ne.data);re.push({entity:ve,score:Ae[ue],index:R,word:Te})}Oe.push(re)}return he?Oe:Oe[0]}}class h extends y{constructor(Q){super(Q)}async _call(Q,j,{top_k:he=1}={}){const be=this.tokenizer(Q,{text_pair:j,padding:!0,truncation:!0}),{start_logits:we,end_logits:Ce}=await this.model(be),De=be.input_ids.tolist(),Oe=be.attention_mask.tolist(),Le=this.tokenizer.all_special_ids,je=[];for(let L=0;L<we.dims[0];++L){const re=De[L],R=re.findIndex($e=>$e==this.tokenizer.sep_token_id);Oe[L].map(($e,Ve)=>$e==1&&(Ve===0||Ve>R&&Le.findIndex(Je=>Je==re[Ve])===-1));const ne=we[L].tolist(),ue=Ce[L].tolist();for(let $e=1;$e<ne.length;++$e)(Oe[L]==0||$e<=R||Le.findIndex(Ve=>Ve==re[$e])!==-1)&&(ne[$e]=-1/0,ue[$e]=-1/0);const ve=(0,l.softmax)(ne).map(($e,Ve)=>[$e,Ve]),Te=(0,l.softmax)(ue).map(($e,Ve)=>[$e,Ve]);ve[0][0]=0,Te[0][0]=0;const Ae=(0,a.product)(ve,Te).filter($e=>$e[0][1]<=$e[1][1]).map($e=>[$e[0][1],$e[1][1],$e[0][0]*$e[1][0]]).sort(($e,Ve)=>Ve[2]-$e[2]);for(let $e=0;$e<Math.min(Ae.length,he);++$e){const[Ve,Je,qe]=Ae[$e],pt=re.slice(Ve,Je+1),Tt=this.tokenizer.decode(pt,{skip_special_tokens:!0});je.push({answer:Tt,score:qe})}}return he===1?je[0]:je}}class w extends y{constructor(Q){super(Q)}async _call(Q,{top_k:j=5}={}){const he=this.tokenizer(Q,{padding:!0,truncation:!0}),{logits:be}=await this.model(he),we=[],Ce=he.input_ids.tolist();for(let De=0;De<Ce.length;++De){const Oe=Ce[De],Le=Oe.findIndex(ne=>ne==this.tokenizer.mask_token_id);if(Le===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const je=be[De][Le],L=await(0,p.topk)(new p.Tensor("float32",(0,l.softmax)(je.data),je.dims),j),re=L[0].tolist(),R=L[1].tolist();we.push(R.map((ne,ue)=>{const ve=Oe.slice();return ve[Le]=ne,{score:re[ue],token:Number(ne),token_str:this.tokenizer.decode([ne]),sequence:this.tokenizer.decode(ve,{skip_special_tokens:!0})}}))}return Array.isArray(Q)?we:we[0]}}class M extends y{constructor(j){super(j);ie(this,"_key","generated_text")}async _call(j,he={}){Array.isArray(j)||(j=[j]),this.model.config.prefix&&(j=j.map(Le=>this.model.config.prefix+Le));const be=this.model.config.task_specific_params;be&&be[this.task]&&be[this.task].prefix&&(j=j.map(Le=>be[this.task].prefix+Le));const we=this.tokenizer,Ce={padding:!0,truncation:!0};let De;this instanceof b&&"_build_translation_inputs"in we?De=we._build_translation_inputs(j,Ce,he):De=we(j,Ce);const Oe=await this.model.generate({...De,...he});return we.batch_decode(Oe,{skip_special_tokens:!0}).map(Le=>({[this._key]:Le}))}}class x extends M{constructor(j){super(j);ie(this,"_key","summary_text")}}class b extends M{constructor(j){super(j);ie(this,"_key","translation_text")}}function T(ye){return Array.isArray(ye)&&ye.every(Q=>"role"in Q&&"content"in Q)}class S extends y{constructor(Q){super(Q)}async _call(Q,j={}){let he=!1,be=!1,we;if(typeof Q=="string")we=Q=[Q];else if(Array.isArray(Q)&&Q.every(R=>typeof R=="string"))he=!0,we=Q;else{if(T(Q))Q=[Q];else if(Array.isArray(Q)&&Q.every(T))he=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");be=!0,we=Q.map(R=>this.tokenizer.apply_chat_template(R,{tokenize:!1,add_generation_prompt:!0}))}const Ce=j.add_special_tokens??!1,De=be?!1:j.return_full_text??!0;this.tokenizer.padding_side="left";const Oe=this.tokenizer(we,{add_special_tokens:Ce,padding:!0,truncation:!0}),Le=await this.model.generate({...Oe,...j}),je=this.tokenizer.batch_decode(Le,{skip_special_tokens:!0});let L;!De&&Oe.input_ids.dims.at(-1)>0&&(L=this.tokenizer.batch_decode(Oe.input_ids,{skip_special_tokens:!0}).map(R=>R.length));const re=Array.from({length:Q.length},R=>[]);for(let R=0;R<je.length;++R){const ne=Math.floor(R/Le.dims[0]*Q.length);L&&(je[R]=je[R].slice(L[ne])),re[ne].push({generated_text:be?[...Q[ne],{role:"assistant",content:je[R]}]:je[R]})}return!he&&re.length===1?re[0]:re}}class $ extends y{constructor(Q){super(Q),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([j,he])=>[j.toLowerCase(),he])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(Q,j,{hypothesis_template:he="This example is {}.",multi_label:be=!1}={}){const we=Array.isArray(Q);we||(Q=[Q]),Array.isArray(j)||(j=[j]);const Ce=j.map(Le=>he.replace("{}",Le)),De=be||j.length===1,Oe=[];for(const Le of Q){const je=[];for(const R of Ce){const ne=this.tokenizer(Le,{text_pair:R,padding:!0,truncation:!0}),ue=await this.model(ne);De?je.push([ue.logits.data[this.contradiction_id],ue.logits.data[this.entailment_id]]):je.push(ue.logits.data[this.entailment_id])}const re=(De?je.map(R=>(0,l.softmax)(R)[1]):(0,l.softmax)(je)).map((R,ne)=>[R,ne]).sort((R,ne)=>ne[0]-R[0]);Oe.push({sequence:Le,labels:re.map(R=>j[R[1]]),scores:re.map(R=>R[0])})}return we?Oe:Oe[0]}}class O extends y{constructor(Q){super(Q)}async _call(Q,{pooling:j="none",normalize:he=!1,quantize:be=!1,precision:we="binary"}={}){const Ce=this.tokenizer(Q,{padding:!0,truncation:!0}),De=await this.model(Ce);let Oe=De.last_hidden_state??De.logits??De.token_embeddings;if(j!=="none")if(j==="mean")Oe=(0,p.mean_pooling)(Oe,Ce.attention_mask);else if(j==="cls")Oe=Oe.slice(null,0);else throw Error(`Pooling method '${j}' not supported.`);return he&&(Oe=Oe.normalize(2,-1)),be&&(Oe=(0,p.quantize_embeddings)(Oe,we)),Oe}}class G extends y{constructor(Q){super(Q)}async _call(Q,{pool:j=null}={}){const he=await d(Q),{pixel_values:be}=await this.processor(he),we=await this.model({pixel_values:be});let Ce;if(j){if(!("pooler_output"in we))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");Ce=we.pooler_output}else Ce=we.last_hidden_state??we.logits??we.image_embeds;return Ce}}class H extends y{constructor(Q){super(Q)}async _call(Q,{top_k:j=5}={}){const he=this.processor.feature_extractor.config.sampling_rate,be=await f(Q,he),we=this.model.config.id2label,Ce=[];for(const De of be){const Oe=await this.processor(De),je=(await this.model(Oe)).logits[0],L=await(0,p.topk)(new p.Tensor("float32",(0,l.softmax)(je.data),je.dims),j),re=L[0].tolist(),ne=L[1].tolist().map((ue,ve)=>({label:we?we[ue]:`LABEL_${ue}`,score:re[ve]}));Ce.push(ne)}return Array.isArray(Q)?Ce:Ce[0]}}class N extends y{constructor(Q){super(Q)}async _call(Q,j,{hypothesis_template:he="This is a sound of {}."}={}){const be=!Array.isArray(Q);be&&(Q=[Q]);const we=j.map(je=>he.replace("{}",je)),Ce=this.tokenizer(we,{padding:!0,truncation:!0}),De=this.processor.feature_extractor.config.sampling_rate,Oe=await f(Q,De),Le=[];for(const je of Oe){const L=await this.processor(je),re=await this.model({...Ce,...L}),R=(0,l.softmax)(re.logits_per_audio.data);Le.push([...R].map((ne,ue)=>({score:ne,label:j[ue]})))}return be?Le[0]:Le}}class J extends y{constructor(Q){super(Q)}async _call(Q,j={}){switch(this.model.config.model_type){case"whisper":case"lite-whisper":return this._call_whisper(Q,j);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(Q,j);case"moonshine":return this._call_moonshine(Q,j);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(Q,j){j.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),j.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const he=!Array.isArray(Q);he&&(Q=[Q]);const be=this.processor.feature_extractor.config.sampling_rate,we=await f(Q,be),Ce=[];for(const De of we){const Oe=await this.processor(De),je=(await this.model(Oe)).logits[0],L=[];for(const R of je)L.push((0,l.max)(R.data)[1]);const re=this.tokenizer.decode(L);Ce.push({text:re})}return he?Ce[0]:Ce}async _call_whisper(Q,j){const he=j.return_timestamps??!1,be=j.chunk_length_s??0,we=j.force_full_sequences??!1;let Ce=j.stride_length_s??null;const De={...j};he==="word"&&(De.return_token_timestamps=!0,De.return_timestamps=!1);const Oe=!Array.isArray(Q);Oe&&(Q=[Q]);const Le=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,je=this.processor.feature_extractor.config.hop_length,L=this.processor.feature_extractor.config.sampling_rate,re=await f(Q,L),R=[];for(const ne of re){let ue=[];if(be>0){if(Ce===null)Ce=be/6;else if(be<=Ce)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const Ae=L*be,$e=L*Ce,Ve=Ae-2*$e;let Je=0;for(;;){const qe=Je+Ae,pt=ne.subarray(Je,qe),Tt=await this.processor(pt),Ht=Je===0,$t=qe>=ne.length;if(ue.push({stride:[pt.length,Ht?0:$e,$t?0:$e],input_features:Tt.input_features,is_last:$t}),$t)break;Je+=Ve}}else ue=[{stride:[ne.length,0,0],input_features:(await this.processor(ne)).input_features,is_last:!0}];for(const Ae of ue){De.num_frames=Math.floor(Ae.stride[0]/je);const $e=await this.model.generate({inputs:Ae.input_features,...De});he==="word"?(Ae.tokens=$e.sequences.tolist()[0],Ae.token_timestamps=$e.token_timestamps.tolist()[0].map(Ve=>(0,l.round)(Ve,2))):Ae.tokens=$e[0].tolist(),Ae.stride=Ae.stride.map(Ve=>Ve/L)}const[ve,Te]=this.tokenizer._decode_asr(ue,{time_precision:Le,return_timestamps:he,force_full_sequences:we});R.push({text:ve,...Te})}return Oe?R[0]:R}async _call_moonshine(Q,j){const he=!Array.isArray(Q);he&&(Q=[Q]);const be=this.processor.feature_extractor.config.sampling_rate,we=await f(Q,be),Ce=[];for(const De of we){const Oe=await this.processor(De),Le=Math.floor(De.length/be)*6,je=await this.model.generate({max_new_tokens:Le,...j,...Oe}),L=this.processor.batch_decode(je,{skip_special_tokens:!0})[0];Ce.push({text:L})}return he?Ce[0]:Ce}}class q extends y{constructor(Q){super(Q)}async _call(Q,j={}){const he=Array.isArray(Q),be=await d(Q),{pixel_values:we}=await this.processor(be),Ce=[];for(const De of we){De.dims=[1,...De.dims];const Oe=await this.model.generate({inputs:De,...j}),Le=this.tokenizer.batch_decode(Oe,{skip_special_tokens:!0}).map(je=>({generated_text:je.trim()}));Ce.push(Le)}return he?Ce:Ce[0]}}class X extends y{constructor(Q){super(Q)}async _call(Q,{top_k:j=5}={}){const he=await d(Q),{pixel_values:be}=await this.processor(he),we=await this.model({pixel_values:be}),Ce=this.model.config.id2label,De=[];for(const Oe of we.logits){const Le=await(0,p.topk)(new p.Tensor("float32",(0,l.softmax)(Oe.data),Oe.dims),j),je=Le[0].tolist(),re=Le[1].tolist().map((R,ne)=>({label:Ce?Ce[R]:`LABEL_${R}`,score:je[ne]}));De.push(re)}return Array.isArray(Q)?De:De[0]}}class Y extends y{constructor(Q){super(Q),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(Q,{threshold:j=.5,mask_threshold:he=.5,overlap_mask_area_threshold:be=.8,label_ids_to_fuse:we=null,target_sizes:Ce=null,subtask:De=null}={}){if(Array.isArray(Q)&&Q.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const Le=await d(Q),je=Le.map(Ae=>[Ae.height,Ae.width]),L=await this.processor(Le),{inputNames:re,outputNames:R}=this.model.sessions.model;if(!re.includes("pixel_values")){if(re.length!==1)throw Error(`Expected a single input name, but got ${re.length} inputs: ${re}.`);const Ae=re[0];if(Ae in L)throw Error(`Input name ${Ae} already exists in the inputs.`);L[Ae]=L.pixel_values}const ne=await this.model(L);let ue=null;if(De!==null)ue=this.subtasks_mapping[De];else if(this.processor.image_processor){for(const[Ae,$e]of Object.entries(this.subtasks_mapping))if($e in this.processor.image_processor){ue=this.processor.image_processor[$e].bind(this.processor.image_processor),De=Ae;break}}const ve=this.model.config.id2label,Te=[];if(De)if(De==="panoptic"||De==="instance"){const Ae=ue(ne,j,he,be,we,Ce??je)[0],$e=Ae.segmentation;for(const Ve of Ae.segments_info){const Je=new Uint8ClampedArray($e.data.length);for(let pt=0;pt<$e.data.length;++pt)$e.data[pt]===Ve.id&&(Je[pt]=255);const qe=new c.RawImage(Je,$e.dims[1],$e.dims[0],1);Te.push({score:Ve.score,label:ve[Ve.label_id],mask:qe})}}else if(De==="semantic"){const{segmentation:Ae,labels:$e}=ue(ne,Ce??je)[0];for(const Ve of $e){const Je=new Uint8ClampedArray(Ae.data.length);for(let pt=0;pt<Ae.data.length;++pt)Ae.data[pt]===Ve&&(Je[pt]=255);const qe=new c.RawImage(Je,Ae.dims[1],Ae.dims[0],1);Te.push({score:null,label:ve[Ve],mask:qe})}}else throw Error(`Subtask ${De} not supported.`);else{const $e=ne[R[0]];for(let Ve=0;Ve<je.length;++Ve){const Je=je[Ve],qe=$e[Ve];qe.data.some(Tt=>Tt<-1e-5||Tt>1+1e-5)&&qe.sigmoid_();const pt=await c.RawImage.fromTensor(qe.mul_(255).to("uint8")).resize(Je[1],Je[0]);Te.push({label:null,score:null,mask:pt})}}return Te}}class K extends Y{constructor(Q){super(Q)}async _call(Q,j={}){if(Array.isArray(Q)&&Q.length!==1)throw Error("Background removal pipeline currently only supports a batch size of 1.");const be=await d(Q),we=await super._call(Q,j);return be.map((De,Oe)=>{const Le=De.clone();return Le.putAlpha(we[Oe].mask),Le})}}class oe extends y{constructor(Q){super(Q)}async _call(Q,j,{hypothesis_template:he="This is a photo of {}"}={}){const be=Array.isArray(Q),we=await d(Q),Ce=j.map(re=>he.replace("{}",re)),De=this.tokenizer(Ce,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:Oe}=await this.processor(we),Le=await this.model({...De,pixel_values:Oe}),je=this.model.config.model_type==="siglip"?re=>re.sigmoid().data:re=>(0,l.softmax)(re.data),L=[];for(const re of Le.logits_per_image){const ne=[...je(re)].map((ue,ve)=>({score:ue,label:j[ve]}));ne.sort((ue,ve)=>ve.score-ue.score),L.push(ne)}return be?L:L[0]}}class se extends y{constructor(Q){super(Q)}async _call(Q,{threshold:j=.9,percentage:he=!1}={}){const be=Array.isArray(Q);if(be&&Q.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const we=await d(Q),Ce=he?null:we.map(R=>[R.height,R.width]),{pixel_values:De,pixel_mask:Oe}=await this.processor(we),Le=await this.model({pixel_values:De,pixel_mask:Oe}),je=this.processor.image_processor.post_process_object_detection(Le,j,Ce),L=this.model.config.id2label,re=je.map(R=>R.boxes.map((ne,ue)=>({score:R.scores[ue],label:L[R.classes[ue]],box:m(ne,!he)})));return be?re:re[0]}}class F extends y{constructor(Q){super(Q)}async _call(Q,j,{threshold:he=.1,top_k:be=null,percentage:we=!1}={}){const Ce=Array.isArray(Q),De=await d(Q),Oe=this.tokenizer(j,{padding:!0,truncation:!0}),Le=await this.processor(De),je=[];for(let L=0;L<De.length;++L){const re=De[L],R=we?null:[[re.height,re.width]],ne=Le.pixel_values[L].unsqueeze_(0),ue=await this.model({...Oe,pixel_values:ne});let ve;if("post_process_grounded_object_detection"in this.processor){const Te=this.processor.post_process_grounded_object_detection(ue,Oe.input_ids,{box_threshold:he,text_threshold:he,target_sizes:R})[0];ve=Te.boxes.map((Ae,$e)=>({score:Te.scores[$e],label:Te.labels[$e],box:m(Ae,!we)}))}else{const Te=this.processor.image_processor.post_process_object_detection(ue,he,R,!0)[0];ve=Te.boxes.map((Ae,$e)=>({score:Te.scores[$e],label:j[Te.classes[$e]],box:m(Ae,!we)}))}ve.sort((Te,Ae)=>Ae.score-Te.score),be!==null&&(ve=ve.slice(0,be)),je.push(ve)}return Ce?je:je[0]}}class I extends y{constructor(Q){super(Q)}async _call(Q,j,he={}){const be=(await d(Q))[0],{pixel_values:we}=await this.processor(be),Ce=`<s_docvqa><s_question>${j}</s_question><s_answer>`,De=this.tokenizer(Ce,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,Oe=await this.model.generate({inputs:we,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:De,...he}),je=this.tokenizer.batch_decode(Oe)[0].match(/<s_answer>(.*?)<\/s_answer>/);let L=null;return je&&je.length>=2&&(L=je[1].trim()),[{answer:L}]}}class V extends y{constructor(j){super(j);ie(this,"DEFAULT_VOCODER_ID","Xenova/speecht5_hifigan");this.vocoder=j.vocoder??null}async _call(j,{speaker_embeddings:he=null}={}){return this.processor?this._call_text_to_spectrogram(j,{speaker_embeddings:he}):this._call_text_to_waveform(j)}async _call_text_to_waveform(j){const he=this.tokenizer(j,{padding:!0,truncation:!0}),{waveform:be}=await this.model(he),we=this.model.config.sampling_rate;return new u.RawAudio(be.data,we)}async _call_text_to_spectrogram(j,{speaker_embeddings:he}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await s.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),(typeof he=="string"||he instanceof URL)&&(he=new Float32Array(await(await fetch(he)).arrayBuffer())),he instanceof Float32Array)he=new p.Tensor("float32",he,[1,he.length]);else if(!(he instanceof p.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:be}=this.tokenizer(j,{padding:!0,truncation:!0}),{waveform:we}=await this.model.generate_speech(be,he,{vocoder:this.vocoder}),Ce=this.processor.feature_extractor.config.sampling_rate;return new u.RawAudio(we.data,Ce)}}class ee extends y{constructor(Q){super(Q)}async _call(Q){const j=await d(Q),he=await this.processor(j),be=await this.model(he),we=[];for(const Ce of be.reconstruction){const De=Ce.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");we.push(c.RawImage.fromTensor(De))}return we.length>1?we:we[0]}}class pe extends y{constructor(Q){super(Q)}async _call(Q){const j=await d(Q),he=await this.processor(j),{predicted_depth:be}=await this.model(he),we=[];for(let Ce=0;Ce<j.length;++Ce){const De=be[Ce],[Oe,Le]=De.dims.slice(-2),[je,L]=j[Ce].size,re=(await(0,p.interpolate_4d)(De.view(1,1,Oe,Le),{size:[L,je],mode:"bilinear"})).view(L,je),R=re.min().item(),ne=re.max().item(),ue=re.sub(R).div_(ne-R).mul_(255).to("uint8").unsqueeze(0),ve=c.RawImage.fromTensor(ue);we.push({predicted_depth:re,depth:ve})}return we.length>1?we:we[0]}}const Z=Object.freeze({"text-classification":{tokenizer:r.AutoTokenizer,pipeline:C,model:s.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:r.AutoTokenizer,pipeline:_,model:s.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:r.AutoTokenizer,pipeline:h,model:s.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:r.AutoTokenizer,pipeline:w,model:s.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:r.AutoTokenizer,pipeline:x,model:s.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:r.AutoTokenizer,pipeline:b,model:s.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:r.AutoTokenizer,pipeline:M,model:s.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:r.AutoTokenizer,pipeline:S,model:s.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:r.AutoTokenizer,pipeline:$,model:s.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:H,model:s.AutoModelForAudioClassification,processor:i.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:r.AutoTokenizer,pipeline:N,model:s.AutoModel,processor:i.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:r.AutoTokenizer,pipeline:J,model:[s.AutoModelForSpeechSeq2Seq,s.AutoModelForCTC],processor:i.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:r.AutoTokenizer,pipeline:V,model:[s.AutoModelForTextToWaveform,s.AutoModelForTextToSpectrogram],processor:[i.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:r.AutoTokenizer,pipeline:q,model:s.AutoModelForVision2Seq,processor:i.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:X,model:s.AutoModelForImageClassification,processor:i.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:Y,model:[s.AutoModelForImageSegmentation,s.AutoModelForSemanticSegmentation,s.AutoModelForUniversalSegmentation],processor:i.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"background-removal":{pipeline:K,model:[s.AutoModelForImageSegmentation,s.AutoModelForSemanticSegmentation,s.AutoModelForUniversalSegmentation],processor:i.AutoProcessor,default:{model:"Xenova/modnet"},type:"image"},"zero-shot-image-classification":{tokenizer:r.AutoTokenizer,pipeline:oe,model:s.AutoModel,processor:i.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:se,model:s.AutoModelForObjectDetection,processor:i.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:r.AutoTokenizer,pipeline:F,model:s.AutoModelForZeroShotObjectDetection,processor:i.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:r.AutoTokenizer,pipeline:I,model:s.AutoModelForDocumentQuestionAnswering,processor:i.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:ee,model:s.AutoModelForImageToImage,processor:i.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:pe,model:s.AutoModelForDepthEstimation,processor:i.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:r.AutoTokenizer,pipeline:O,model:s.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:i.AutoProcessor,pipeline:G,model:[s.AutoModelForImageFeatureExtraction,s.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),de=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function Se(ye,Q=null,{progress_callback:j=null,config:he=null,cache_dir:be=null,local_files_only:we=!1,revision:Ce="main",device:De=null,dtype:Oe=null,subfolder:Le="onnx",use_external_data_format:je=null,model_file_name:L=null,session_options:re={}}={}){ye=de[ye]??ye;const R=Z[ye.split("_",1)[0]];if(!R)throw Error(`Unsupported pipeline: ${ye}. Must be one of [${Object.keys(Z)}]`);Q||(Q=R.default.model,console.log(`No model specified. Using default model: "${Q}".`));const ne={progress_callback:j,config:he,cache_dir:be,local_files_only:we,revision:Ce,device:De,dtype:Oe,subfolder:Le,use_external_data_format:je,model_file_name:L,session_options:re},ue=new Map([["tokenizer",R.tokenizer],["model",R.model],["processor",R.processor]]),ve=await Re(ue,Q,ne);ve.task=ye,(0,a.dispatchCallback)(j,{status:"ready",task:ye,model:Q});const Te=R.pipeline;return new Te(ve)}async function Re(ye,Q,j){const he=Object.create(null),be=[];for(const[we,Ce]of ye.entries()){if(!Ce)continue;let De;Array.isArray(Ce)?De=new Promise(async(Oe,Le)=>{var L,re;let je;for(const R of Ce){if(R===null){Oe(null);return}try{Oe(await R.from_pretrained(Q,j));return}catch(ne){if((L=ne.message)!=null&&L.includes("Unsupported model type"))je=ne;else if((re=ne.message)!=null&&re.includes("Could not locate file"))je=ne;else{Le(ne);return}}}Le(je)}):De=Ce.from_pretrained(Q,j),he[we]=De,be.push(De)}await Promise.all(be);for(const[we,Ce]of Object.entries(he))he[we]=await Ce;return he}},"./src/tokenizers.js":(e,t,n)=>{n.r(t),n.d(t,{AlbertTokenizer:()=>br,AutoTokenizer:()=>Mo,BartTokenizer:()=>ys,BertTokenizer:()=>hs,BlenderbotSmallTokenizer:()=>js,BlenderbotTokenizer:()=>go,BloomTokenizer:()=>Jr,CLIPTokenizer:()=>fo,CamembertTokenizer:()=>it,CodeGenTokenizer:()=>Fr,CodeLlamaTokenizer:()=>ar,CohereTokenizer:()=>wo,ConvBertTokenizer:()=>fn,DebertaTokenizer:()=>ms,DebertaV2Tokenizer:()=>_s,DistilBertTokenizer:()=>et,ElectraTokenizer:()=>Or,EsmTokenizer:()=>co,FalconTokenizer:()=>qn,GPT2Tokenizer:()=>gs,GPTNeoXTokenizer:()=>Mi,GemmaTokenizer:()=>po,Grok1Tokenizer:()=>Zr,HerbertTokenizer:()=>Ns,LlamaTokenizer:()=>uo,M2M100Tokenizer:()=>Nn,MBart50Tokenizer:()=>vs,MBartTokenizer:()=>Yr,MPNetTokenizer:()=>Ys,MarianTokenizer:()=>mo,MgpstrTokenizer:()=>Vs,MobileBertTokenizer:()=>Bs,NllbTokenizer:()=>Js,NougatTokenizer:()=>xi,PreTrainedTokenizer:()=>ft,Qwen2Tokenizer:()=>Tr,RoFormerTokenizer:()=>Be,RobertaTokenizer:()=>ws,SiglipTokenizer:()=>ho,SpeechT5Tokenizer:()=>yo,SqueezeBertTokenizer:()=>Gt,T5Tokenizer:()=>_r,TokenizerModel:()=>G,VitsTokenizer:()=>vo,Wav2Vec2CTCTokenizer:()=>_o,WhisperTokenizer:()=>Qn,XLMRobertaTokenizer:()=>Xs,XLMTokenizer:()=>Yt,is_chinese_char:()=>w});var r=n("./src/utils/generic.js"),s=n("./src/utils/core.js"),i=n("./src/utils/hub.js"),o=n("./src/utils/maths.js"),a=n("./src/utils/tensor.js"),l=n("./src/utils/data-structures.js"),u=n("./node_modules/@huggingface/jinja/dist/index.js"),p=n("./src/models/whisper/common_whisper.js");async function c(me,A){const U=await Promise.all([(0,i.getModelJSON)(me,"tokenizer.json",!0,A),(0,i.getModelJSON)(me,"tokenizer_config.json",!0,A)]);return A.legacy!==null&&(U[1].legacy=A.legacy),U}function d(me,A){const U=[];let te=0;for(const le of me.matchAll(A)){const fe=le[0];te<le.index&&U.push(me.slice(te,le.index)),fe.length>0&&U.push(fe),te=le.index+fe.length}return te<me.length&&U.push(me.slice(te)),U}function f(me,A=!0){if(me.Regex!==void 0){let U=me.Regex.replace(/\\([#&~])/g,"$1");for(const[te,le]of $)U=U.replaceAll(te,le);return new RegExp(U,"gu")}else if(me.String!==void 0){const U=(0,s.escapeRegExp)(me.String);return new RegExp(A?U:`(${U})`,"gu")}else return console.warn("Unknown pattern type:",me),null}function m(me){return new Map(Object.entries(me))}function y(me){const A=me.dims;switch(A.length){case 1:return me.tolist();case 2:if(A[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return me.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${A.length}.`)}}function C(me){return me.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function _(me){return me.replace(new RegExp("\\p{M}","gu"),"")}function h(me){return _(me.toLowerCase())}function w(me){return me>=19968&&me<=40959||me>=13312&&me<=19903||me>=131072&&me<=173791||me>=173824&&me<=177983||me>=177984&&me<=178207||me>=178208&&me<=183983||me>=63744&&me<=64255||me>=194560&&me<=195103}function M(me,A,U){const te=[];let le=0;for(;le<me.length;){if(te.push(me[le]),(A.get(me[le])??U)!==U){++le;continue}for(;++le<me.length&&(A.get(me[le])??U)===U;)A.get(te.at(-1))!==U&&(te[te.length-1]+=me[le])}return te}function x(me){return me.match(/\S+/g)||[]}const b="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",T=new RegExp(`^[${b}]+$`,"gu"),S=".,!?",$=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],[` ?[^(\\s|[${S}])]+`,` ?[^\\s${S}]+`]]);class O{constructor(A){this.content=A.content,this.id=A.id,this.single_word=A.single_word??!1,this.lstrip=A.lstrip??!1,this.rstrip=A.rstrip??!1,this.special=A.special??!1,this.normalized=A.normalized??null}}class G extends r.Callable{constructor(A){super(),this.config=A,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(A,...U){switch(A.type){case"WordPiece":return new H(A);case"Unigram":return new N(A,...U);case"BPE":return new X(A);default:if(A.vocab)return Array.isArray(A.vocab)?new N(A,...U):typeof A.vocab=="object"&&A.continuing_subword_prefix&&A.unk_token?new H(A):new Y(A,...U);throw new Error(`Unknown TokenizerModel type: ${A.type}`)}}_call(A){return A=this.encode(A),this.fuse_unk&&(A=M(A,this.tokens_to_ids,this.unk_token_id)),A}encode(A){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(A){return A.map(U=>this.tokens_to_ids.get(U)??this.unk_token_id)}convert_ids_to_tokens(A){return A.map(U=>this.vocab[U]??this.unk_token)}}class H extends G{constructor(A){super(A),this.tokens_to_ids=m(A.vocab),this.unk_token_id=this.tokens_to_ids.get(A.unk_token),this.unk_token=A.unk_token,this.max_input_chars_per_word=A.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[U,te]of this.tokens_to_ids)this.vocab[te]=U}encode(A){const U=[];for(const te of A){const le=[...te];if(le.length>this.max_input_chars_per_word){U.push(this.unk_token);continue}let fe=!1,Ee=0;const We=[];for(;Ee<le.length;){let Xe=le.length,Ke=null;for(;Ee<Xe;){let tt=le.slice(Ee,Xe).join("");if(Ee>0&&(tt=this.config.continuing_subword_prefix+tt),this.tokens_to_ids.has(tt)){Ke=tt;break}--Xe}if(Ke===null){fe=!0;break}We.push(Ke),Ee=Xe}fe?U.push(this.unk_token):U.push(...We)}return U}}class N extends G{constructor(A,U){super(A);const te=A.vocab.length;this.vocab=new Array(te),this.scores=new Array(te);for(let le=0;le<te;++le)[this.vocab[le],this.scores[le]]=A.vocab[le];this.unk_token_id=A.unk_id,this.unk_token=this.vocab[A.unk_id],this.tokens_to_ids=new Map(this.vocab.map((le,fe)=>[le,fe])),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=U.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,o.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new l.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(A){const U=A.chars,te=1;let le=0;for(;le<U.length;){let fe=!1;const Ee=U.slice(le).join(""),We=this.trie.commonPrefixSearch(Ee);for(const Xe of We){const Ke=this.tokens_to_ids.get(Xe),tt=this.scores[Ke],_t=(0,s.len)(Xe);A.insert(le,_t,tt,Ke),!fe&&_t===te&&(fe=!0)}fe||A.insert(le,te,this.unk_score,this.unk_token_id),le+=te}}tokenize(A){const U=new l.TokenLattice(A,this.bos_token_id,this.eos_token_id);return this.populateNodes(U),U.tokens()}encode(A){const U=[];for(const te of A){const le=this.tokenize(te);U.push(...le)}return U}}const J=(()=>{const me=[...Array.from({length:94},(le,fe)=>fe+33),...Array.from({length:12},(le,fe)=>fe+161),...Array.from({length:82},(le,fe)=>fe+174)],A=me.slice();let U=0;for(let le=0;le<256;++le)me.includes(le)||(me.push(le),A.push(256+U),U+=1);const te=A.map(le=>String.fromCharCode(le));return Object.fromEntries(me.map((le,fe)=>[le,te[fe]]))})(),q=(0,s.reverseDictionary)(J);class X extends G{constructor(A){super(A),this.tokens_to_ids=m(A.vocab),this.unk_token_id=this.tokens_to_ids.get(A.unk_token),this.unk_token=A.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[te,le]of this.tokens_to_ids)this.vocab[le]=te;const U=Array.isArray(A.merges[0]);this.merges=U?A.merges:A.merges.map(te=>te.split(" ",2)),this.bpe_ranks=new Map(this.merges.map((te,le)=>[JSON.stringify(te),le])),this.end_of_word_suffix=A.end_of_word_suffix,this.continuing_subword_suffix=A.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.max_length_to_cache=256,this.cache_capacity=1e4,this.cache=new l.LRUCache(this.cache_capacity)}clear_cache(){this.cache.clear()}bpe(A){if(A.length===0)return[];const U=this.cache.get(A);if(U!==void 0)return U;const te=Array.from(A);this.end_of_word_suffix&&(te[te.length-1]+=this.end_of_word_suffix);let le=[];if(te.length>1){const fe=new l.PriorityQueue((Xe,Ke)=>Xe.score<Ke.score);let Ee={token:te[0],bias:0,prev:null,next:null},We=Ee;for(let Xe=1;Xe<te.length;++Xe){const Ke={bias:Xe/te.length,token:te[Xe],prev:We,next:null};We.next=Ke,this._add_node(fe,We),We=Ke}for(;!fe.isEmpty();){const Xe=fe.pop();if(Xe.deleted||!Xe.next||Xe.next.deleted)continue;if(Xe.deleted=!0,Xe.next.deleted=!0,Xe.prev){const tt={...Xe.prev};Xe.prev.deleted=!0,Xe.prev=tt,tt.prev?tt.prev.next=tt:Ee=tt}const Ke={token:Xe.token+Xe.next.token,bias:Xe.bias,prev:Xe.prev,next:Xe.next.next};Ke.prev?(Ke.prev.next=Ke,this._add_node(fe,Ke.prev)):Ee=Ke,Ke.next&&(Ke.next.prev=Ke,this._add_node(fe,Ke))}for(let Xe=Ee;Xe!==null;Xe=Xe.next)le.push(Xe.token)}else le=te;if(this.continuing_subword_suffix)for(let fe=0;fe<le.length-1;++fe)le[fe]+=this.continuing_subword_suffix;return A.length<this.max_length_to_cache&&this.cache.put(A,le),le}_add_node(A,U){const te=this.bpe_ranks.get(JSON.stringify([U.token,U.next.token]));te!==void 0&&(U.score=te+U.bias,A.push(U))}encode(A){const U=[];for(const te of A){if(this.ignore_merges&&this.tokens_to_ids.has(te)){U.push(te);continue}const le=this.bpe(te);for(const fe of le)if(this.tokens_to_ids.has(fe))U.push(fe);else if(this.byte_fallback){const Ee=Array.from(this.text_encoder.encode(fe)).map(We=>`<0x${We.toString(16).toUpperCase().padStart(2,"0")}>`);Ee.every(We=>this.tokens_to_ids.has(We))?U.push(...Ee):U.push(this.unk_token)}else U.push(this.unk_token)}return U}}class Y extends G{constructor(A,U){super(A),this.tokens_to_ids=m(U.target_lang?A.vocab[U.target_lang]:A.vocab),this.bos_token=U.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=U.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=U.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=U.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[te,le]of this.tokens_to_ids)this.vocab[le]=te}encode(A){return A}}class K extends r.Callable{constructor(A){super(),this.config=A}static fromConfig(A){if(A===null)return null;switch(A.type){case"BertNormalizer":return new ye(A);case"Precompiled":return new $t(A);case"Sequence":return new Re(A);case"Replace":return new oe(A);case"NFC":return new F(A);case"NFD":return new I(A);case"NFKC":return new V(A);case"NFKD":return new ee(A);case"Strip":return new pe(A);case"StripAccents":return new Z(A);case"Lowercase":return new de(A);case"Prepend":return new Se(A);default:throw new Error(`Unknown Normalizer type: ${A.type}`)}}normalize(A){throw Error("normalize should be implemented in subclass.")}_call(A){return this.normalize(A)}}class oe extends K{normalize(A){const U=f(this.config.pattern);return U===null?A:A.replaceAll(U,this.config.content)}}class se extends K{constructor(){super(...arguments);ie(this,"form")}normalize(U){return U=U.normalize(this.form),U}}class F extends se{constructor(){super(...arguments);ie(this,"form","NFC")}}class I extends se{constructor(){super(...arguments);ie(this,"form","NFD")}}class V extends se{constructor(){super(...arguments);ie(this,"form","NFKC")}}class ee extends se{constructor(){super(...arguments);ie(this,"form","NFKD")}}class pe extends K{normalize(A){return this.config.strip_left&&this.config.strip_right?A=A.trim():(this.config.strip_left&&(A=A.trimStart()),this.config.strip_right&&(A=A.trimEnd())),A}}class Z extends K{normalize(A){return A=_(A),A}}class de extends K{normalize(A){return A=A.toLowerCase(),A}}class Se extends K{normalize(A){return A=this.config.prepend+A,A}}class Re extends K{constructor(A){super(A),this.normalizers=A.normalizers.map(U=>K.fromConfig(U))}normalize(A){return this.normalizers.reduce((U,te)=>te.normalize(U),A)}}class ye extends K{_tokenize_chinese_chars(A){const U=[];for(let te=0;te<A.length;++te){const le=A[te],fe=le.charCodeAt(0);w(fe)?(U.push(" "),U.push(le),U.push(" ")):U.push(le)}return U.join("")}stripAccents(A){return A.normalize("NFD").replace(new RegExp("\\p{Mn}","gu"),"")}_is_control(A){switch(A){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(A)}}_clean_text(A){const U=[];for(const te of A){const le=te.charCodeAt(0);le===0||le===65533||this._is_control(te)||(/^\s$/.test(te)?U.push(" "):U.push(te))}return U.join("")}normalize(A){return this.config.clean_text&&(A=this._clean_text(A)),this.config.handle_chinese_chars&&(A=this._tokenize_chinese_chars(A)),this.config.lowercase?(A=A.toLowerCase(),this.config.strip_accents!==!1&&(A=this.stripAccents(A))):this.config.strip_accents&&(A=this.stripAccents(A)),A}}class Q extends r.Callable{static fromConfig(A){if(A===null)return null;switch(A.type){case"BertPreTokenizer":return new j(A);case"Sequence":return new Pn(A);case"Whitespace":return new ht(A);case"WhitespaceSplit":return new Ft(A);case"Metaspace":return new Tt(A);case"ByteLevel":return new he(A);case"Split":return new be(A);case"Punctuation":return new we(A);case"Digits":return new Ce(A);case"Replace":return new Ct(A);default:throw new Error(`Unknown PreTokenizer type: ${A.type}`)}}pre_tokenize_text(A,U){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(A,U){return(Array.isArray(A)?A.map(te=>this.pre_tokenize_text(te,U)):this.pre_tokenize_text(A,U)).flat()}_call(A,U){return this.pre_tokenize(A,U)}}class j extends Q{constructor(A){super(),this.pattern=new RegExp(`[^\\s${b}]+|[${b}]`,"gu")}pre_tokenize_text(A,U){return A.trim().match(this.pattern)||[]}}class he extends Q{constructor(A){super(),this.config=A,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=J,this.text_encoder=new TextEncoder}pre_tokenize_text(A,U){return this.add_prefix_space&&!A.startsWith(" ")&&(A=" "+A),(this.use_regex?A.match(this.pattern)||[]:[A]).map(le=>Array.from(this.text_encoder.encode(le),fe=>this.byte_encoder[fe]).join(""))}}class be extends Q{constructor(A){super(),this.config=A,this.pattern=f(this.config.pattern,this.config.invert)}pre_tokenize_text(A,U){var te;return this.pattern===null?[]:this.config.invert?A.match(this.pattern)||[]:((te=this.config.behavior)==null?void 0:te.toLowerCase())==="removed"?A.split(this.pattern).filter(le=>le):d(A,this.pattern)}}class we extends Q{constructor(A){super(),this.config=A,this.pattern=new RegExp(`[^${b}]+|[${b}]+`,"gu")}pre_tokenize_text(A,U){return A.match(this.pattern)||[]}}class Ce extends Q{constructor(A){super(),this.config=A;const U=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(U,"gu")}pre_tokenize_text(A,U){return A.match(this.pattern)||[]}}class De extends r.Callable{constructor(A){super(),this.config=A}static fromConfig(A){if(A===null)return null;switch(A.type){case"TemplateProcessing":return new je(A);case"ByteLevel":return new L(A);case"RobertaProcessing":return new Le(A);case"BertProcessing":return new Oe(A);case"Sequence":return new re(A);default:throw new Error(`Unknown PostProcessor type: ${A.type}`)}}post_process(A,...U){throw Error("post_process should be implemented in subclass.")}_call(A,...U){return this.post_process(A,...U)}}class Oe extends De{constructor(A){super(A),this.cls=A.cls[0],this.sep=A.sep[0]}post_process(A,U=null,{add_special_tokens:te=!0}={}){te&&(A=(0,s.mergeArrays)([this.cls],A,[this.sep]));let le=new Array(A.length).fill(0);if(U!==null){const fe=te&&this instanceof Le?[this.sep]:[],Ee=te?[this.sep]:[];A=(0,s.mergeArrays)(A,fe,U,Ee),le=(0,s.mergeArrays)(le,new Array(U.length+fe.length+Ee.length).fill(1))}return{tokens:A,token_type_ids:le}}}class Le extends Oe{}class je extends De{constructor(A){super(A),this.single=A.single,this.pair=A.pair}post_process(A,U=null,{add_special_tokens:te=!0}={}){const le=U===null?this.single:this.pair;let fe=[],Ee=[];for(const We of le)"SpecialToken"in We?te&&(fe.push(We.SpecialToken.id),Ee.push(We.SpecialToken.type_id)):"Sequence"in We&&(We.Sequence.id==="A"?(fe=(0,s.mergeArrays)(fe,A),Ee=(0,s.mergeArrays)(Ee,new Array(A.length).fill(We.Sequence.type_id))):We.Sequence.id==="B"&&(fe=(0,s.mergeArrays)(fe,U),Ee=(0,s.mergeArrays)(Ee,new Array(U.length).fill(We.Sequence.type_id))));return{tokens:fe,token_type_ids:Ee}}}class L extends De{post_process(A,U=null){return U&&(A=(0,s.mergeArrays)(A,U)),{tokens:A}}}class re extends De{constructor(A){super(A),this.processors=A.processors.map(U=>De.fromConfig(U))}post_process(A,U=null,te={}){let le;for(const fe of this.processors)if(fe instanceof L)A=fe.post_process(A).tokens,U&&(U=fe.post_process(U).tokens);else{const Ee=fe.post_process(A,U,te);A=Ee.tokens,le=Ee.token_type_ids}return{tokens:A,token_type_ids:le}}}class R extends r.Callable{constructor(A){super(),this.config=A,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=A.trim_offsets}static fromConfig(A){if(A===null)return null;switch(A.type){case"WordPiece":return new Ae(A);case"Metaspace":return new Ht(A);case"ByteLevel":return new $e(A);case"Replace":return new ne(A);case"ByteFallback":return new ue(A);case"Fuse":return new ve(A);case"Strip":return new Te(A);case"Sequence":return new Je(A);case"CTC":return new Ve(A);case"BPEDecoder":return new qe(A);default:throw new Error(`Unknown Decoder type: ${A.type}`)}}_call(A){return this.decode(A)}decode(A){return this.decode_chain(A).join("")}decode_chain(A){throw Error("`decode_chain` should be implemented in subclass.")}}class ne extends R{decode_chain(A){const U=f(this.config.pattern);return U===null?A:A.map(te=>te.replaceAll(U,this.config.content))}}class ue extends R{constructor(A){super(A),this.text_decoder=new TextDecoder}decode_chain(A){const U=[];let te=[];for(const le of A){let fe=null;if(le.length===6&&le.startsWith("<0x")&&le.endsWith(">")){const Ee=parseInt(le.slice(3,5),16);isNaN(Ee)||(fe=Ee)}if(fe!==null)te.push(fe);else{if(te.length>0){const Ee=this.text_decoder.decode(Uint8Array.from(te));U.push(Ee),te=[]}U.push(le)}}if(te.length>0){const le=this.text_decoder.decode(Uint8Array.from(te));U.push(le),te=[]}return U}}class ve extends R{decode_chain(A){return[A.join("")]}}class Te extends R{constructor(A){super(A),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(A){return A.map(U=>{let te=0;for(let fe=0;fe<this.start&&U[fe]===this.content;++fe){te=fe+1;continue}let le=U.length;for(let fe=0;fe<this.stop;++fe){const Ee=U.length-fe-1;if(U[Ee]===this.content){le=Ee;continue}else break}return U.slice(te,le)})}}class Ae extends R{constructor(A){super(A),this.cleanup=A.cleanup}decode_chain(A){return A.map((U,te)=>(te!==0&&(U.startsWith(this.config.prefix)?U=U.replace(this.config.prefix,""):U=" "+U),this.cleanup&&(U=C(U)),U))}}class $e extends R{constructor(A){super(A),this.byte_decoder=q,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(A){const U=A.join(""),te=new Uint8Array([...U].map(fe=>this.byte_decoder[fe]));return this.text_decoder.decode(te)}decode_chain(A){const U=[];let te=[];for(const le of A)this.added_tokens.find(fe=>fe.content===le)!==void 0?(te.length>0&&(U.push(this.convert_tokens_to_string(te)),te=[]),U.push(le)):te.push(le);return te.length>0&&U.push(this.convert_tokens_to_string(te)),U}}class Ve extends R{constructor(A){super(A),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(A){if(A.length===0)return"";const U=[A[0]];for(let fe=1;fe<A.length;++fe)A[fe]!==U.at(-1)&&U.push(A[fe]);let le=U.filter(fe=>fe!==this.pad_token).join("");return this.cleanup&&(le=C(le).replaceAll(this.word_delimiter_token," ").trim()),le}decode_chain(A){return[this.convert_tokens_to_string(A)]}}class Je extends R{constructor(A){super(A),this.decoders=A.decoders.map(U=>R.fromConfig(U))}decode_chain(A){return this.decoders.reduce((U,te)=>te.decode_chain(U),A)}}class qe extends R{constructor(A){super(A),this.suffix=this.config.suffix}decode_chain(A){return A.map((U,te)=>U.replaceAll(this.suffix,te===A.length-1?"":" "))}}class pt extends R{decode_chain(A){let U="";for(let te=1;te<A.length;te+=2)U+=A[te];return[U]}}class Tt extends Q{constructor(A){super(),this.addPrefixSpace=A.add_prefix_space,this.replacement=A.replacement,this.strRep=A.str_rep||this.replacement,this.prepend_scheme=A.prepend_scheme??"always"}pre_tokenize_text(A,{section_index:U=void 0}={}){let te=A.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!te.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&U===0)&&(te=this.strRep+te),[te]}}class Ht extends R{constructor(A){super(A),this.addPrefixSpace=A.add_prefix_space,this.replacement=A.replacement}decode_chain(A){const U=[];for(let te=0;te<A.length;++te){let le=A[te].replaceAll(this.replacement," ");this.addPrefixSpace&&te==0&&le.startsWith(" ")&&(le=le.substring(1)),U.push(le)}return U}}class $t extends K{constructor(A){super(A),this.charsmap=A.precompiled_charsmap}normalize(A){return A=A.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),A=A.replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," "),A.includes("")?A=A.split("").map(te=>te.normalize("NFKC")).join(""):A=A.normalize("NFKC"),A}}class Pn extends Q{constructor(A){super(),this.tokenizers=A.pretokenizers.map(U=>Q.fromConfig(U))}pre_tokenize_text(A,U){return this.tokenizers.reduce((te,le)=>le.pre_tokenize(te,U),[A])}}class ht extends Q{constructor(A){super()}pre_tokenize_text(A,U){return A.match(/\w+|[^\w\s]+/g)||[]}}class Ft extends Q{constructor(A){super()}pre_tokenize_text(A,U){return x(A)}}class Ct extends Q{constructor(A){super(),this.config=A,this.pattern=f(this.config.pattern),this.content=this.config.content}pre_tokenize_text(A,U){return this.pattern===null?[A]:[A.replaceAll(this.pattern,this.config.content)]}}const Bn=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function An(me,A,U,te){for(const le of Object.keys(me)){const fe=A-me[le].length,Ee=U(le),We=new Array(fe).fill(Ee);me[le]=te==="right"?(0,s.mergeArrays)(me[le],We):(0,s.mergeArrays)(We,me[le])}}function Dr(me,A){for(const U of Object.keys(me))me[U].length=A}class ft extends r.Callable{constructor(U,te){super();ie(this,"return_token_type_ids",!1);ie(this,"padding_side","right");this._tokenizer_config=te,this.normalizer=K.fromConfig(U.normalizer),this.pre_tokenizer=Q.fromConfig(U.pre_tokenizer),this.model=G.fromConfig(U.model,te),this.post_processor=De.fromConfig(U.post_processor),this.decoder=R.fromConfig(U.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const le of U.added_tokens){const fe=new O(le);this.added_tokens.push(fe),this.model.tokens_to_ids.set(fe.content,fe.id),this.model.vocab[fe.id]=fe.content,fe.special&&(this.special_tokens.push(fe.content),this.all_special_ids.push(fe.id))}if(this.additional_special_tokens=te.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_splitter=new l.DictionarySplitter(this.added_tokens.map(le=>le.content)),this.added_tokens_map=new Map(this.added_tokens.map(le=>[le.content,le])),this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.bos_token=this.getToken("bos_token"),this.bos_token_id=this.model.tokens_to_ids.get(this.bos_token),this.eos_token=this.getToken("eos_token"),this.eos_token_id=this.model.tokens_to_ids.get(this.eos_token),this.model_max_length=te.model_max_length,this.remove_space=te.remove_space,this.clean_up_tokenization_spaces=te.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=te.do_lowercase_and_remove_accent??!1,te.padding_side&&(this.padding_side=te.padding_side),this.legacy=!1,this.chat_template=te.chat_template??null,Array.isArray(this.chat_template)){const le=Object.create(null);for(const{name:fe,template:Ee}of this.chat_template){if(typeof fe!="string"||typeof Ee!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');le[fe]=Ee}this.chat_template=le}this._compiled_template_cache=new Map}getToken(...U){for(const te of U){const le=this._tokenizer_config[te];if(le)if(typeof le=="object"){if(le.__type==="AddedToken")return le.content;throw Error(`Unknown token: ${le}`)}else return le}return null}static async from_pretrained(U,{progress_callback:te=null,config:le=null,cache_dir:fe=null,local_files_only:Ee=!1,revision:We="main",legacy:Xe=null}={}){const Ke=await c(U,{progress_callback:te,config:le,cache_dir:fe,local_files_only:Ee,revision:We,legacy:Xe});return new this(...Ke)}_call(U,{text_pair:te=null,add_special_tokens:le=!0,padding:fe=!1,truncation:Ee=null,max_length:We=null,return_tensor:Xe=!0,return_token_type_ids:Ke=null}={}){const tt=Array.isArray(U);let _t;if(tt){if(U.length===0)throw Error("text array must be non-empty");if(te!==null){if(Array.isArray(te)){if(U.length!==te.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");_t=U.map((Lt,Jt)=>this._encode_plus(Lt,{text_pair:te[Jt],add_special_tokens:le,return_token_type_ids:Ke}))}else _t=U.map(Lt=>this._encode_plus(Lt,{add_special_tokens:le,return_token_type_ids:Ke}))}else{if(U==null)throw Error("text may not be null or undefined");if(Array.isArray(te))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");_t=[this._encode_plus(U,{text_pair:te,add_special_tokens:le,return_token_type_ids:Ke})]}if(We===null?fe==="max_length"?We=this.model_max_length:We=(0,o.max)(_t.map(Lt=>Lt.input_ids.length))[0]:Ee||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),We=Math.min(We,this.model_max_length??1/0),fe||Ee)for(let Lt=0;Lt<_t.length;++Lt)_t[Lt].input_ids.length!==We&&(_t[Lt].input_ids.length>We?Ee&&Dr(_t[Lt],We):fe&&An(_t[Lt],We,Jt=>Jt==="input_ids"?this.pad_token_id:0,this.padding_side));const It={};if(Xe){if(!(fe&&Ee)&&_t.some(Jt=>{var Vt;for(const un of Object.keys(Jt))if(Jt[un].length!==((Vt=_t[0][un])==null?void 0:Vt.length))return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const Lt=[_t.length,_t[0].input_ids.length];for(const Jt of Object.keys(_t[0]))It[Jt]=new a.Tensor("int64",BigInt64Array.from(_t.flatMap(Vt=>Vt[Jt]).map(BigInt)),Lt)}else{for(const Lt of Object.keys(_t[0]))It[Lt]=_t.map(Jt=>Jt[Lt]);if(!tt)for(const Lt of Object.keys(It))It[Lt]=It[Lt][0]}return It}_encode_text(U){if(U===null)return null;const te=this.added_tokens_splitter.split(U);for(let fe=0;fe<te.length;++fe){const Ee=this.added_tokens_map.get(te[fe]);Ee&&(Ee.lstrip&&fe>0&&(te[fe-1]=te[fe-1].trimEnd()),Ee.rstrip&&fe<te.length-1&&(te[fe+1]=te[fe+1].trimStart()))}return te.flatMap((fe,Ee)=>{if(fe.length===0)return[];if(this.added_tokens_map.has(fe))return[fe];if(this.remove_space===!0&&(fe=fe.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(fe=h(fe)),this.normalizer!==null&&(fe=this.normalizer(fe)),fe.length===0)return[];const We=this.pre_tokenizer!==null?this.pre_tokenizer(fe,{section_index:Ee}):[fe];return this.model(We)})}_encode_plus(U,{text_pair:te=null,add_special_tokens:le=!0,return_token_type_ids:fe=null}={}){const{tokens:Ee,token_type_ids:We}=this._tokenize_helper(U,{pair:te,add_special_tokens:le}),Xe=this.model.convert_tokens_to_ids(Ee),Ke={input_ids:Xe,attention_mask:new Array(Xe.length).fill(1)};return(fe??this.return_token_type_ids)&&We&&(Ke.token_type_ids=We),Ke}_tokenize_helper(U,{pair:te=null,add_special_tokens:le=!1}={}){const fe=this._encode_text(U),Ee=this._encode_text(te);return this.post_processor?this.post_processor(fe,Ee,{add_special_tokens:le}):{tokens:(0,s.mergeArrays)(fe??[],Ee??[])}}tokenize(U,{pair:te=null,add_special_tokens:le=!1}={}){return this._tokenize_helper(U,{pair:te,add_special_tokens:le}).tokens}encode(U,{text_pair:te=null,add_special_tokens:le=!0,return_token_type_ids:fe=null}={}){return this._encode_plus(U,{text_pair:te,add_special_tokens:le,return_token_type_ids:fe}).input_ids}batch_decode(U,te={}){return U instanceof a.Tensor&&(U=U.tolist()),U.map(le=>this.decode(le,te))}decode(U,te={}){if(U instanceof a.Tensor&&(U=y(U)),!Array.isArray(U)||U.length===0||!(0,s.isIntegralNumber)(U[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(U,te)}decode_single(U,{skip_special_tokens:te=!1,clean_up_tokenization_spaces:le=null}){let fe=this.model.convert_ids_to_tokens(U);te&&(fe=fe.filter(We=>!this.special_tokens.includes(We)));let Ee=this.decoder?this.decoder(fe):fe.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(Ee=Ee.replaceAll(this.decoder.end_of_word_suffix," "),te&&(Ee=Ee.trim())),(le??this.clean_up_tokenization_spaces)&&(Ee=C(Ee)),Ee}get_chat_template({chat_template:U=null,tools:te=null}={}){if(this.chat_template&&typeof this.chat_template=="object"){const le=this.chat_template;if(U!==null&&Object.hasOwn(le,U))U=le[U];else if(U===null)if(te!==null&&"tool_use"in le)U=le.tool_use;else if("default"in le)U=le.default;else throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(le).sort()}.`)}else if(U===null)if(this.chat_template)U=this.chat_template;else throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");return U}apply_chat_template(U,{tools:te=null,documents:le=null,chat_template:fe=null,add_generation_prompt:Ee=!1,tokenize:We=!0,padding:Xe=!1,truncation:Ke=!1,max_length:tt=null,return_tensor:_t=!0,return_dict:It=!1,tokenizer_kwargs:Lt={},...Jt}={}){if(fe=this.get_chat_template({chat_template:fe,tools:te}),typeof fe!="string")throw Error(`chat_template must be a string, but got ${typeof fe}`);let Vt=this._compiled_template_cache.get(fe);Vt===void 0&&(Vt=new u.Template(fe),this._compiled_template_cache.set(fe,Vt));const un=Object.create(null);for(const jn of Bn){const Vn=this.getToken(jn);Vn&&(un[jn]=Vn)}const tr=Vt.render({messages:U,add_generation_prompt:Ee,tools:te,documents:le,...un,...Jt});if(We){const jn=this._call(tr,{add_special_tokens:!1,padding:Xe,truncation:Ke,max_length:tt,return_tensor:_t,...Lt});return It?jn:jn.input_ids}return tr}}class hs extends ft{constructor(){super(...arguments);ie(this,"return_token_type_ids",!0)}}class br extends ft{constructor(){super(...arguments);ie(this,"return_token_type_ids",!0)}}class Bs extends ft{constructor(){super(...arguments);ie(this,"return_token_type_ids",!0)}}class Gt extends ft{constructor(){super(...arguments);ie(this,"return_token_type_ids",!0)}}class ms extends ft{constructor(){super(...arguments);ie(this,"return_token_type_ids",!0)}}class _s extends ft{constructor(){super(...arguments);ie(this,"return_token_type_ids",!0)}}class Ns extends ft{constructor(){super(...arguments);ie(this,"return_token_type_ids",!0)}}class fn extends ft{constructor(){super(...arguments);ie(this,"return_token_type_ids",!0)}}class Be extends ft{constructor(){super(...arguments);ie(this,"return_token_type_ids",!0)}}class et extends ft{}class it extends ft{}class Yt extends ft{constructor(U,te){super(U,te);ie(this,"return_token_type_ids",!0);console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class Or extends ft{constructor(){super(...arguments);ie(this,"return_token_type_ids",!0)}}class _r extends ft{}class gs extends ft{}class ys extends ft{}class Yr extends ft{constructor(A,U){super(A,U),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(te=>this.languageRegex.test(te)),this.lang_to_token=te=>te}_build_translation_inputs(A,U,te){return lr(this,A,U,te)}}class vs extends Yr{}class ws extends ft{}class Jr extends ft{}const or="";class uo extends ft{constructor(U,te){super(U,te);ie(this,"padding_side","left");this.legacy=te.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new Tt({replacement:or,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(U){if(U===null)return null;if(this.legacy||U.length===0)return super._encode_text(U);let te=super._encode_text(or+U.replaceAll(or," "));return te.length>1&&te[0]===or&&this.special_tokens.includes(te[1])&&(te=te.slice(1)),te}}class ar extends ft{}class Xs extends ft{}class Ys extends ft{}class qn extends ft{}class Mi extends ft{}class co extends ft{}class Tr extends ft{}class po extends ft{}class Zr extends ft{}function lr(me,A,U,te){if(!("language_codes"in me)||!Array.isArray(me.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in me)||!(me.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in me)||typeof me.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const le=te.src_lang,fe=te.tgt_lang;if(!me.language_codes.includes(fe))throw new Error(`Target language code "${fe}" is not valid. Must be one of: {${me.language_codes.join(", ")}}`);if(le!==void 0){if(!me.language_codes.includes(le))throw new Error(`Source language code "${le}" is not valid. Must be one of: {${me.language_codes.join(", ")}}`);for(const Ee of me.post_processor.config.single)if("SpecialToken"in Ee&&me.languageRegex.test(Ee.SpecialToken.id)){Ee.SpecialToken.id=me.lang_to_token(le);break}}return te.forced_bos_token_id=me.model.convert_tokens_to_ids([me.lang_to_token(fe)])[0],me._call(A,U)}class Js extends ft{constructor(A,U){super(A,U),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(te=>this.languageRegex.test(te)),this.lang_to_token=te=>te}_build_translation_inputs(A,U,te){return lr(this,A,U,te)}}class Nn extends ft{constructor(A,U){super(A,U),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(te=>this.languageRegex.test(te)).map(te=>te.slice(2,-2)),this.lang_to_token=te=>`__${te}__`}_build_translation_inputs(A,U,te){return lr(this,A,U,te)}}class Qn extends ft{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(A,{return_timestamps:U=!1,return_language:te=!1,time_precision:le=null,force_full_sequences:fe=!0}={}){if(le===null)throw Error("Must specify time_precision");let Ee=null;const We=U==="word";function Xe(){return{language:Ee,timestamp:[null,null],text:""}}const Ke=[];let tt=Xe(),_t=0;const It=this.timestamp_begin,Jt=It+1500;let Vt=[],un=[],tr=!1,jn=null;const Vn=new Set(this.all_special_ids);for(const Kt of A){const Sn=Kt.tokens,Xn=We?Kt.token_timestamps:null;let ts=null,Lr=It;if("stride"in Kt){const[Dn,tn,xn]=Kt.stride;if(_t-=tn,jn=Dn-xn,tn&&(Lr=tn/le+It),xn)for(let bn=Sn.length-1;bn>=0;--bn){const Tn=Number(Sn[bn]);if(Tn>=It){if(ts!==null&&(Tn-It)*le<jn)break;ts=Tn}}}let Mn=[],zr=[];for(let Dn=0;Dn<Sn.length;++Dn){const tn=Number(Sn[Dn]);if(Vn.has(tn)){const xn=this.decode([tn]),bn=p.WHISPER_LANGUAGE_MAPPING.get(xn.slice(2,-2));if(bn!==void 0){if(Ee!==null&&bn!==Ee&&!U){Vt.push(Mn);const Tn=this.findLongestCommonSequence(Vt)[0],bi=this.decode(Tn);tt.text=bi,Ke.push(tt),Vt=[],Mn=[],tt=Xe()}Ee=tt.language=bn}}else if(tn>=It&&tn<=Jt){const xn=(tn-It)*le+_t,bn=(0,o.round)(xn,2);if(ts!==null&&tn>=ts)tr=!0;else if(tr||Vt.length>0&&tn<Lr)tr=!1;else if(tt.timestamp[0]===null)tt.timestamp[0]=bn;else if(bn!==tt.timestamp[0]){tt.timestamp[1]=bn,Vt.push(Mn),We&&un.push(zr);const[Tn,bi]=this.findLongestCommonSequence(Vt,un),xo=this.decode(Tn);tt.text=xo,We&&(tt.words=this.collateWordTimestamps(Tn,bi,Ee)),Ke.push(tt),Vt=[],Mn=[],un=[],zr=[],tt=Xe()}}else if(Mn.push(tn),We){let xn=(0,o.round)(Xn[Dn]+_t,2),bn;if(Dn+1<Xn.length){bn=(0,o.round)(Xn[Dn+1]+_t,2);const Tn=this.decode([tn]);T.test(Tn)&&(bn=(0,o.round)(Math.min(xn+le,bn),2))}else bn=null;zr.push([xn,bn])}}if("stride"in Kt){const[Dn,tn,xn]=Kt.stride;_t+=Dn-xn}Mn.length>0?(Vt.push(Mn),We&&un.push(zr)):Vt.every(Dn=>Dn.length===0)&&(tt=Xe(),Vt=[],Mn=[],un=[],zr=[])}if(Vt.length>0){if(fe&&U)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[Kt,Sn]=this.findLongestCommonSequence(Vt,un),Xn=this.decode(Kt);tt.text=Xn,We&&(tt.words=this.collateWordTimestamps(Kt,Sn,Ee)),Ke.push(tt)}let en=Object.create(null);const es=Ke.map(Kt=>Kt.text).join("");if(U||te){for(let Kt=0;Kt<Ke.length;++Kt){const Sn=Ke[Kt];U||delete Sn.timestamp,te||delete Sn.language}if(We){const Kt=[];for(const Sn of Ke)for(const Xn of Sn.words)Kt.push(Xn);en={chunks:Kt}}else en={chunks:Ke}}return[es,en]}findLongestCommonSequence(A,U=null){let te=A[0],le=te.length,fe=[];const Ee=Array.isArray(U)&&U.length>0;let We=Ee?[]:null,Xe=Ee?U[0]:null;for(let Ke=1;Ke<A.length;++Ke){const tt=A[Ke];let _t=0,It=[le,le,0,0];const Lt=tt.length;for(let en=1;en<le+Lt;++en){const es=Math.max(0,le-en),Kt=Math.min(le,le+Lt-en),Sn=te.slice(es,Kt),Xn=Math.max(0,en-le),ts=Math.min(Lt,en),Lr=tt.slice(Xn,ts);if(Sn.length!==Lr.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let Mn;Ee?Mn=Sn.filter((tn,xn)=>tn===Lr[xn]&&Xe[es+xn]<=U[Ke][Xn+xn]).length:Mn=Sn.filter((tn,xn)=>tn===Lr[xn]).length;const zr=en/1e4,Dn=Mn/en+zr;Mn>1&&Dn>_t&&(_t=Dn,It=[es,Kt,Xn,ts])}const[Jt,Vt,un,tr]=It,jn=Math.floor((Vt+Jt)/2),Vn=Math.floor((tr+un)/2);fe.push(...te.slice(0,jn)),te=tt.slice(Vn),le=te.length,Ee&&(We.push(...Xe.slice(0,jn)),Xe=U[Ke].slice(Vn))}return fe.push(...te),Ee?(We.push(...Xe),[fe,We]):[fe,[]]}collateWordTimestamps(A,U,te){const[le,fe,Ee]=this.combineTokensIntoWords(A,te),We=[];for(let Xe=0;Xe<le.length;++Xe){const Ke=Ee[Xe];We.push({text:le[Xe],timestamp:[U[Ke.at(0)][0],U[Ke.at(-1)][1]]})}return We}combineTokensIntoWords(A,U,te=`"'([{-`,le=`"'.,!?:)]}`){U=U??"english";let fe,Ee,We;return["chinese","japanese","thai","lao","myanmar"].includes(U)?[fe,Ee,We]=this.splitTokensOnUnicode(A):[fe,Ee,We]=this.splitTokensOnSpaces(A),this.mergePunctuations(fe,Ee,We,te,le)}decode(A,U){let te;return U!=null&&U.decode_with_timestamps?(A instanceof a.Tensor&&(A=y(A)),te=this.decodeWithTimestamps(A,U)):te=super.decode(A,U),te}decodeWithTimestamps(A,U){const te=(U==null?void 0:U.time_precision)??.02,le=Array.from(this.all_special_ids).at(-1)+1;let fe=[[]];for(let Ee of A)if(Ee=Number(Ee),Ee>=le){const We=((Ee-le)*te).toFixed(2);fe.push(`<|${We}|>`),fe.push([])}else fe[fe.length-1].push(Ee);return fe=fe.map(Ee=>typeof Ee=="string"?Ee:super.decode(Ee,U)),fe.join("")}splitTokensOnUnicode(A){const U=this.decode(A,{decode_with_timestamps:!0}),te="",le=[],fe=[],Ee=[];let We=[],Xe=[],Ke=0;for(let tt=0;tt<A.length;++tt){const _t=A[tt];We.push(_t),Xe.push(tt);const It=this.decode(We,{decode_with_timestamps:!0});(!It.includes(te)||U[Ke+It.indexOf(te)]===te)&&(le.push(It),fe.push(We),Ee.push(Xe),We=[],Xe=[],Ke+=It.length)}return[le,fe,Ee]}splitTokensOnSpaces(A){const[U,te,le]=this.splitTokensOnUnicode(A),fe=[],Ee=[],We=[],Xe=new RegExp(`^[${b}]$`,"gu");for(let Ke=0;Ke<U.length;++Ke){const tt=U[Ke],_t=te[Ke],It=le[Ke],Lt=_t[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),Jt=tt.startsWith(" "),Vt=tt.trim(),un=Xe.test(Vt);if(Lt||Jt||un||fe.length===0)fe.push(tt),Ee.push(_t),We.push(It);else{const tr=fe.length-1;fe[tr]+=tt,Ee[tr].push(..._t),We[tr].push(...It)}}return[fe,Ee,We]}mergePunctuations(A,U,te,le,fe){const Ee=structuredClone(A),We=structuredClone(U),Xe=structuredClone(te);let Ke=Ee.length-2,tt=Ee.length-1;for(;Ke>=0;)Ee[Ke].startsWith(" ")&&le.includes(Ee[Ke].trim())?(Ee[tt]=Ee[Ke]+Ee[tt],We[tt]=(0,s.mergeArrays)(We[Ke],We[tt]),Xe[tt]=(0,s.mergeArrays)(Xe[Ke],Xe[tt]),Ee[Ke]="",We[Ke]=[],Xe[Ke]=[]):tt=Ke,--Ke;for(Ke=0,tt=1;tt<Ee.length;)!Ee[Ke].endsWith(" ")&&fe.includes(Ee[tt])?(Ee[Ke]+=Ee[tt],We[Ke]=(0,s.mergeArrays)(We[Ke],We[tt]),Xe[Ke]=(0,s.mergeArrays)(Xe[Ke],Xe[tt]),Ee[tt]="",We[tt]=[],Xe[tt]=[]):Ke=tt,++tt;return[Ee.filter(_t=>_t),We.filter(_t=>_t.length>0),Xe.filter(_t=>_t.length>0)]}}class Fr extends ft{}class fo extends ft{}class ho extends ft{}class mo extends ft{constructor(A,U){super(A,U),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(te=>this.languageRegex.test(te)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(A){if(A===null)return null;const[U,...te]=A.trim().split(this.languageRegex);if(te.length===0)return super._encode_text(U);if(te.length===2){const[le,fe]=te;return this.supported_language_codes.includes(le)||console.warn(`Unsupported language code "${le}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,s.mergeArrays)([le],super._encode_text(fe))}}}class _o extends ft{}class go extends ft{}class js extends ft{}class yo extends ft{}class xi extends ft{}class vo extends ft{constructor(A,U){super(A,U),this.decoder=new pt({})}}class wo extends ft{}class Vs extends ft{}class Mo{static async from_pretrained(A,{progress_callback:U=null,config:te=null,cache_dir:le=null,local_files_only:fe=!1,revision:Ee="main",legacy:We=null}={}){var It;const[Xe,Ke]=await c(A,{progress_callback:U,config:te,cache_dir:le,local_files_only:fe,revision:Ee,legacy:We}),tt=((It=Ke.tokenizer_class)==null?void 0:It.replace(/Fast$/,""))??"PreTrainedTokenizer";let _t=this.TOKENIZER_CLASS_MAPPING[tt];return _t||(console.warn(`Unknown tokenizer class "${tt}", attempting to construct from base class.`),_t=ft),new _t(Xe,Ke)}}ie(Mo,"TOKENIZER_CLASS_MAPPING",{T5Tokenizer:_r,DistilBertTokenizer:et,CamembertTokenizer:it,DebertaTokenizer:ms,DebertaV2Tokenizer:_s,BertTokenizer:hs,HerbertTokenizer:Ns,ConvBertTokenizer:fn,RoFormerTokenizer:Be,XLMTokenizer:Yt,ElectraTokenizer:Or,MobileBertTokenizer:Bs,SqueezeBertTokenizer:Gt,AlbertTokenizer:br,GPT2Tokenizer:gs,BartTokenizer:ys,MBartTokenizer:Yr,MBart50Tokenizer:vs,RobertaTokenizer:ws,WhisperTokenizer:Qn,CodeGenTokenizer:Fr,CLIPTokenizer:fo,SiglipTokenizer:ho,MarianTokenizer:mo,BloomTokenizer:Jr,NllbTokenizer:Js,M2M100Tokenizer:Nn,LlamaTokenizer:uo,CodeLlamaTokenizer:ar,XLMRobertaTokenizer:Xs,MPNetTokenizer:Ys,FalconTokenizer:qn,GPTNeoXTokenizer:Mi,EsmTokenizer:co,Wav2Vec2CTCTokenizer:_o,BlenderbotTokenizer:go,BlenderbotSmallTokenizer:js,SpeechT5Tokenizer:yo,NougatTokenizer:xi,VitsTokenizer:vo,Qwen2Tokenizer:Tr,GemmaTokenizer:po,Grok1Tokenizer:Zr,CohereTokenizer:wo,MgpstrTokenizer:Vs,PreTrainedTokenizer:ft})},"./src/utils/audio.js":(e,t,n)=>{n.r(t),n.d(t,{RawAudio:()=>H,hamming:()=>d,hanning:()=>c,mel_filter_bank:()=>w,read_audio:()=>u,spectrogram:()=>S,window_function:()=>$});var r=n("./src/utils/hub.js"),s=n("./src/utils/maths.js"),i=n("./src/utils/core.js"),o=n("./src/env.js"),a=n("?7a2c"),l=n("./src/utils/tensor.js");async function u(N,J){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const q=await(await(0,r.getFile)(N)).arrayBuffer(),X=new AudioContext({sampleRate:J});typeof J>"u"&&console.warn(`No sampling rate provided, using default of ${X.sampleRate}Hz.`);const Y=await X.decodeAudioData(q);let K;if(Y.numberOfChannels===2){const oe=Math.sqrt(2),se=Y.getChannelData(0),F=Y.getChannelData(1);K=new Float32Array(se.length);for(let I=0;I<Y.length;++I)K[I]=oe*(se[I]+F[I])/2}else K=Y.getChannelData(0);return K}function p(N,J){if(N<1)return new Float64Array;if(N===1)return new Float64Array([1]);const q=1-J,X=2*Math.PI/(N-1),Y=new Float64Array(N);for(let K=0;K<N;++K)Y[K]=J-q*Math.cos(K*X);return Y}function c(N){return p(N,.5)}function d(N){return p(N,.54)}const f={htk:N=>2595*Math.log10(1+N/700),kaldi:N=>1127*Math.log(1+N/700),slaney:(N,J=1e3,q=15,X=27/Math.log(6.4))=>N>=J?q+Math.log(N/J)*X:3*N/200};function m(N,J="htk"){const q=f[J];if(!q)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof N=="number"?q(N):N.map(X=>q(X))}const y={htk:N=>700*(10**(N/2595)-1),kaldi:N=>700*(Math.exp(N/1127)-1),slaney:(N,J=1e3,q=15,X=Math.log(6.4)/27)=>N>=q?J*Math.exp(X*(N-q)):200*N/3};function C(N,J="htk"){const q=y[J];if(!q)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof N=="number"?q(N):N.map(X=>q(X))}function _(N,J){const q=Float64Array.from({length:J.length-1},(oe,se)=>J[se+1]-J[se]),X=Array.from({length:N.length},()=>new Array(J.length));for(let oe=0;oe<N.length;++oe){const se=X[oe];for(let F=0;F<J.length;++F)se[F]=J[F]-N[oe]}const Y=J.length-2,K=Array.from({length:Y},()=>new Array(N.length));for(let oe=0;oe<N.length;++oe){const se=X[oe];for(let F=0;F<Y;++F){const I=-se[F]/q[F],V=se[F+2]/q[F+1];K[F][oe]=Math.max(0,Math.min(I,V))}}return K}function h(N,J,q){const X=(J-N)/(q-1);return Float64Array.from({length:q},(Y,K)=>N+X*K)}function w(N,J,q,X,Y,K=null,oe="htk",se=!1){if(K!==null&&K!=="slaney")throw new Error('norm must be one of null or "slaney"');if(N<2)throw new Error(`Require num_frequency_bins: ${N} >= 2`);if(q>X)throw new Error(`Require min_frequency: ${q} <= max_frequency: ${X}`);const F=m(q,oe),I=m(X,oe),V=h(F,I,J+2);let ee=C(V,oe),pe;if(se){const de=Y/((N-1)*2);pe=m(Float64Array.from({length:N},(Se,Re)=>Re*de),oe),ee=V}else pe=h(0,Math.floor(Y/2),N);const Z=_(pe,ee);if(K!==null&&K==="slaney")for(let de=0;de<J;++de){const Se=Z[de],Re=2/(ee[de+2]-ee[de]);for(let ye=0;ye<N;++ye)Se[ye]*=Re}return Z}function M(N,J,q){const X=new N.constructor(N.length+J+q),Y=N.length-1;for(let K=0;K<N.length;++K)X[J+K]=N[K];for(let K=1;K<=J;++K)X[J-K]=N[(0,i.calculateReflectOffset)(K,Y)];for(let K=1;K<=q;++K)X[Y+J+K]=N[(0,i.calculateReflectOffset)(Y-K,Y)];return X}function x(N,J,q,X,Y){if(q<=0)throw new Error("reference must be greater than zero");if(X<=0)throw new Error("min_value must be greater than zero");q=Math.max(X,q);const K=Math.log10(q);for(let oe=0;oe<N.length;++oe)N[oe]=J*Math.log10(Math.max(X,N[oe])-K);if(Y!==null){if(Y<=0)throw new Error("db_range must be greater than zero");const oe=(0,s.max)(N)[0]-Y;for(let se=0;se<N.length;++se)N[se]=Math.max(N[se],oe)}return N}function b(N,J=1,q=1e-5,X=null){return x(N,20,J,q,X)}function T(N,J=1,q=1e-10,X=null){return x(N,10,J,q,X)}async function S(N,J,q,X,{fft_length:Y=null,power:K=1,center:oe=!0,pad_mode:se="reflect",onesided:F=!0,preemphasis:I=null,mel_filters:V=null,mel_floor:ee=1e-10,log_mel:pe=null,reference:Z=1,min_value:de=1e-10,db_range:Se=null,remove_dc_offset:Re=null,min_num_frames:ye=null,max_num_frames:Q=null,do_pad:j=!0,transpose:he=!1}={}){const be=J.length;if(Y===null&&(Y=q),q>Y)throw Error(`frame_length (${q}) may not be larger than fft_length (${Y})`);if(be!==q)throw new Error(`Length of the window (${be}) must equal frame_length (${q})`);if(X<=0)throw new Error("hop_length must be greater than zero");if(K===null&&V!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(oe){if(se!=="reflect")throw new Error(`pad_mode="${se}" not implemented yet.`);const ve=Math.floor((Y-1)/2)+1;N=M(N,ve,ve)}let we=Math.floor(1+Math.floor((N.length-q)/X));ye!==null&&we<ye&&(we=ye);const Ce=F?Math.floor(Y/2)+1:Y;let De=we,Oe=we;Q!==null&&(Q>we?j&&(Oe=Q):Oe=De=Q);const Le=new s.FFT(Y),je=new Float64Array(Y),L=new Float64Array(Le.outputBufferSize),re=new Float32Array(Ce*Oe);for(let ve=0;ve<De;++ve){const Te=ve*X,Ae=Math.min(N.length-Te,q);Ae!==q&&je.fill(0,0,q);for(let $e=0;$e<Ae;++$e)je[$e]=N[Te+$e];if(Re){let $e=0;for(let Je=0;Je<Ae;++Je)$e+=je[Je];const Ve=$e/Ae;for(let Je=0;Je<Ae;++Je)je[Je]-=Ve}if(I!==null){for(let $e=Ae-1;$e>=1;--$e)je[$e]-=I*je[$e-1];je[0]*=1-I}for(let $e=0;$e<J.length;++$e)je[$e]*=J[$e];Le.realTransform(L,je);for(let $e=0;$e<Ce;++$e){const Ve=$e<<1;re[$e*Oe+ve]=L[Ve]**2+L[Ve+1]**2}}if(K!==null&&K!==2){const ve=2/K;for(let Te=0;Te<re.length;++Te)re[Te]**=ve}const R=V.length;let ne=await(0,l.matmul)(new l.Tensor("float32",V.flat(),[R,Ce]),new l.Tensor("float32",re,[Ce,Oe]));he&&(ne=ne.transpose(1,0));const ue=ne.data;for(let ve=0;ve<ue.length;++ve)ue[ve]=Math.max(ee,ue[ve]);if(K!==null&&pe!==null){const ve=Math.min(ue.length,De*R);switch(pe){case"log":for(let Te=0;Te<ve;++Te)ue[Te]=Math.log(ue[Te]);break;case"log10":for(let Te=0;Te<ve;++Te)ue[Te]=Math.log10(ue[Te]);break;case"dB":if(K===1)b(ue,Z,de,Se);else if(K===2)T(ue,Z,de,Se);else throw new Error(`Cannot use log_mel option '${pe}' with power ${K}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${pe}'`)}}return ne}function $(N,J,{periodic:q=!0,frame_length:X=null,center:Y=!0}={}){const K=q?N+1:N;let oe;switch(J){case"boxcar":oe=new Float64Array(K).fill(1);break;case"hann":case"hann_window":oe=c(K);break;case"hamming":oe=d(K);break;case"povey":oe=c(K).map(se=>Math.pow(se,.85));break;default:throw new Error(`Unknown window type ${J}.`)}if(q&&(oe=oe.subarray(0,N)),X===null)return oe;if(N>X)throw new Error(`Length of the window (${N}) may not be larger than frame_length (${X})`);return oe}function O(N,J){let q=44;const X=new ArrayBuffer(q+N.length*4),Y=new DataView(X);G(Y,0,"RIFF"),Y.setUint32(4,36+N.length*4,!0),G(Y,8,"WAVE"),G(Y,12,"fmt "),Y.setUint32(16,16,!0),Y.setUint16(20,3,!0),Y.setUint16(22,1,!0),Y.setUint32(24,J,!0),Y.setUint32(28,J*4,!0),Y.setUint16(32,4,!0),Y.setUint16(34,32,!0),G(Y,36,"data"),Y.setUint32(40,N.length*4,!0);for(let K=0;K<N.length;++K,q+=4)Y.setFloat32(q,N[K],!0);return X}function G(N,J,q){for(let X=0;X<q.length;++X)N.setUint8(J+X,q.charCodeAt(X))}class H{constructor(J,q){this.audio=J,this.sampling_rate=q}toWav(){return O(this.audio,this.sampling_rate)}toBlob(){const J=this.toWav();return new Blob([J],{type:"audio/wav"})}async save(J){let q;if(o.apis.IS_BROWSER_ENV){if(o.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save a file from a Web Worker.");q=i.saveBlob}else if(o.apis.IS_FS_AVAILABLE)q=async(X,Y)=>{let K=await Y.arrayBuffer();a.writeFileSync(X,Buffer.from(K))};else throw new Error("Unable to save because filesystem is disabled in this environment.");await q(J,this.toBlob())}}},"./src/utils/constants.js":(e,t,n)=>{n.r(t),n.d(t,{CHAT_TEMPLATE_NAME:()=>l,CONFIG_NAME:()=>s,FEATURE_EXTRACTOR_NAME:()=>i,GENERATION_CONFIG_NAME:()=>u,GITHUB_ISSUE_URL:()=>r,IMAGE_PROCESSOR_NAME:()=>o,PROCESSOR_NAME:()=>a});const r="https://github.com/huggingface/transformers.js/issues/new/choose",s="config.json",i="preprocessor_config.json",o=i,a="processor_config.json",l="chat_template.json",u="generation_config.json"},"./src/utils/core.js":(e,t,n)=>{n.r(t),n.d(t,{calculateDimensions:()=>u,calculateReflectOffset:()=>f,count:()=>_,dispatchCallback:()=>r,escapeRegExp:()=>i,isIntegralNumber:()=>a,isNullishDimension:()=>l,isTypedArray:()=>o,len:()=>C,mergeArrays:()=>c,pick:()=>y,pop:()=>p,product:()=>d,reverseDictionary:()=>s,saveBlob:()=>m});function r(h,w){h&&h(w)}function s(h){return Object.fromEntries(Object.entries(h).map(([w,M])=>[M,w]))}function i(h){return h.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function o(h){var w,M,x;return((x=(M=(w=h==null?void 0:h.prototype)==null?void 0:w.__proto__)==null?void 0:M.constructor)==null?void 0:x.name)==="TypedArray"}function a(h){return Number.isInteger(h)||typeof h=="bigint"}function l(h){return h==null||h===-1}function u(h){const w=[];let M=h;for(;Array.isArray(M);)w.push(M.length),M=M[0];return w}function p(h,w,M=void 0){const x=h[w];if(x!==void 0)return delete h[w],x;if(M===void 0)throw Error(`Key ${w} does not exist in object.`);return M}function c(...h){return Array.prototype.concat.apply([],h)}function d(...h){return h.reduce((w,M)=>w.flatMap(x=>M.map(b=>[x,b])))}function f(h,w){return Math.abs((h+w)%(2*w)-w)}function m(h,w){const M=URL.createObjectURL(w),x=document.createElement("a");x.href=M,x.download=h,x.click(),x.remove(),URL.revokeObjectURL(M)}function y(h,w){return Object.assign({},...w.map(M=>{if(h[M]!==void 0)return{[M]:h[M]}}))}function C(h){let w=0;for(const M of h)++w;return w}function _(h,w){let M=0;for(const x of h)x===w&&++M;return M}},"./src/utils/data-structures.js":(e,t,n)=>{n.r(t),n.d(t,{CharTrie:()=>s,DictionarySplitter:()=>l,LRUCache:()=>u,PriorityQueue:()=>r,TokenLattice:()=>o});class r{constructor(c=(f,m)=>f>m,d=1/0){this._heap=[],this._comparator=c,this._maxSize=d}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...c){return this.extend(c)}extend(c){for(const d of c)if(this.size<this._maxSize)this._heap.push(d),this._siftUp();else{const f=this._smallest();this._comparator(d,this._heap[f])&&(this._heap[f]=d,this._siftUpFrom(f))}return this.size}pop(){const c=this.peek(),d=this.size-1;return d>0&&this._swap(0,d),this._heap.pop(),this._siftDown(),c}replace(c){const d=this.peek();return this._heap[0]=c,this._siftDown(),d}_parent(c){return(c+1>>>1)-1}_left(c){return(c<<1)+1}_right(c){return c+1<<1}_greater(c,d){return this._comparator(this._heap[c],this._heap[d])}_swap(c,d){const f=this._heap[c];this._heap[c]=this._heap[d],this._heap[d]=f}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(c){for(;c>0&&this._greater(c,this._parent(c));)this._swap(c,this._parent(c)),c=this._parent(c)}_siftDown(){let c=0;for(;this._left(c)<this.size&&this._greater(this._left(c),c)||this._right(c)<this.size&&this._greater(this._right(c),c);){const d=this._right(c)<this.size&&this._greater(this._right(c),this._left(c))?this._right(c):this._left(c);this._swap(c,d),c=d}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class s{constructor(){this.root=i.default()}extend(c){for(const d of c)this.push(d)}push(c){let d=this.root;for(const f of c){let m=d.children.get(f);m===void 0&&(m=i.default(),d.children.set(f,m)),d=m}d.isLeaf=!0}*commonPrefixSearch(c){let d=this.root;if(d===void 0)return;let f="";for(const m of c){if(f+=m,d=d.children.get(m),d===void 0)return;d.isLeaf&&(yield f)}}}class i{constructor(c,d){this.isLeaf=c,this.children=d}static default(){return new i(!1,new Map)}}class o{constructor(c,d,f){this.chars=Array.from(c),this.len=this.chars.length,this.bosTokenId=d,this.eosTokenId=f,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const m=new a(this.bosTokenId,0,0,0,0),y=new a(this.eosTokenId,1,this.len,0,0);this.nodes.push(m.clone()),this.nodes.push(y.clone()),this.beginNodes[this.len].push(y),this.endNodes[0].push(m)}insert(c,d,f,m){const y=this.nodes.length,C=new a(m,y,c,d,f);this.beginNodes[c].push(C),this.endNodes[c+d].push(C),this.nodes.push(C)}viterbi(){const c=this.len;let d=0;for(;d<=c;){if(this.beginNodes[d].length==0)return[];for(let _ of this.beginNodes[d]){_.prev=null;let h=0,w=null;for(let M of this.endNodes[d]){const x=M.backtraceScore+_.score;(w===null||x>h)&&(w=M.clone(),h=x)}if(w!==null)_.prev=w,_.backtraceScore=h;else return[]}++d}const f=[],y=this.beginNodes[c][0].prev;if(y===null)return[];let C=y.clone();for(;C.prev!==null;)f.push(C.clone()),C=C.clone().prev.clone();return f.reverse(),f}piece(c){return this.chars.slice(c.pos,c.pos+c.length).join("")}tokens(){return this.viterbi().map(d=>this.piece(d))}tokenIds(){return this.viterbi().map(d=>d.tokenId)}}class a{constructor(c,d,f,m,y){this.tokenId=c,this.nodeId=d,this.pos=f,this.length=m,this.score=y,this.prev=null,this.backtraceScore=0}clone(){const c=new a(this.tokenId,this.nodeId,this.pos,this.length,this.score);return c.prev=this.prev,c.backtraceScore=this.backtraceScore,c}}class l{constructor(c){this.trie=this._buildTrie(c)}_buildTrie(c){var f;const d=Object.create(null);for(const m of c){let y=d;for(let C=0;C<m.length;++C)y=y[f=m[C]]??(y[f]=Object.create(null));y.end=m}return d}split(c){const d=[],f=c.length;let m=0,y=0;for(;y<f;){let C=this.trie,_=null,h=y;for(;h<f&&(C=C[c[h]]);)C.end&&(_=C.end),++h;_?(y>m&&d.push(c.slice(m,y)),d.push(_),y+=_.length,m=y):++y}return m<f&&d.push(c.slice(m)),d}}class u{constructor(c){this.capacity=c,this.cache=new Map}get(c){if(!this.cache.has(c))return;const d=this.cache.get(c);return this.cache.delete(c),this.cache.set(c,d),d}put(c,d){this.cache.has(c)&&this.cache.delete(c),this.cache.set(c,d),this.cache.size>this.capacity&&this.cache.delete(this.cache.keys().next().value)}clear(){this.cache.clear()}}},"./src/utils/devices.js":(e,t,n)=>{n.r(t),n.d(t,{DEVICE_TYPES:()=>r});const r=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})},"./src/utils/dtypes.js":(e,t,n)=>{n.r(t),n.d(t,{DATA_TYPES:()=>o,DEFAULT_DEVICE_DTYPE_MAPPING:()=>a,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>l,isWebGpuFp16Supported:()=>i});var r=n("./src/env.js"),s=n("./src/utils/devices.js");const i=function(){let u;return async function(){if(u===void 0)if(!r.apis.IS_WEBGPU_AVAILABLE)u=!1;else try{u=(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{u=!1}return u}}(),o=Object.freeze({auto:"auto",fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),a=Object.freeze({[s.DEVICE_TYPES.wasm]:o.q8}),l=Object.freeze({[o.fp32]:"",[o.fp16]:"_fp16",[o.int8]:"_int8",[o.uint8]:"_uint8",[o.q8]:"_quantized",[o.q4]:"_q4",[o.q4f16]:"_q4f16",[o.bnb4]:"_bnb4"})},"./src/utils/generic.js":(e,t,n)=>{n.r(t),n.d(t,{Callable:()=>r});const r=class{constructor(){let s=function(...i){return s._call(...i)};return Object.setPrototypeOf(s,new.target.prototype)}_call(...s){throw Error("Must implement _call method in subclass")}}},"./src/utils/hub.js":(e,t,n)=>{n.r(t),n.d(t,{MAX_EXTERNAL_DATA_CHUNKS:()=>a,getFile:()=>f,getModelFile:()=>h,getModelJSON:()=>w});var r=n("?7a2c"),s=n("?a42a"),i=n("./src/env.js"),o=n("./src/utils/core.js");const a=100,l={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class u{constructor(T){if(this.filePath=T,this.headers=new Headers,this.exists=r.existsSync(T),this.exists){this.status=200,this.statusText="OK";let S=r.statSync(T);this.headers.set("content-length",S.size.toString()),this.updateContentType();const $=r.createReadStream(T);this.body=new ReadableStream({start(O){$.on("data",G=>O.enqueue(G)),$.on("end",()=>O.close()),$.on("error",G=>O.error(G))},cancel(){$.destroy()}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const T=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",l[T]??"application/octet-stream")}clone(){let T=new u(this.filePath);return T.exists=this.exists,T.status=this.status,T.statusText=this.statusText,T.headers=new Headers(this.headers),T}async arrayBuffer(){return(await r.promises.readFile(this.filePath)).buffer}async blob(){const T=await r.promises.readFile(this.filePath);return new Blob([T],{type:this.headers.get("content-type")})}async text(){return await r.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function p(b,T=null,S=null){let $;try{$=new URL(b)}catch{return!1}return!(T&&!T.includes($.protocol)||S&&!S.includes($.hostname))}const c=/^(\b[\w\-.]+\b\/)?\b[\w\-.]{1,96}\b$/;function d(b){return!(!c.test(b)||b.includes("..")||b.includes("--")||b.endsWith(".git")||b.endsWith(".ipynb"))}async function f(b){var T;if(i.env.useFS&&!p(b,["http:","https:","blob:"]))return new u(b.toString());if(typeof process<"u"&&((T=process==null?void 0:process.release)==null?void 0:T.name)==="node"){const S=!!(ri!=null&&ri.TESTING_REMOTELY),$=i.env.version,O=new Headers;if(O.set("User-Agent",`transformers.js/${$}; is_ci/${S};`),p(b,["http:","https:"],["huggingface.co","hf.co"])){const H=(ri==null?void 0:ri.HF_TOKEN)??(ri==null?void 0:ri.HF_ACCESS_TOKEN);H&&O.set("Authorization",`Bearer ${H}`)}return fetch(b,{headers:O})}else return fetch(b)}const m={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function y(b,T,S){if(!S)return null;const $=m[b]??`Error (${b}) occurred while trying to load file`;throw Error(`${$}: "${T}".`)}class C{constructor(T){this.path=T}async match(T){let S=s.join(this.path,T),$=new u(S);if($.exists)return $}async put(T,S,$=void 0){let O=s.join(this.path,T);try{const G=S.headers.get("Content-Length"),H=parseInt(G??"0");let N=0;await r.promises.mkdir(s.dirname(O),{recursive:!0});const J=r.createWriteStream(O),q=S.body.getReader();for(;;){const{done:X,value:Y}=await q.read();if(X)break;await new Promise((oe,se)=>{J.write(Y,F=>{if(F){se(F);return}oe()})}),N+=Y.length;const K=H?N/H*100:0;$==null||$({progress:K,loaded:N,total:H})}J.close()}catch(G){try{await r.promises.unlink(O)}catch{}throw G}}}async function _(b,...T){for(let S of T)try{let $=await b.match(S);if($)return $}catch{continue}}async function h(b,T,S=!0,$={},O=!1){if(!i.env.allowLocalModels){if($.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!i.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}(0,o.dispatchCallback)($.progress_callback,{status:"initiate",name:b,file:T});let G;if(!G&&i.env.useCustomCache){if(!i.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!i.env.customCache.match||!i.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");G=i.env.customCache}if(!G&&i.env.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{G=await caches.open("transformers-cache")}catch(ee){console.warn("An error occurred while opening the browser cache:",ee)}}if(!G&&i.env.useFSCache){if(!i.apis.IS_FS_AVAILABLE)throw Error("File System Cache is not available in this environment.");G=new C($.cache_dir??i.env.cacheDir)}const H=$.revision??"main",N=x(b,T),J=d(b),q=J?x(i.env.localModelPath,N):N,X=x(i.env.remoteHost,i.env.remotePathTemplate.replaceAll("{model}",b).replaceAll("{revision}",encodeURIComponent(H)),T);let Y;const K=G instanceof C?H==="main"?N:x(b,H,T):X;let oe=!1,se;G&&(se=await _(G,q,K));const F=se!==void 0;if(se===void 0){if(i.env.allowLocalModels)if(p(N,["http:","https:"])){if($.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${N}.`);if(!i.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${N}.`)}else try{se=await f(q),Y=q}catch(pe){console.warn(`Unable to load from local path "${q}": "${pe}"`)}if(se===void 0||se.status===404){if($.local_files_only||!i.env.allowRemoteModels){if(S)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${q}".`);return null}if(!J)throw Error(`Local file missing at "${q}" and download aborted due to invalid model ID "${b}".`);if(se=await f(X),se.status!==200)return y(se.status,X,S);Y=K}oe=G&&typeof Response<"u"&&se instanceof Response&&se.status===200}(0,o.dispatchCallback)($.progress_callback,{status:"download",name:b,file:T});let I;if(!(i.apis.IS_NODE_ENV&&O)){let ee;$.progress_callback?F&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(ee=new Uint8Array(await se.arrayBuffer()),(0,o.dispatchCallback)($.progress_callback,{status:"progress",name:b,file:T,progress:100,loaded:ee.length,total:ee.length})):ee=await M(se,pe=>{(0,o.dispatchCallback)($.progress_callback,{status:"progress",name:b,file:T,...pe})}):ee=new Uint8Array(await se.arrayBuffer()),I=ee}if(oe&&Y&&await G.match(Y)===void 0&&(I?await G.put(Y,new Response(I,{headers:se.headers})).catch(ee=>{console.warn(`Unable to add response to browser cache: ${ee}.`)}):await G.put(Y,se,$.progress_callback)),(0,o.dispatchCallback)($.progress_callback,{status:"done",name:b,file:T}),I){if(!i.apis.IS_NODE_ENV&&O)throw new Error("Cannot return path in a browser environment.");return I}if(se instanceof u)return se.filePath;const V=await(G==null?void 0:G.match(Y));if(V instanceof u)return V.filePath;if(V instanceof Response)return new Uint8Array(await V.arrayBuffer());if(typeof V=="string")return V;throw new Error("Unable to get model file path or buffer.")}async function w(b,T,S=!0,$={}){const O=await h(b,T,S,$,!1);if(O===null)return{};const H=new TextDecoder("utf-8").decode(O);return JSON.parse(H)}async function M(b,T){const S=b.headers.get("Content-Length");S===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let $=parseInt(S??"0"),O=new Uint8Array($),G=0;const H=b.body.getReader();async function N(){const{done:J,value:q}=await H.read();if(J)return;const X=G+q.length;if(X>$){$=X;const K=new Uint8Array($);K.set(O),O=K}O.set(q,G),G=X;const Y=G/$*100;return T({progress:Y,loaded:G,total:$}),N()}return await N(),O}function x(...b){return b=b.map((T,S)=>(S&&(T=T.replace(new RegExp("^/"),"")),S!==b.length-1&&(T=T.replace(new RegExp("/$"),"")),T)),b.join("/")}},"./src/utils/image.js":(e,t,n)=>{n.r(t),n.d(t,{RawImage:()=>m,load_image:()=>y});var r=n("./src/utils/core.js"),s=n("./src/utils/hub.js"),i=n("./src/env.js"),o=n("./src/utils/tensor.js"),a=n("?2b25");let l,u,p;const c=i.apis.IS_BROWSER_ENV||i.apis.IS_WEBWORKER_ENV;if(c)l=(C,_)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(C,_)},p=self.createImageBitmap,u=self.ImageData;else if(a)p=async C=>{const h=(await C.metadata()).channels,{data:w,info:M}=await C.rotate().raw().toBuffer({resolveWithObject:!0}),x=new m(new Uint8ClampedArray(w),M.width,M.height,M.channels);return h!==void 0&&h!==M.channels&&x.convert(h),x};else throw new Error("Unable to load image processing library.");const d={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},f=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class m{constructor(_,h,w,M){this.data=_,this.width=h,this.height=w,this.channels=M}get size(){return[this.width,this.height]}static async read(_){if(_ instanceof m)return _;if(typeof _=="string"||_ instanceof URL)return await this.fromURL(_);if(_ instanceof Blob)return await this.fromBlob(_);if(typeof HTMLCanvasElement<"u"&&_ instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&_ instanceof OffscreenCanvas)return this.fromCanvas(_);throw new Error(`Unsupported input type: ${typeof _}`)}static fromCanvas(_){if(!c)throw new Error("fromCanvas() is only supported in browser environments.");const w=_.getContext("2d").getImageData(0,0,_.width,_.height).data;return new m(w,_.width,_.height,4)}static async fromURL(_){const h=await(0,s.getFile)(_);if(h.status!==200)throw new Error(`Unable to read image from "${_}" (${h.status} ${h.statusText})`);const w=await h.blob();return this.fromBlob(w)}static async fromBlob(_){if(c){const h=await p(_),w=l(h.width,h.height).getContext("2d");return w.drawImage(h,0,0),new this(w.getImageData(0,0,h.width,h.height).data,h.width,h.height,4)}else{const h=a(await _.arrayBuffer());return await p(h)}}static fromTensor(_,h="CHW"){if(_.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${_.dims.length} dimensions.`);if(h==="CHW")_=_.transpose(1,2,0);else if(h!=="HWC")throw new Error(`Unsupported channel format: ${h}`);if(!(_.data instanceof Uint8ClampedArray||_.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${_.type}`);switch(_.dims[2]){case 1:case 2:case 3:case 4:return new m(_.data,_.dims[1],_.dims[0],_.dims[2]);default:throw new Error(`Unsupported number of channels: ${_.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const _=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let h=0,w=0;h<this.data.length;h+=this.channels){const M=this.data[h],x=this.data[h+1],b=this.data[h+2];_[w++]=Math.round(.2989*M+.587*x+.114*b)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(_,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const _=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let h=0,w=0;h<this.data.length;++h)_[w++]=this.data[h],_[w++]=this.data[h],_[w++]=this.data[h];break;case 4:for(let h=0,w=0;h<this.data.length;h+=4)_[w++]=this.data[h],_[w++]=this.data[h+1],_[w++]=this.data[h+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(_,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const _=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let h=0,w=0;h<this.data.length;++h)_[w++]=this.data[h],_[w++]=this.data[h],_[w++]=this.data[h],_[w++]=255;break;case 3:for(let h=0,w=0;h<this.data.length;h+=3)_[w++]=this.data[h],_[w++]=this.data[h+1],_[w++]=this.data[h+2],_[w++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(_,this.width,this.height,4)}putAlpha(_){if(_.width!==this.width||_.height!==this.height)throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${_.width}x${_.height}`);if(_.channels!==1)throw new Error(`Expected mask to have 1 channel, but got ${_.channels}`);const h=this.data,w=_.data,M=this.width*this.height;if(this.channels===3){const x=new Uint8ClampedArray(M*4);for(let b=0,T=0,S=0;b<M;++b)x[S++]=h[T++],x[S++]=h[T++],x[S++]=h[T++],x[S++]=w[b];return this._update(x,this.width,this.height,4)}else if(this.channels===4){for(let x=0;x<M;++x)h[4*x+3]=w[x];return this}throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`)}async resize(_,h,{resample:w=2}={}){if(this.width===_&&this.height===h)return this;let M=d[w]??w;const x=(0,r.isNullishDimension)(_),b=(0,r.isNullishDimension)(h);if(x&&b)return this;if(x?_=h/this.height*this.width:b&&(h=_/this.width*this.height),c){const T=this.channels,S=this.toCanvas(),$=l(_,h).getContext("2d");return $.drawImage(S,0,0,_,h),new m($.getImageData(0,0,_,h).data,_,h,4).convert(T)}else{let T=this.toSharp();switch(M){case"box":case"hamming":(M==="box"||M==="hamming")&&(console.warn(`Resampling method ${M} is not yet supported. Using bilinear instead.`),M="bilinear");case"nearest":case"bilinear":case"bicubic":T=T.affine([_/this.width,0,0,h/this.height],{interpolator:M});break;case"lanczos":T=T.resize({width:_,height:h,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${M} is not supported.`)}return await p(T)}}async pad([_,h,w,M]){if(_=Math.max(_,0),h=Math.max(h,0),w=Math.max(w,0),M=Math.max(M,0),_===0&&h===0&&w===0&&M===0)return this;if(c){const x=this.channels,b=this.toCanvas(),T=this.width+_+h,S=this.height+w+M,$=l(T,S).getContext("2d");return $.drawImage(b,0,0,this.width,this.height,_,w,this.width,this.height),new m($.getImageData(0,0,T,S).data,T,S,4).convert(x)}else{const x=this.toSharp().extend({left:_,right:h,top:w,bottom:M});return await p(x)}}async crop([_,h,w,M]){if(_=Math.max(_,0),h=Math.max(h,0),w=Math.min(w,this.width-1),M=Math.min(M,this.height-1),_===0&&h===0&&w===this.width-1&&M===this.height-1)return this;const x=w-_+1,b=M-h+1;if(c){const T=this.channels,S=this.toCanvas(),$=l(x,b).getContext("2d");return $.drawImage(S,_,h,x,b,0,0,x,b),new m($.getImageData(0,0,x,b).data,x,b,4).convert(T)}else{const T=this.toSharp().extract({left:_,top:h,width:x,height:b});return await p(T)}}async center_crop(_,h){if(this.width===_&&this.height===h)return this;const w=(this.width-_)/2,M=(this.height-h)/2;if(c){const x=this.channels,b=this.toCanvas(),T=l(_,h).getContext("2d");let S=0,$=0,O=0,G=0;return w>=0?S=w:O=-w,M>=0?$=M:G=-M,T.drawImage(b,S,$,_,h,O,G,_,h),new m(T.getImageData(0,0,_,h).data,_,h,4).convert(x)}else{let x=this.toSharp();if(w>=0&&M>=0)x=x.extract({left:Math.floor(w),top:Math.floor(M),width:_,height:h});else if(w<=0&&M<=0){const b=Math.floor(-M),T=Math.floor(-w);x=x.extend({top:b,left:T,right:_-this.width-T,bottom:h-this.height-b})}else{let b=[0,0],T=0;M<0?(b[0]=Math.floor(-M),b[1]=h-this.height-b[0]):T=Math.floor(M);let S=[0,0],$=0;w<0?(S[0]=Math.floor(-w),S[1]=_-this.width-S[0]):$=Math.floor(w),x=x.extend({top:b[0],bottom:b[1],left:S[0],right:S[1]}).extract({left:$,top:T,width:_,height:h})}return await p(x)}}async toBlob(_="image/png",h=1){if(!c)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:_,quality:h})}toTensor(_="CHW"){let h=new o.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(_!=="HWC")if(_==="CHW")h=h.permute(2,0,1);else throw new Error(`Unsupported channel format: ${_}`);return h}toCanvas(){if(!c)throw new Error("toCanvas() is only supported in browser environments.");const _=this.clone().rgba(),h=l(_.width,_.height),w=new u(_.data,_.width,_.height);return h.getContext("2d").putImageData(w,0,0),h}split(){const{data:_,width:h,height:w,channels:M}=this,x=_.constructor,b=_.length/M,T=Array.from({length:M},()=>new x(b));for(let S=0;S<b;++S){const $=M*S;for(let O=0;O<M;++O)T[O][S]=_[$+O]}return T.map(S=>new m(S,h,w,1))}_update(_,h,w,M=null){return this.data=_,this.width=h,this.height=w,M!==null&&(this.channels=M),this}clone(){return new m(this.data.slice(),this.width,this.height,this.channels)}convert(_){if(this.channels===_)return this;switch(_){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(_){if(c){if(i.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const h=_.split(".").pop().toLowerCase(),w=f.get(h)??"image/png",M=await this.toBlob(w);(0,r.saveBlob)(_,M)}else{if(i.apis.IS_FS_AVAILABLE)return await this.toSharp().toFile(_);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(c)throw new Error("toSharp() is only supported in server-side environments.");return a(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}const y=m.read.bind(m)},"./src/utils/maths.js":(e,t,n)=>{n.r(t),n.d(t,{FFT:()=>y,bankers_round:()=>h,cos_sim:()=>l,dot:()=>a,dynamic_time_warping:()=>w,interpolate_data:()=>r,log_softmax:()=>o,magnitude:()=>u,max:()=>c,medianFilter:()=>C,min:()=>p,permute_data:()=>s,round:()=>_,softmax:()=>i});function r(M,[x,b,T],[S,$],O="bilinear",G=!1){const H=$/T,N=S/b,J=new M.constructor(S*$*x),q=b*T,X=S*$;for(let Y=0;Y<S;++Y)for(let K=0;K<$;++K){const oe=Y*$+K,se=(K+.5)/H-.5,F=(Y+.5)/N-.5;let I=Math.floor(se),V=Math.floor(F);const ee=Math.min(I+1,T-1),pe=Math.min(V+1,b-1);I=Math.max(I,0),V=Math.max(V,0);const Z=se-I,de=F-V,Se=(1-Z)*(1-de),Re=Z*(1-de),ye=(1-Z)*de,Q=Z*de,j=V*T,he=pe*T,be=j+I,we=j+ee,Ce=he+I,De=he+ee;for(let Oe=0;Oe<x;++Oe){const Le=Oe*q;J[Oe*X+oe]=Se*M[Le+be]+Re*M[Le+we]+ye*M[Le+Ce]+Q*M[Le+De]}}return J}function s(M,x,b){const T=new Array(b.length),S=new Array(b.length);for(let G=b.length-1,H=1;G>=0;--G)S[G]=H,T[G]=x[b[G]],H*=T[G];const $=b.map((G,H)=>S[b.indexOf(H)]),O=new M.constructor(M.length);for(let G=0;G<M.length;++G){let H=0;for(let N=x.length-1,J=G;N>=0;--N)H+=J%x[N]*$[N],J=Math.floor(J/x[N]);O[H]=M[G]}return[O,T]}function i(M){const x=c(M)[0],b=M.map($=>Math.exp($-x)),T=b.reduce(($,O)=>$+O,0);return b.map($=>$/T)}function o(M){const x=c(M)[0];let b=0;for(let $=0;$<M.length;++$)b+=Math.exp(M[$]-x);const T=Math.log(b);return M.map($=>$-x-T)}function a(M,x){let b=0;for(let T=0;T<M.length;++T)b+=M[T]*x[T];return b}function l(M,x){const b=a(M,x),T=u(M),S=u(x);return b/(T*S)}function u(M){return Math.sqrt(M.reduce((x,b)=>x+b*b,0))}function p(M){if(M.length===0)throw Error("Array must not be empty");let x=M[0],b=0;for(let T=1;T<M.length;++T)M[T]<x&&(x=M[T],b=T);return[x,b]}function c(M){if(M.length===0)throw Error("Array must not be empty");let x=M[0],b=0;for(let T=1;T<M.length;++T)M[T]>x&&(x=M[T],b=T);return[x,b]}function d(M){return M>0&&(M&M-1)===0}class f{constructor(x){if(this.size=x|0,this.size<=1||!d(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=x<<1,this.table=new Float64Array(this.size*2);for(let T=0;T<this.table.length;T+=2){const S=Math.PI*T/this.size;this.table[T]=Math.cos(S),this.table[T+1]=-Math.sin(S)}let b=0;for(let T=1;this.size>T;T<<=1)++b;this._width=b%2===0?b-1:b,this._bitrev=new Int32Array(1<<this._width);for(let T=0;T<this._bitrev.length;++T){this._bitrev[T]=0;for(let S=0;S<this._width;S+=2){const $=this._width-S-2;this._bitrev[T]|=(T>>>S&3)<<$}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(x,b){const T=b||new Array(x.length>>>1);for(let S=0;S<x.length;S+=2)T[S>>>1]=x[S];return T}toComplexArray(x,b){const T=b||this.createComplexArray();for(let S=0;S<T.length;S+=2)T[S]=x[S>>>1],T[S+1]=0;return T}transform(x,b){if(x===b)throw new Error("Input and output buffers must be different");this._transform4(x,b,1)}realTransform(x,b){if(x===b)throw new Error("Input and output buffers must be different");this._realTransform4(x,b,1)}inverseTransform(x,b){if(x===b)throw new Error("Input and output buffers must be different");this._transform4(x,b,-1);for(let T=0;T<x.length;++T)x[T]/=this.size}_transform4(x,b,T){const S=this._csize;let O=1<<this._width,G=S/O<<1,H,N;const J=this._bitrev;if(G===4)for(H=0,N=0;H<S;H+=G,++N){const X=J[N];this._singleTransform2(b,x,H,X,O)}else for(H=0,N=0;H<S;H+=G,++N){const X=J[N];this._singleTransform4(b,x,H,X,O,T)}const q=this.table;for(O>>=2;O>=2;O>>=2){G=S/O<<1;const X=G>>>2;for(H=0;H<S;H+=G){const Y=H+X-1;for(let K=H,oe=0;K<Y;K+=2,oe+=O){const se=K,F=se+X,I=F+X,V=I+X,ee=x[se],pe=x[se+1],Z=x[F],de=x[F+1],Se=x[I],Re=x[I+1],ye=x[V],Q=x[V+1],j=q[oe],he=T*q[oe+1],be=Z*j-de*he,we=Z*he+de*j,Ce=q[2*oe],De=T*q[2*oe+1],Oe=Se*Ce-Re*De,Le=Se*De+Re*Ce,je=q[3*oe],L=T*q[3*oe+1],re=ye*je-Q*L,R=ye*L+Q*je,ne=ee+Oe,ue=pe+Le,ve=ee-Oe,Te=pe-Le,Ae=be+re,$e=we+R,Ve=T*(be-re),Je=T*(we-R);x[se]=ne+Ae,x[se+1]=ue+$e,x[F]=ve+Je,x[F+1]=Te-Ve,x[I]=ne-Ae,x[I+1]=ue-$e,x[V]=ve-Je,x[V+1]=Te+Ve}}}}_singleTransform2(x,b,T,S,$){const O=x[S],G=x[S+1],H=x[S+$],N=x[S+$+1];b[T]=O+H,b[T+1]=G+N,b[T+2]=O-H,b[T+3]=G-N}_singleTransform4(x,b,T,S,$,O){const G=$*2,H=$*3,N=x[S],J=x[S+1],q=x[S+$],X=x[S+$+1],Y=x[S+G],K=x[S+G+1],oe=x[S+H],se=x[S+H+1],F=N+Y,I=J+K,V=N-Y,ee=J-K,pe=q+oe,Z=X+se,de=O*(q-oe),Se=O*(X-se);b[T]=F+pe,b[T+1]=I+Z,b[T+2]=V+Se,b[T+3]=ee-de,b[T+4]=F-pe,b[T+5]=I-Z,b[T+6]=V-Se,b[T+7]=ee+de}_realTransform4(x,b,T){const S=this._csize;let O=1<<this._width,G=S/O<<1,H,N;const J=this._bitrev;if(G===4)for(H=0,N=0;H<S;H+=G,++N){const Y=J[N];this._singleRealTransform2(b,x,H,Y>>>1,O>>>1)}else for(H=0,N=0;H<S;H+=G,++N){const Y=J[N];this._singleRealTransform4(b,x,H,Y>>>1,O>>>1,T)}const q=this.table;for(O>>=2;O>=2;O>>=2){G=S/O<<1;const Y=G>>>1,K=Y>>>1,oe=K>>>1;for(H=0;H<S;H+=G)for(let se=0,F=0;se<=oe;se+=2,F+=O){const I=H+se,V=I+K,ee=V+K,pe=ee+K,Z=x[I],de=x[I+1],Se=x[V],Re=x[V+1],ye=x[ee],Q=x[ee+1],j=x[pe],he=x[pe+1],be=Z,we=de,Ce=q[F],De=T*q[F+1],Oe=Se*Ce-Re*De,Le=Se*De+Re*Ce,je=q[2*F],L=T*q[2*F+1],re=ye*je-Q*L,R=ye*L+Q*je,ne=q[3*F],ue=T*q[3*F+1],ve=j*ne-he*ue,Te=j*ue+he*ne,Ae=be+re,$e=we+R,Ve=be-re,Je=we-R,qe=Oe+ve,pt=Le+Te,Tt=T*(Oe-ve),Ht=T*(Le-Te);if(x[I]=Ae+qe,x[I+1]=$e+pt,x[V]=Ve+Ht,x[V+1]=Je-Tt,se===0){x[ee]=Ae-qe,x[ee+1]=$e-pt;continue}if(se===oe)continue;const $t=H+K-se,Pn=H+Y-se;x[$t]=Ve-T*Ht,x[$t+1]=-Je-T*Tt,x[Pn]=Ae-T*qe,x[Pn+1]=-$e+T*pt}}const X=S>>>1;for(let Y=2;Y<X;Y+=2)x[S-Y]=x[Y],x[S-Y+1]=-x[Y+1]}_singleRealTransform2(x,b,T,S,$){const O=x[S],G=x[S+$];b[T]=O+G,b[T+1]=0,b[T+2]=O-G,b[T+3]=0}_singleRealTransform4(x,b,T,S,$,O){const G=$*2,H=$*3,N=x[S],J=x[S+$],q=x[S+G],X=x[S+H],Y=N+q,K=N-q,oe=J+X,se=O*(J-X);b[T]=Y+oe,b[T+1]=0,b[T+2]=K,b[T+3]=-se,b[T+4]=Y-oe,b[T+5]=0,b[T+6]=K,b[T+7]=se}}class m{constructor(x){const b=2*(x-1),T=2*(2*x-1),S=2**Math.ceil(Math.log2(T));this.bufferSize=S,this._a=b;const $=new Float64Array(T),O=new Float64Array(S);this._chirpBuffer=new Float64Array(S),this._buffer1=new Float64Array(S),this._buffer2=new Float64Array(S),this._outBuffer1=new Float64Array(S),this._outBuffer2=new Float64Array(S);const G=-2*Math.PI/x,H=Math.cos(G),N=Math.sin(G);for(let J=0;J<T>>1;++J){const q=(J+1-x)**2/2,X=Math.sqrt(H**2+N**2)**q,Y=q*Math.atan2(N,H),K=2*J;$[K]=X*Math.cos(Y),$[K+1]=X*Math.sin(Y),O[K]=$[K],O[K+1]=-$[K+1]}this._slicedChirpBuffer=$.subarray(b,T),this._f=new f(S>>1),this._f.transform(this._chirpBuffer,O)}_transform(x,b,T){const S=this._buffer1,$=this._buffer2,O=this._outBuffer1,G=this._outBuffer2,H=this._chirpBuffer,N=this._slicedChirpBuffer,J=this._a;if(T)for(let q=0;q<N.length;q+=2){const X=q+1,Y=q>>1,K=b[Y];S[q]=K*N[q],S[X]=K*N[X]}else for(let q=0;q<N.length;q+=2){const X=q+1;S[q]=b[q]*N[q]-b[X]*N[X],S[X]=b[q]*N[X]+b[X]*N[q]}this._f.transform(O,S);for(let q=0;q<H.length;q+=2){const X=q+1;$[q]=O[q]*H[q]-O[X]*H[X],$[X]=O[q]*H[X]+O[X]*H[q]}this._f.inverseTransform(G,$);for(let q=0;q<G.length;q+=2){const X=G[q+J],Y=G[q+J+1],K=N[q],oe=N[q+1];x[q]=X*K-Y*oe,x[q+1]=X*oe+Y*K}}transform(x,b){this._transform(x,b,!1)}realTransform(x,b){this._transform(x,b,!0)}}class y{constructor(x){this.fft_length=x,this.isPowerOfTwo=d(x),this.isPowerOfTwo?(this.fft=new f(x),this.outputBufferSize=2*x):(this.fft=new m(x),this.outputBufferSize=this.fft.bufferSize)}realTransform(x,b){this.fft.realTransform(x,b)}transform(x,b){this.fft.transform(x,b)}}function C(M,x){if(x%2===0||x<=0)throw new Error("Window size must be a positive odd number");const b=new M.constructor(M.length),T=new M.constructor(x),S=Math.floor(x/2);for(let $=0;$<M.length;++$){let O=0;for(let G=-S;G<=S;++G){let H=$+G;H<0?H=Math.abs(H):H>=M.length&&(H=2*(M.length-1)-H),T[O++]=M[H]}T.sort(),b[$]=T[S]}return b}function _(M,x){const b=Math.pow(10,x);return Math.round(M*b)/b}function h(M){const x=Math.round(M);return Math.abs(M)%1===.5?x%2===0?x:x-1:x}function w(M){const x=M.length,b=M[0].length,T=[x+1,b+1],S=Array.from({length:T[0]},()=>Array(T[1]).fill(1/0));S[0][0]=0;const $=Array.from({length:T[0]},()=>Array(T[1]).fill(-1));for(let J=1;J<T[1];++J)for(let q=1;q<T[0];++q){const X=S[q-1][J-1],Y=S[q-1][J],K=S[q][J-1];let oe,se;X<Y&&X<K?(oe=X,se=0):Y<X&&Y<K?(oe=Y,se=1):(oe=K,se=2),S[q][J]=M[q-1][J-1]+oe,$[q][J]=se}for(let J=0;J<T[1];++J)$[0][J]=2;for(let J=0;J<T[0];++J)$[J][0]=1;let O=x,G=b,H=[],N=[];for(;O>0||G>0;)switch(H.push(O-1),N.push(G-1),$[O][G]){case 0:--O,--G;break;case 1:--O;break;case 2:--G;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${O}, ${G}]. Please file a bug report.`)}return H.reverse(),N.reverse(),[H,N]}},"./src/utils/tensor.js":(e,t,n)=>{n.r(t),n.d(t,{DataTypeMap:()=>o,Tensor:()=>a,cat:()=>b,full:()=>N,full_like:()=>J,interpolate:()=>p,interpolate_4d:()=>c,layer_norm:()=>h,matmul:()=>d,mean:()=>O,mean_pooling:()=>_,ones:()=>q,ones_like:()=>X,permute:()=>u,quantize_embeddings:()=>se,rand:()=>oe,rfft:()=>f,slice:()=>C,stack:()=>T,std_mean:()=>$,topk:()=>m,zeros:()=>Y,zeros_like:()=>K});var r=n("./src/utils/maths.js"),s=n("./src/backends/onnx.js"),i=n("./src/ops/registry.js");const o=Object.freeze({float32:Float32Array,float16:typeof Float16Array<"u"?Float16Array:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array,uint4:Uint8Array,int4:Int8Array});class a{constructor(...I){ie(this,"ort_tensor");return(0,s.isONNXTensor)(I[0])?this.ort_tensor=I[0]:this.ort_tensor=new s.Tensor(I[0],I[1],I[2]),new Proxy(this,{get:(V,ee)=>{if(typeof ee=="string"){let pe=Number(ee);if(Number.isInteger(pe))return V._getitem(pe)}return V[ee]},set:(V,ee,pe)=>V[ee]=pe})}get dims(){return this.ort_tensor.dims}set dims(I){this.ort_tensor.dims=I}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[I,...V]=this.dims;if(V.length>0){const ee=V.reduce((pe,Z)=>pe*Z);for(let pe=0;pe<I;++pe)yield this._subarray(pe,ee,V)}else yield*this.data}_getitem(I){const[V,...ee]=this.dims;if(I=x(I,V),ee.length>0){const pe=ee.reduce((Z,de)=>Z*de);return this._subarray(I,pe,ee)}else return new a(this.type,[this.data[I]],ee)}indexOf(I){const V=this.data;for(let ee=0;ee<V.length;++ee)if(V[ee]==I)return ee;return-1}_subarray(I,V,ee){const pe=I*V,Z=(I+1)*V,de="subarray"in this.data?this.data.subarray(pe,Z):this.data.slice(pe,Z);return new a(this.type,de,ee)}item(){const I=this.data;if(I.length!==1)throw new Error(`a Tensor with ${I.length} elements cannot be converted to Scalar`);return I[0]}tolist(){return l(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const I=this.data;for(let V=0;V<I.length;++V)I[V]=1/(1+Math.exp(-I[V]));return this}map(I){return this.clone().map_(I)}map_(I){const V=this.data;for(let ee=0;ee<V.length;++ee)V[ee]=I(V[ee],ee,V);return this}mul(I){return this.clone().mul_(I)}mul_(I){const V=this.data;for(let ee=0;ee<V.length;++ee)V[ee]*=I;return this}div(I){return this.clone().div_(I)}div_(I){const V=this.data;for(let ee=0;ee<V.length;++ee)V[ee]/=I;return this}add(I){return this.clone().add_(I)}add_(I){const V=this.data;for(let ee=0;ee<V.length;++ee)V[ee]+=I;return this}sub(I){return this.clone().sub_(I)}sub_(I){const V=this.data;for(let ee=0;ee<V.length;++ee)V[ee]-=I;return this}clone(){return new a(this.type,this.data.slice(),this.dims.slice())}slice(...I){const V=[],ee=[];for(let ye=0;ye<this.dims.length;++ye){let Q=I[ye];if(Q==null)ee.push([0,this.dims[ye]]),V.push(this.dims[ye]);else if(typeof Q=="number")Q=x(Q,this.dims[ye],ye),ee.push([Q,Q+1]);else if(Array.isArray(Q)&&Q.length===2){let[j,he]=Q;if(j=j===null?0:x(j,this.dims[ye],ye,!1),he=he===null?this.dims[ye]:x(he,this.dims[ye],ye,!1),j>he)throw new Error(`Invalid slice: ${Q}`);const be=[Math.max(j,0),Math.min(he,this.dims[ye])];ee.push(be),V.push(be[1]-be[0])}else throw new Error(`Invalid slice: ${Q}`)}const pe=ee.map(([ye,Q])=>Q-ye),Z=pe.reduce((ye,Q)=>ye*Q),de=this.data,Se=new de.constructor(Z),Re=this.stride();for(let ye=0;ye<Z;++ye){let Q=0;for(let j=pe.length-1,he=ye;j>=0;--j){const be=pe[j];Q+=(he%be+ee[j][0])*Re[j],he=Math.floor(he/be)}Se[ye]=de[Q]}return new a(this.type,Se,V)}permute(...I){return u(this,I)}transpose(...I){return this.permute(...I)}sum(I=null,V=!1){return this.norm(1,I,V)}norm(I="fro",V=null,ee=!1){if(I==="fro")I=2;else if(typeof I=="string")throw Error(`Unsupported norm: ${I}`);const pe=this.data,Z=(ye,Q)=>ye+Q**I;if(V===null){const ye=pe.reduce(Z,0)**(1/I);return new a(this.type,[ye],[])}const[de,Se,Re]=S(Z,this,V,ee);if(I!==1)for(let ye=0;ye<Se.length;++ye)Se[ye]=Se[ye]**(1/I);return new a(de,Se,Re)}normalize_(I=2,V=1){V=x(V,this.dims.length);const ee=this.norm(I,V,!0),pe=this.data,Z=ee.data;for(let de=0;de<pe.length;++de){let Se=0;for(let Re=this.dims.length-1,ye=de,Q=1;Re>=0;--Re){const j=this.dims[Re];if(Re!==V){const he=ye%j;Se+=he*Q,Q*=this.dims[Re]}ye=Math.floor(ye/j)}pe[de]/=Z[Se]}return this}normalize(I=2,V=1){return this.clone().normalize_(I,V)}stride(){return G(this.dims)}squeeze(I=null){return new a(this.type,this.data,w(this.dims,I))}squeeze_(I=null){return this.dims=w(this.dims,I),this}unsqueeze(I=null){return new a(this.type,this.data,M(this.dims,I))}unsqueeze_(I=null){return this.dims=M(this.dims,I),this}flatten_(I=0,V=-1){V=(V+this.dims.length)%this.dims.length;let ee=this.dims.slice(0,I),pe=this.dims.slice(I,V+1),Z=this.dims.slice(V+1);return this.dims=[...ee,pe.reduce((de,Se)=>de*Se,1),...Z],this}flatten(I=0,V=-1){return this.clone().flatten_(I,V)}view(...I){let V=-1;for(let pe=0;pe<I.length;++pe)if(I[pe]===-1){if(V!==-1)throw new Error("Only one dimension can be inferred");V=pe}const ee=this.data;if(V!==-1){const pe=I.reduce((Z,de,Se)=>Se!==V?Z*de:Z,1);I[V]=ee.length/pe}return new a(this.type,ee,I)}neg_(){const I=this.data;for(let V=0;V<I.length;++V)I[V]=-I[V];return this}neg(){return this.clone().neg_()}gt(I){const V=new Uint8Array(this.data.length),ee=this.data;for(let pe=0;pe<ee.length;++pe)V[pe]=ee[pe]>I?1:0;return new a("bool",V,this.dims)}lt(I){const V=new Uint8Array(this.data.length),ee=this.data;for(let pe=0;pe<ee.length;++pe)V[pe]=ee[pe]<I?1:0;return new a("bool",V,this.dims)}clamp_(I,V){const ee=this.data;for(let pe=0;pe<ee.length;++pe)ee[pe]=Math.min(Math.max(ee[pe],I),V);return this}clamp(I,V){return this.clone().clamp_(I,V)}round_(){const I=this.data;for(let V=0;V<I.length;++V)I[V]=Math.round(I[V]);return this}round(){return this.clone().round_()}mean(I=null,V=!1){return O(this,I,V)}min(I=null,V=!1){if(I===null){const de=(0,r.min)(this.data)[0];return new a(this.type,[de],[])}const[ee,pe,Z]=S((de,Se)=>Math.min(de,Se),this,I,V,1/0);return new a(ee,pe,Z)}max(I=null,V=!1){if(I===null){const de=(0,r.max)(this.data)[0];return new a(this.type,[de],[])}const[ee,pe,Z]=S((de,Se)=>Math.max(de,Se),this,I,V,-1/0);return new a(ee,pe,Z)}argmin(I=null,V=!1){if(I!==null)throw new Error("`dim !== null` not yet implemented.");const ee=(0,r.min)(this.data)[1];return new a("int64",[BigInt(ee)],[])}argmax(I=null,V=!1){if(I!==null)throw new Error("`dim !== null` not yet implemented.");const ee=(0,r.max)(this.data)[1];return new a("int64",[BigInt(ee)],[])}to(I){if(this.type===I)return this;if(!o.hasOwnProperty(I))throw new Error(`Unsupported type: ${I}`);let V;const ee=["int64","uint64"].includes(this.type),pe=["int64","uint64"].includes(I);return ee&&!pe?V=Number:!ee&&pe&&(V=BigInt),new a(I,o[I].from(this.data,V),this.dims)}}function l(F,I){const V=F.length,ee=I.reduce((Z,de)=>Z*de);if(V!==ee)throw Error(`cannot reshape array of size ${V} into shape (${I})`);let pe=F;for(let Z=I.length-1;Z>=0;Z--)pe=pe.reduce((de,Se)=>{let Re=de[de.length-1];return Re.length<I[Z]?Re.push(Se):de.push([Se]),de},[[]]);return pe[0]}function u(F,I){const[V,ee]=(0,r.permute_data)(F.data,F.dims,I);return new a(F.type,V,ee)}function p(F,[I,V],ee="bilinear",pe=!1){const Z=F.dims.at(-3)??1,de=F.dims.at(-2),Se=F.dims.at(-1);let Re=(0,r.interpolate_data)(F.data,[Z,de,Se],[I,V],ee,pe);return new a(F.type,Re,[Z,I,V])}async function c(F,{size:I=null,mode:V="bilinear"}={}){if(F.dims.length!==4)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!I)throw new Error("`interpolate_4d` requires a `size` argument.");let ee;if(I.length===2)ee=[...F.dims.slice(0,2),...I];else if(I.length===3)ee=[F.dims[0],...I];else if(I.length===4)ee=I;else throw new Error("`size` must be of length 2, 3, or 4.");let pe;if(V==="nearest")pe=await i.TensorOpRegistry.nearest_interpolate_4d;else if(V==="bilinear")pe=await i.TensorOpRegistry.bilinear_interpolate_4d;else if(V==="bicubic")pe=await i.TensorOpRegistry.bicubic_interpolate_4d;else throw new Error(`Unsupported mode: ${V}`);const Z=new a("int64",new BigInt64Array(ee.map(BigInt)),[ee.length]);return await pe({x:F,s:Z})}async function d(F,I){return await(await i.TensorOpRegistry.matmul)({a:F,b:I})}async function f(F,I){return await(await i.TensorOpRegistry.rfft)({x:F,a:I})}async function m(F,I){const V=await i.TensorOpRegistry.top_k;return I==null?I=F.dims.at(-1):I=Math.min(I,F.dims.at(-1)),await V({x:F,k:new a("int64",[BigInt(I)],[1])})}const y=F=>new a("int64",F,[F.length]);async function C(F,I,V,ee,pe){return await(await i.TensorOpRegistry.slice)({x:F,s:y(I),e:y(V),a:y(ee),t:y(pe??new Array(ee.length).fill(1))})}function _(F,I){const V=F.data,ee=I.data,pe=[F.dims[0],F.dims[2]],Z=new V.constructor(pe[0]*pe[1]),[de,Se,Re]=F.dims;let ye=0;for(let Q=0;Q<de;++Q){const j=Q*Re*Se;for(let he=0;he<Re;++he){let be=0,we=0;const Ce=Q*Se,De=j+he;for(let Le=0;Le<Se;++Le){const je=Number(ee[Ce+Le]);we+=je,be+=V[De+Le*Re]*je}const Oe=be/we;Z[ye++]=Oe}}return new a(F.type,Z,pe)}function h(F,I,{eps:V=1e-5}={}){if(F.dims.length!==2)throw new Error("`layer_norm` currently only supports 2D input.");const[ee,pe]=F.dims;if(I.length!==1&&I[0]!==pe)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[Z,de]=$(F,1,0,!0),Se=Z.data,Re=de.data,ye=F.data,Q=new ye.constructor(ye.length);for(let j=0;j<ee;++j){const he=j*pe;for(let be=0;be<pe;++be){const we=he+be;Q[we]=(ye[we]-Re[j])/(Se[j]+V)}}return new a(F.type,Q,F.dims)}function w(F,I){return F=F.slice(),I===null?F=F.filter(V=>V!==1):typeof I=="number"?F[I]===1&&F.splice(I,1):Array.isArray(I)&&(F=F.filter((V,ee)=>V!==1||!I.includes(ee))),F}function M(F,I){return I=x(I,F.length+1),F=F.slice(),F.splice(I,0,1),F}function x(F,I,V=null,ee=!0){if(F<-I||F>=I){if(ee)throw new Error(`IndexError: index ${F} is out of bounds for dimension${V===null?"":" "+V} with size ${I}`);return F<-I?0:I}return F<0&&(F=(F%I+I)%I),F}function b(F,I=0){I=x(I,F[0].dims.length);const V=F[0].dims.slice();V[I]=F.reduce((de,Se)=>de+Se.dims[I],0);const ee=V.reduce((de,Se)=>de*Se,1),pe=new F[0].data.constructor(ee),Z=F[0].type;if(I===0){let de=0;for(const Se of F){const Re=Se.data;pe.set(Re,de),de+=Re.length}}else{let de=0;for(let Se=0;Se<F.length;++Se){const{data:Re,dims:ye}=F[Se];for(let Q=0;Q<Re.length;++Q){let j=0;for(let he=ye.length-1,be=Q,we=1;he>=0;--he){const Ce=ye[he];let De=be%Ce;he===I&&(De+=de),j+=De*we,we*=V[he],be=Math.floor(be/Ce)}pe[j]=Re[Q]}de+=ye[I]}}return new a(Z,pe,V)}function T(F,I=0){return b(F.map(V=>V.unsqueeze(I)),I)}function S(F,I,V=null,ee=!1,pe=null){const Z=I.data,de=I.dims;V=x(V,de.length);const Se=de.slice();Se[V]=1;const Re=new Z.constructor(Z.length/de[V]);pe!==null&&Re.fill(pe);for(let ye=0;ye<Z.length;++ye){let Q=0;for(let j=de.length-1,he=ye,be=1;j>=0;--j){const we=de[j];if(j!==V){const Ce=he%we;Q+=Ce*be,be*=Se[j]}he=Math.floor(he/we)}Re[Q]=F(Re[Q],Z[ye],ye,Q)}return ee||Se.splice(V,1),[I.type,Re,Se]}function $(F,I=null,V=1,ee=!1){const pe=F.data,Z=F.dims;if(I===null){const be=pe.reduce((Oe,Le)=>Oe+Le,0)/pe.length,we=Math.sqrt(pe.reduce((Oe,Le)=>Oe+(Le-be)**2,0)/(pe.length-V)),Ce=new a(F.type,[be],[]);return[new a(F.type,[we],[]),Ce]}I=x(I,Z.length);const de=O(F,I,ee),Se=de.data,[Re,ye,Q]=S((he,be,we,Ce)=>he+(be-Se[Ce])**2,F,I,ee);for(let he=0;he<ye.length;++he)ye[he]=Math.sqrt(ye[he]/(Z[I]-V));return[new a(Re,ye,Q),de]}function O(F,I=null,V=!1){const ee=F.dims,pe=F.data;if(I===null){const Re=pe.reduce((ye,Q)=>ye+Q,0);return new a(F.type,[Re/pe.length],[])}I=x(I,ee.length);const[Z,de,Se]=S((Re,ye)=>Re+ye,F,I,V);if(ee[I]!==1)for(let Re=0;Re<de.length;++Re)de[Re]/=ee[I];return new a(Z,de,Se)}function G(F){const I=new Array(F.length);for(let V=F.length-1,ee=1;V>=0;--V)I[V]=ee,ee*=F[V];return I}function H(F,I,V,ee){const pe=F.reduce((Z,de)=>Z*de,1);return new a(V,new ee(pe).fill(I),F)}function N(F,I){let V,ee;if(typeof I=="number")V="float32",ee=Float32Array;else if(typeof I=="bigint")V="int64",ee=BigInt64Array;else if(typeof I=="boolean")V="bool",ee=Uint8Array;else throw new Error(`Unsupported data type: ${typeof I}`);return H(F,I,V,ee)}function J(F,I){return N(F.dims,I)}function q(F){return H(F,1n,"int64",BigInt64Array)}function X(F){return q(F.dims)}function Y(F){return H(F,0n,"int64",BigInt64Array)}function K(F){return Y(F.dims)}function oe(F){const I=F.reduce((V,ee)=>V*ee,1);return new a("float32",Float32Array.from({length:I},()=>Math.random()),F)}function se(F,I){if(F.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(F.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(I))throw new Error("The precision must be either 'binary' or 'ubinary'");const V=I==="binary",ee=V?"int8":"uint8",pe=V?Int8Array:Uint8Array,Z=F.data,de=new pe(Z.length/8);for(let Se=0;Se<Z.length;++Se){const Re=Z[Se]>0?1:0,ye=Math.floor(Se/8),Q=Se%8;de[ye]|=Re<<7-Q,V&&Q===0&&(de[ye]-=128)}return new a(ee,de,[F.dims[0],F.dims[1]/8])}},"./src/utils/video.js":(e,t,n)=>{n.r(t),n.d(t,{RawVideo:()=>o,RawVideoFrame:()=>i,load_video:()=>a});var r=n("./src/utils/image.js"),s=n("./src/env.js");class i{constructor(u,p){this.image=u,this.timestamp=p}}class o{constructor(u,p){u.length>0&&u[0]instanceof r.RawImage&&(u=u.map((c,d)=>new i(c,(d+1)/(u.length+1)*p))),this.frames=u,this.duration=p}get width(){return this.frames[0].image.width}get height(){return this.frames[0].image.height}get fps(){return this.frames.length/this.duration}}async function a(l,{num_frames:u=null,fps:p=null}={}){if(!s.apis.IS_BROWSER_ENV)throw new Error("`load_video` is currently only supported in browser environments.");if(u==null&&p==null)throw new Error("Either num_frames or fps must be provided.");const c=[],d=document.createElement("video");if(d.crossOrigin="anonymous",d.muted=!0,typeof l=="string")d.src=l;else if(l instanceof Blob)d.src=URL.createObjectURL(l);else if(l instanceof HTMLVideoElement)d.src=l.src;else throw new Error("Invalid URL or video element provided.");if(await new Promise(w=>d.onloadedmetadata=w),d.seekable.start(0)===d.seekable.end(0)){const M=await(await fetch(d.src)).blob();d.src=URL.createObjectURL(M),await new Promise(x=>d.onloadedmetadata=x)}const f=d.duration;let m,y;u!=null?(m=u,y=u===1?0:f/(u-1)):(y=1/p,m=Math.floor(f/y));let C=[];for(let w=0;w<m;++w)C.push(u===1?f/2:w*y);const _=document.createElement("canvas");_.width=d.videoWidth,_.height=d.videoHeight;const h=_.getContext("2d",{willReadFrequently:!0});for(const w of C){d.currentTime=w,await new Promise(T=>{d.onseeked=T}),h.drawImage(d,0,0,_.width,_.height);const M=h.getImageData(0,0,_.width,_.height),x=new r.RawImage(M.data,_.width,_.height,4),b=new i(x,w);c.push(b)}return d.remove(),new o(c,f)}}},YS={};function Bt(e){var t=YS[e];if(t!==void 0)return t.exports;var n=YS[e]={exports:{}};return eW[e](n,n.exports,Bt),n.exports}(()=>{var e=Object.getPrototypeOf?n=>Object.getPrototypeOf(n):n=>n.__proto__,t;Bt.t=function(n,r){if(r&1&&(n=this(n)),r&8||typeof n=="object"&&n&&(r&4&&n.__esModule||r&16&&typeof n.then=="function"))return n;var s=Object.create(null);Bt.r(s);var i={};t=t||[null,e({}),e([]),e(e)];for(var o=r&2&&n;typeof o=="object"&&!~t.indexOf(o);o=e(o))Object.getOwnPropertyNames(o).forEach(a=>i[a]=()=>n[a]);return i.default=()=>n,Bt.d(s,i),s}})();Bt.d=(e,t)=>{for(var n in t)Bt.o(t,n)&&!Bt.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})};Bt.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);Bt.r=e=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var v={};(()=>{/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/Bt.r(v),Bt.d(v,{ASTFeatureExtractor:()=>c.ASTFeatureExtractor,ASTForAudioClassification:()=>n.ASTForAudioClassification,ASTModel:()=>n.ASTModel,ASTPreTrainedModel:()=>n.ASTPreTrainedModel,AlbertForMaskedLM:()=>n.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>n.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>n.AlbertForSequenceClassification,AlbertModel:()=>n.AlbertModel,AlbertPreTrainedModel:()=>n.AlbertPreTrainedModel,AlbertTokenizer:()=>r.AlbertTokenizer,AudioClassificationPipeline:()=>t.AudioClassificationPipeline,AutoConfig:()=>s.AutoConfig,AutoFeatureExtractor:()=>d.AutoFeatureExtractor,AutoImageProcessor:()=>y.AutoImageProcessor,AutoModel:()=>n.AutoModel,AutoModelForAudioClassification:()=>n.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>n.AutoModelForAudioFrameClassification,AutoModelForAudioTextToText:()=>n.AutoModelForAudioTextToText,AutoModelForCTC:()=>n.AutoModelForCTC,AutoModelForCausalLM:()=>n.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>n.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>n.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>n.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>n.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>n.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>n.AutoModelForImageSegmentation,AutoModelForImageTextToText:()=>n.AutoModelForImageTextToText,AutoModelForImageToImage:()=>n.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>n.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>n.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>n.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>n.AutoModelForObjectDetection,AutoModelForPoseEstimation:()=>n.AutoModelForPoseEstimation,AutoModelForQuestionAnswering:()=>n.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>n.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>n.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>n.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>n.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>n.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>n.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>n.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>n.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>n.AutoModelForVision2Seq,AutoModelForXVector:()=>n.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>n.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>h.AutoProcessor,AutoTokenizer:()=>r.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>t.AutomaticSpeechRecognitionPipeline,BackgroundRemovalPipeline:()=>t.BackgroundRemovalPipeline,BartForConditionalGeneration:()=>n.BartForConditionalGeneration,BartForSequenceClassification:()=>n.BartForSequenceClassification,BartModel:()=>n.BartModel,BartPretrainedModel:()=>n.BartPretrainedModel,BartTokenizer:()=>r.BartTokenizer,BaseModelOutput:()=>n.BaseModelOutput,BaseStreamer:()=>w.BaseStreamer,BeitFeatureExtractor:()=>m.BeitFeatureExtractor,BeitForImageClassification:()=>n.BeitForImageClassification,BeitModel:()=>n.BeitModel,BeitPreTrainedModel:()=>n.BeitPreTrainedModel,BertForMaskedLM:()=>n.BertForMaskedLM,BertForQuestionAnswering:()=>n.BertForQuestionAnswering,BertForSequenceClassification:()=>n.BertForSequenceClassification,BertForTokenClassification:()=>n.BertForTokenClassification,BertModel:()=>n.BertModel,BertPreTrainedModel:()=>n.BertPreTrainedModel,BertTokenizer:()=>r.BertTokenizer,BitImageProcessor:()=>m.BitImageProcessor,BlenderbotForConditionalGeneration:()=>n.BlenderbotForConditionalGeneration,BlenderbotModel:()=>n.BlenderbotModel,BlenderbotPreTrainedModel:()=>n.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>n.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>n.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>n.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>r.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>r.BlenderbotTokenizer,BloomForCausalLM:()=>n.BloomForCausalLM,BloomModel:()=>n.BloomModel,BloomPreTrainedModel:()=>n.BloomPreTrainedModel,BloomTokenizer:()=>r.BloomTokenizer,CLIPFeatureExtractor:()=>m.CLIPFeatureExtractor,CLIPImageProcessor:()=>m.CLIPImageProcessor,CLIPModel:()=>n.CLIPModel,CLIPPreTrainedModel:()=>n.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>n.CLIPSegForImageSegmentation,CLIPSegModel:()=>n.CLIPSegModel,CLIPSegPreTrainedModel:()=>n.CLIPSegPreTrainedModel,CLIPTextModel:()=>n.CLIPTextModel,CLIPTextModelWithProjection:()=>n.CLIPTextModelWithProjection,CLIPTokenizer:()=>r.CLIPTokenizer,CLIPVisionModel:()=>n.CLIPVisionModel,CLIPVisionModelWithProjection:()=>n.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>n.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>n.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>n.CamembertForSequenceClassification,CamembertForTokenClassification:()=>n.CamembertForTokenClassification,CamembertModel:()=>n.CamembertModel,CamembertPreTrainedModel:()=>n.CamembertPreTrainedModel,CamembertTokenizer:()=>r.CamembertTokenizer,CausalLMOutput:()=>n.CausalLMOutput,CausalLMOutputWithPast:()=>n.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>m.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>n.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>n.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>n.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>c.ClapFeatureExtractor,ClapModel:()=>n.ClapModel,ClapPreTrainedModel:()=>n.ClapPreTrainedModel,ClapTextModelWithProjection:()=>n.ClapTextModelWithProjection,ClassifierFreeGuidanceLogitsProcessor:()=>x.ClassifierFreeGuidanceLogitsProcessor,CodeGenForCausalLM:()=>n.CodeGenForCausalLM,CodeGenModel:()=>n.CodeGenModel,CodeGenPreTrainedModel:()=>n.CodeGenPreTrainedModel,CodeGenTokenizer:()=>r.CodeGenTokenizer,CodeLlamaTokenizer:()=>r.CodeLlamaTokenizer,CohereForCausalLM:()=>n.CohereForCausalLM,CohereModel:()=>n.CohereModel,CoherePreTrainedModel:()=>n.CoherePreTrainedModel,CohereTokenizer:()=>r.CohereTokenizer,ConvBertForMaskedLM:()=>n.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>n.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>n.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>n.ConvBertForTokenClassification,ConvBertModel:()=>n.ConvBertModel,ConvBertPreTrainedModel:()=>n.ConvBertPreTrainedModel,ConvBertTokenizer:()=>r.ConvBertTokenizer,ConvNextFeatureExtractor:()=>m.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>n.ConvNextForImageClassification,ConvNextImageProcessor:()=>m.ConvNextImageProcessor,ConvNextModel:()=>n.ConvNextModel,ConvNextPreTrainedModel:()=>n.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>n.ConvNextV2ForImageClassification,ConvNextV2Model:()=>n.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>n.ConvNextV2PreTrainedModel,DPTFeatureExtractor:()=>m.DPTFeatureExtractor,DPTForDepthEstimation:()=>n.DPTForDepthEstimation,DPTImageProcessor:()=>m.DPTImageProcessor,DPTModel:()=>n.DPTModel,DPTPreTrainedModel:()=>n.DPTPreTrainedModel,DacDecoderModel:()=>n.DacDecoderModel,DacDecoderOutput:()=>n.DacDecoderOutput,DacEncoderModel:()=>n.DacEncoderModel,DacEncoderOutput:()=>n.DacEncoderOutput,DacFeatureExtractor:()=>c.DacFeatureExtractor,DacModel:()=>n.DacModel,DacPreTrainedModel:()=>n.DacPreTrainedModel,DataTypeMap:()=>l.DataTypeMap,DebertaForMaskedLM:()=>n.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>n.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>n.DebertaForSequenceClassification,DebertaForTokenClassification:()=>n.DebertaForTokenClassification,DebertaModel:()=>n.DebertaModel,DebertaPreTrainedModel:()=>n.DebertaPreTrainedModel,DebertaTokenizer:()=>r.DebertaTokenizer,DebertaV2ForMaskedLM:()=>n.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>n.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>n.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>n.DebertaV2ForTokenClassification,DebertaV2Model:()=>n.DebertaV2Model,DebertaV2PreTrainedModel:()=>n.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>r.DebertaV2Tokenizer,DecisionTransformerModel:()=>n.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>n.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>m.DeiTFeatureExtractor,DeiTForImageClassification:()=>n.DeiTForImageClassification,DeiTImageProcessor:()=>m.DeiTImageProcessor,DeiTModel:()=>n.DeiTModel,DeiTPreTrainedModel:()=>n.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>n.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>n.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>t.DepthEstimationPipeline,DepthProForDepthEstimation:()=>n.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>n.DepthProPreTrainedModel,DetrFeatureExtractor:()=>m.DetrFeatureExtractor,DetrForObjectDetection:()=>n.DetrForObjectDetection,DetrForSegmentation:()=>n.DetrForSegmentation,DetrImageProcessor:()=>m.DetrImageProcessor,DetrModel:()=>n.DetrModel,DetrObjectDetectionOutput:()=>n.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>n.DetrPreTrainedModel,DetrSegmentationOutput:()=>n.DetrSegmentationOutput,Dinov2ForImageClassification:()=>n.Dinov2ForImageClassification,Dinov2Model:()=>n.Dinov2Model,Dinov2PreTrainedModel:()=>n.Dinov2PreTrainedModel,Dinov2WithRegistersForImageClassification:()=>n.Dinov2WithRegistersForImageClassification,Dinov2WithRegistersModel:()=>n.Dinov2WithRegistersModel,Dinov2WithRegistersPreTrainedModel:()=>n.Dinov2WithRegistersPreTrainedModel,DistilBertForMaskedLM:()=>n.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>n.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>n.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>n.DistilBertForTokenClassification,DistilBertModel:()=>n.DistilBertModel,DistilBertPreTrainedModel:()=>n.DistilBertPreTrainedModel,DistilBertTokenizer:()=>r.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>t.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>m.DonutFeatureExtractor,DonutImageProcessor:()=>m.DonutImageProcessor,DonutSwinModel:()=>n.DonutSwinModel,DonutSwinPreTrainedModel:()=>n.DonutSwinPreTrainedModel,EfficientNetForImageClassification:()=>n.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>m.EfficientNetImageProcessor,EfficientNetModel:()=>n.EfficientNetModel,EfficientNetPreTrainedModel:()=>n.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>n.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>n.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>n.ElectraForSequenceClassification,ElectraForTokenClassification:()=>n.ElectraForTokenClassification,ElectraModel:()=>n.ElectraModel,ElectraPreTrainedModel:()=>n.ElectraPreTrainedModel,ElectraTokenizer:()=>r.ElectraTokenizer,EncodecFeatureExtractor:()=>c.EncodecFeatureExtractor,EosTokenCriteria:()=>M.EosTokenCriteria,EsmForMaskedLM:()=>n.EsmForMaskedLM,EsmForSequenceClassification:()=>n.EsmForSequenceClassification,EsmForTokenClassification:()=>n.EsmForTokenClassification,EsmModel:()=>n.EsmModel,EsmPreTrainedModel:()=>n.EsmPreTrainedModel,EsmTokenizer:()=>r.EsmTokenizer,ExaoneForCausalLM:()=>n.ExaoneForCausalLM,ExaoneModel:()=>n.ExaoneModel,ExaonePreTrainedModel:()=>n.ExaonePreTrainedModel,FFT:()=>u.FFT,FalconForCausalLM:()=>n.FalconForCausalLM,FalconModel:()=>n.FalconModel,FalconPreTrainedModel:()=>n.FalconPreTrainedModel,FalconTokenizer:()=>r.FalconTokenizer,FastViTForImageClassification:()=>n.FastViTForImageClassification,FastViTModel:()=>n.FastViTModel,FastViTPreTrainedModel:()=>n.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>t.FeatureExtractionPipeline,FeatureExtractor:()=>p.FeatureExtractor,FillMaskPipeline:()=>t.FillMaskPipeline,Florence2ForConditionalGeneration:()=>n.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>n.Florence2PreTrainedModel,Florence2Processor:()=>_.Florence2Processor,ForcedBOSTokenLogitsProcessor:()=>x.ForcedBOSTokenLogitsProcessor,ForcedEOSTokenLogitsProcessor:()=>x.ForcedEOSTokenLogitsProcessor,GLPNFeatureExtractor:()=>m.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>n.GLPNForDepthEstimation,GLPNModel:()=>n.GLPNModel,GLPNPreTrainedModel:()=>n.GLPNPreTrainedModel,GPT2LMHeadModel:()=>n.GPT2LMHeadModel,GPT2Model:()=>n.GPT2Model,GPT2PreTrainedModel:()=>n.GPT2PreTrainedModel,GPT2Tokenizer:()=>r.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>n.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>n.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>n.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>n.GPTJForCausalLM,GPTJModel:()=>n.GPTJModel,GPTJPreTrainedModel:()=>n.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>n.GPTNeoForCausalLM,GPTNeoModel:()=>n.GPTNeoModel,GPTNeoPreTrainedModel:()=>n.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>n.GPTNeoXForCausalLM,GPTNeoXModel:()=>n.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>n.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>r.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>n.Gemma2ForCausalLM,Gemma2Model:()=>n.Gemma2Model,Gemma2PreTrainedModel:()=>n.Gemma2PreTrainedModel,Gemma3ForCausalLM:()=>n.Gemma3ForCausalLM,Gemma3Model:()=>n.Gemma3Model,Gemma3PreTrainedModel:()=>n.Gemma3PreTrainedModel,GemmaForCausalLM:()=>n.GemmaForCausalLM,GemmaModel:()=>n.GemmaModel,GemmaPreTrainedModel:()=>n.GemmaPreTrainedModel,GemmaTokenizer:()=>r.GemmaTokenizer,GlmForCausalLM:()=>n.GlmForCausalLM,GlmModel:()=>n.GlmModel,GlmPreTrainedModel:()=>n.GlmPreTrainedModel,GraniteForCausalLM:()=>n.GraniteForCausalLM,GraniteModel:()=>n.GraniteModel,GranitePreTrainedModel:()=>n.GranitePreTrainedModel,Grok1Tokenizer:()=>r.Grok1Tokenizer,GroundingDinoForObjectDetection:()=>n.GroundingDinoForObjectDetection,GroundingDinoImageProcessor:()=>m.GroundingDinoImageProcessor,GroundingDinoPreTrainedModel:()=>n.GroundingDinoPreTrainedModel,GroundingDinoProcessor:()=>_.GroundingDinoProcessor,GroupViTModel:()=>n.GroupViTModel,GroupViTPreTrainedModel:()=>n.GroupViTPreTrainedModel,HeliumForCausalLM:()=>n.HeliumForCausalLM,HeliumModel:()=>n.HeliumModel,HeliumPreTrainedModel:()=>n.HeliumPreTrainedModel,HerbertTokenizer:()=>r.HerbertTokenizer,HieraForImageClassification:()=>n.HieraForImageClassification,HieraModel:()=>n.HieraModel,HieraPreTrainedModel:()=>n.HieraPreTrainedModel,HubertForCTC:()=>n.HubertForCTC,HubertForSequenceClassification:()=>n.HubertForSequenceClassification,HubertModel:()=>n.HubertModel,HubertPreTrainedModel:()=>n.HubertPreTrainedModel,IJepaForImageClassification:()=>n.IJepaForImageClassification,IJepaModel:()=>n.IJepaModel,IJepaPreTrainedModel:()=>n.IJepaPreTrainedModel,Idefics3ForConditionalGeneration:()=>n.Idefics3ForConditionalGeneration,Idefics3ImageProcessor:()=>m.Idefics3ImageProcessor,Idefics3PreTrainedModel:()=>n.Idefics3PreTrainedModel,Idefics3Processor:()=>_.Idefics3Processor,ImageClassificationPipeline:()=>t.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>t.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>c.ImageFeatureExtractor,ImageMattingOutput:()=>n.ImageMattingOutput,ImageProcessor:()=>f.ImageProcessor,ImageSegmentationPipeline:()=>t.ImageSegmentationPipeline,ImageToImagePipeline:()=>t.ImageToImagePipeline,ImageToTextPipeline:()=>t.ImageToTextPipeline,InterruptableStoppingCriteria:()=>M.InterruptableStoppingCriteria,JAISLMHeadModel:()=>n.JAISLMHeadModel,JAISModel:()=>n.JAISModel,JAISPreTrainedModel:()=>n.JAISPreTrainedModel,JinaCLIPImageProcessor:()=>m.JinaCLIPImageProcessor,JinaCLIPModel:()=>n.JinaCLIPModel,JinaCLIPPreTrainedModel:()=>n.JinaCLIPPreTrainedModel,JinaCLIPProcessor:()=>_.JinaCLIPProcessor,JinaCLIPTextModel:()=>n.JinaCLIPTextModel,JinaCLIPVisionModel:()=>n.JinaCLIPVisionModel,LiteWhisperForConditionalGeneration:()=>n.LiteWhisperForConditionalGeneration,LlamaForCausalLM:()=>n.LlamaForCausalLM,LlamaModel:()=>n.LlamaModel,LlamaPreTrainedModel:()=>n.LlamaPreTrainedModel,LlamaTokenizer:()=>r.LlamaTokenizer,LlavaForConditionalGeneration:()=>n.LlavaForConditionalGeneration,LlavaOnevisionForConditionalGeneration:()=>n.LlavaOnevisionForConditionalGeneration,LlavaOnevisionImageProcessor:()=>m.LlavaOnevisionImageProcessor,LlavaPreTrainedModel:()=>n.LlavaPreTrainedModel,LogitsProcessor:()=>x.LogitsProcessor,LogitsProcessorList:()=>x.LogitsProcessorList,LogitsWarper:()=>x.LogitsWarper,LongT5ForConditionalGeneration:()=>n.LongT5ForConditionalGeneration,LongT5Model:()=>n.LongT5Model,LongT5PreTrainedModel:()=>n.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>n.M2M100ForConditionalGeneration,M2M100Model:()=>n.M2M100Model,M2M100PreTrainedModel:()=>n.M2M100PreTrainedModel,M2M100Tokenizer:()=>r.M2M100Tokenizer,MBart50Tokenizer:()=>r.MBart50Tokenizer,MBartForCausalLM:()=>n.MBartForCausalLM,MBartForConditionalGeneration:()=>n.MBartForConditionalGeneration,MBartForSequenceClassification:()=>n.MBartForSequenceClassification,MBartModel:()=>n.MBartModel,MBartPreTrainedModel:()=>n.MBartPreTrainedModel,MBartTokenizer:()=>r.MBartTokenizer,MPNetForMaskedLM:()=>n.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>n.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>n.MPNetForSequenceClassification,MPNetForTokenClassification:()=>n.MPNetForTokenClassification,MPNetModel:()=>n.MPNetModel,MPNetPreTrainedModel:()=>n.MPNetPreTrainedModel,MPNetTokenizer:()=>r.MPNetTokenizer,MT5ForConditionalGeneration:()=>n.MT5ForConditionalGeneration,MT5Model:()=>n.MT5Model,MT5PreTrainedModel:()=>n.MT5PreTrainedModel,MarianMTModel:()=>n.MarianMTModel,MarianModel:()=>n.MarianModel,MarianPreTrainedModel:()=>n.MarianPreTrainedModel,MarianTokenizer:()=>r.MarianTokenizer,Mask2FormerImageProcessor:()=>m.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>m.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>n.MaskFormerForInstanceSegmentation,MaskFormerImageProcessor:()=>m.MaskFormerImageProcessor,MaskFormerModel:()=>n.MaskFormerModel,MaskFormerPreTrainedModel:()=>n.MaskFormerPreTrainedModel,MaskedLMOutput:()=>n.MaskedLMOutput,MaxLengthCriteria:()=>M.MaxLengthCriteria,Metric3DForDepthEstimation:()=>n.Metric3DForDepthEstimation,Metric3DPreTrainedModel:()=>n.Metric3DPreTrainedModel,Metric3Dv2ForDepthEstimation:()=>n.Metric3Dv2ForDepthEstimation,Metric3Dv2PreTrainedModel:()=>n.Metric3Dv2PreTrainedModel,MgpstrForSceneTextRecognition:()=>n.MgpstrForSceneTextRecognition,MgpstrModelOutput:()=>n.MgpstrModelOutput,MgpstrPreTrainedModel:()=>n.MgpstrPreTrainedModel,MgpstrProcessor:()=>_.MgpstrProcessor,MgpstrTokenizer:()=>r.MgpstrTokenizer,MimiDecoderModel:()=>n.MimiDecoderModel,MimiDecoderOutput:()=>n.MimiDecoderOutput,MimiEncoderModel:()=>n.MimiEncoderModel,MimiEncoderOutput:()=>n.MimiEncoderOutput,MimiModel:()=>n.MimiModel,MimiPreTrainedModel:()=>n.MimiPreTrainedModel,MinLengthLogitsProcessor:()=>x.MinLengthLogitsProcessor,MinNewTokensLengthLogitsProcessor:()=>x.MinNewTokensLengthLogitsProcessor,MistralForCausalLM:()=>n.MistralForCausalLM,MistralModel:()=>n.MistralModel,MistralPreTrainedModel:()=>n.MistralPreTrainedModel,MobileBertForMaskedLM:()=>n.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>n.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>n.MobileBertForSequenceClassification,MobileBertModel:()=>n.MobileBertModel,MobileBertPreTrainedModel:()=>n.MobileBertPreTrainedModel,MobileBertTokenizer:()=>r.MobileBertTokenizer,MobileLLMForCausalLM:()=>n.MobileLLMForCausalLM,MobileLLMModel:()=>n.MobileLLMModel,MobileLLMPreTrainedModel:()=>n.MobileLLMPreTrainedModel,MobileNetV1FeatureExtractor:()=>m.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>n.MobileNetV1ForImageClassification,MobileNetV1ForSemanticSegmentation:()=>n.MobileNetV1ForSemanticSegmentation,MobileNetV1ImageProcessor:()=>m.MobileNetV1ImageProcessor,MobileNetV1Model:()=>n.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>n.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>m.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>n.MobileNetV2ForImageClassification,MobileNetV2ForSemanticSegmentation:()=>n.MobileNetV2ForSemanticSegmentation,MobileNetV2ImageProcessor:()=>m.MobileNetV2ImageProcessor,MobileNetV2Model:()=>n.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>n.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>m.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>n.MobileNetV3ForImageClassification,MobileNetV3ForSemanticSegmentation:()=>n.MobileNetV3ForSemanticSegmentation,MobileNetV3ImageProcessor:()=>m.MobileNetV3ImageProcessor,MobileNetV3Model:()=>n.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>n.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>m.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>n.MobileNetV4ForImageClassification,MobileNetV4ForSemanticSegmentation:()=>n.MobileNetV4ForSemanticSegmentation,MobileNetV4ImageProcessor:()=>m.MobileNetV4ImageProcessor,MobileNetV4Model:()=>n.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>n.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>m.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>n.MobileViTForImageClassification,MobileViTImageProcessor:()=>m.MobileViTImageProcessor,MobileViTModel:()=>n.MobileViTModel,MobileViTPreTrainedModel:()=>n.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>n.MobileViTV2ForImageClassification,MobileViTV2Model:()=>n.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>n.MobileViTV2PreTrainedModel,ModelOutput:()=>n.ModelOutput,ModernBertForMaskedLM:()=>n.ModernBertForMaskedLM,ModernBertForSequenceClassification:()=>n.ModernBertForSequenceClassification,ModernBertForTokenClassification:()=>n.ModernBertForTokenClassification,ModernBertModel:()=>n.ModernBertModel,ModernBertPreTrainedModel:()=>n.ModernBertPreTrainedModel,Moondream1ForConditionalGeneration:()=>n.Moondream1ForConditionalGeneration,MoonshineFeatureExtractor:()=>c.MoonshineFeatureExtractor,MoonshineForConditionalGeneration:()=>n.MoonshineForConditionalGeneration,MoonshineModel:()=>n.MoonshineModel,MoonshinePreTrainedModel:()=>n.MoonshinePreTrainedModel,MoonshineProcessor:()=>_.MoonshineProcessor,MptForCausalLM:()=>n.MptForCausalLM,MptModel:()=>n.MptModel,MptPreTrainedModel:()=>n.MptPreTrainedModel,MultiModalityCausalLM:()=>n.MultiModalityCausalLM,MultiModalityPreTrainedModel:()=>n.MultiModalityPreTrainedModel,MusicgenForCausalLM:()=>n.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>n.MusicgenForConditionalGeneration,MusicgenModel:()=>n.MusicgenModel,MusicgenPreTrainedModel:()=>n.MusicgenPreTrainedModel,NllbTokenizer:()=>r.NllbTokenizer,NoBadWordsLogitsProcessor:()=>x.NoBadWordsLogitsProcessor,NoRepeatNGramLogitsProcessor:()=>x.NoRepeatNGramLogitsProcessor,NomicBertModel:()=>n.NomicBertModel,NomicBertPreTrainedModel:()=>n.NomicBertPreTrainedModel,NougatImageProcessor:()=>m.NougatImageProcessor,NougatTokenizer:()=>r.NougatTokenizer,OPTForCausalLM:()=>n.OPTForCausalLM,OPTModel:()=>n.OPTModel,OPTPreTrainedModel:()=>n.OPTPreTrainedModel,ObjectDetectionPipeline:()=>t.ObjectDetectionPipeline,Olmo2ForCausalLM:()=>n.Olmo2ForCausalLM,Olmo2Model:()=>n.Olmo2Model,Olmo2PreTrainedModel:()=>n.Olmo2PreTrainedModel,OlmoForCausalLM:()=>n.OlmoForCausalLM,OlmoModel:()=>n.OlmoModel,OlmoPreTrainedModel:()=>n.OlmoPreTrainedModel,OpenELMForCausalLM:()=>n.OpenELMForCausalLM,OpenELMModel:()=>n.OpenELMModel,OpenELMPreTrainedModel:()=>n.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>m.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>n.OwlViTForObjectDetection,OwlViTImageProcessor:()=>m.OwlViTImageProcessor,OwlViTModel:()=>n.OwlViTModel,OwlViTPreTrainedModel:()=>n.OwlViTPreTrainedModel,OwlViTProcessor:()=>_.OwlViTProcessor,Owlv2ForObjectDetection:()=>n.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>m.Owlv2ImageProcessor,Owlv2Model:()=>n.Owlv2Model,Owlv2PreTrainedModel:()=>n.Owlv2PreTrainedModel,PaliGemmaForConditionalGeneration:()=>n.PaliGemmaForConditionalGeneration,PaliGemmaPreTrainedModel:()=>n.PaliGemmaPreTrainedModel,PaliGemmaProcessor:()=>_.PaliGemmaProcessor,PatchTSMixerForPrediction:()=>n.PatchTSMixerForPrediction,PatchTSMixerModel:()=>n.PatchTSMixerModel,PatchTSMixerPreTrainedModel:()=>n.PatchTSMixerPreTrainedModel,PatchTSTForPrediction:()=>n.PatchTSTForPrediction,PatchTSTModel:()=>n.PatchTSTModel,PatchTSTPreTrainedModel:()=>n.PatchTSTPreTrainedModel,Phi3ForCausalLM:()=>n.Phi3ForCausalLM,Phi3Model:()=>n.Phi3Model,Phi3PreTrainedModel:()=>n.Phi3PreTrainedModel,Phi3VForCausalLM:()=>n.Phi3VForCausalLM,Phi3VImageProcessor:()=>m.Phi3VImageProcessor,Phi3VPreTrainedModel:()=>n.Phi3VPreTrainedModel,Phi3VProcessor:()=>_.Phi3VProcessor,PhiForCausalLM:()=>n.PhiForCausalLM,PhiModel:()=>n.PhiModel,PhiPreTrainedModel:()=>n.PhiPreTrainedModel,Pipeline:()=>t.Pipeline,PreTrainedModel:()=>n.PreTrainedModel,PreTrainedTokenizer:()=>r.PreTrainedTokenizer,PretrainedConfig:()=>s.PretrainedConfig,PretrainedMixin:()=>n.PretrainedMixin,Processor:()=>C.Processor,PvtForImageClassification:()=>n.PvtForImageClassification,PvtImageProcessor:()=>m.PvtImageProcessor,PvtModel:()=>n.PvtModel,PvtPreTrainedModel:()=>n.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>c.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>n.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>n.PyAnnoteModel,PyAnnotePreTrainedModel:()=>n.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>_.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>n.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>t.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>n.Qwen2ForCausalLM,Qwen2Model:()=>n.Qwen2Model,Qwen2PreTrainedModel:()=>n.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>r.Qwen2Tokenizer,Qwen2VLForConditionalGeneration:()=>n.Qwen2VLForConditionalGeneration,Qwen2VLImageProcessor:()=>m.Qwen2VLImageProcessor,Qwen2VLPreTrainedModel:()=>n.Qwen2VLPreTrainedModel,Qwen2VLProcessor:()=>_.Qwen2VLProcessor,RFDetrForObjectDetection:()=>n.RFDetrForObjectDetection,RFDetrModel:()=>n.RFDetrModel,RFDetrObjectDetectionOutput:()=>n.RFDetrObjectDetectionOutput,RFDetrPreTrainedModel:()=>n.RFDetrPreTrainedModel,RTDetrForObjectDetection:()=>n.RTDetrForObjectDetection,RTDetrImageProcessor:()=>m.RTDetrImageProcessor,RTDetrModel:()=>n.RTDetrModel,RTDetrObjectDetectionOutput:()=>n.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>n.RTDetrPreTrainedModel,RTDetrV2ForObjectDetection:()=>n.RTDetrV2ForObjectDetection,RTDetrV2Model:()=>n.RTDetrV2Model,RTDetrV2ObjectDetectionOutput:()=>n.RTDetrV2ObjectDetectionOutput,RTDetrV2PreTrainedModel:()=>n.RTDetrV2PreTrainedModel,RawAudio:()=>i.RawAudio,RawImage:()=>o.RawImage,RawVideo:()=>a.RawVideo,RawVideoFrame:()=>a.RawVideoFrame,RepetitionPenaltyLogitsProcessor:()=>x.RepetitionPenaltyLogitsProcessor,ResNetForImageClassification:()=>n.ResNetForImageClassification,ResNetModel:()=>n.ResNetModel,ResNetPreTrainedModel:()=>n.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>n.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>n.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>n.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>n.RoFormerForTokenClassification,RoFormerModel:()=>n.RoFormerModel,RoFormerPreTrainedModel:()=>n.RoFormerPreTrainedModel,RoFormerTokenizer:()=>r.RoFormerTokenizer,RobertaForMaskedLM:()=>n.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>n.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>n.RobertaForSequenceClassification,RobertaForTokenClassification:()=>n.RobertaForTokenClassification,RobertaModel:()=>n.RobertaModel,RobertaPreTrainedModel:()=>n.RobertaPreTrainedModel,RobertaTokenizer:()=>r.RobertaTokenizer,SamImageProcessor:()=>m.SamImageProcessor,SamImageSegmentationOutput:()=>n.SamImageSegmentationOutput,SamModel:()=>n.SamModel,SamPreTrainedModel:()=>n.SamPreTrainedModel,SamProcessor:()=>_.SamProcessor,SapiensForDepthEstimation:()=>n.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>n.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>n.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>n.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>c.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>m.SegformerFeatureExtractor,SegformerForImageClassification:()=>n.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>n.SegformerForSemanticSegmentation,SegformerImageProcessor:()=>m.SegformerImageProcessor,SegformerModel:()=>n.SegformerModel,SegformerPreTrainedModel:()=>n.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>n.Seq2SeqLMOutput,SequenceClassifierOutput:()=>n.SequenceClassifierOutput,SiglipImageProcessor:()=>m.SiglipImageProcessor,SiglipModel:()=>n.SiglipModel,SiglipPreTrainedModel:()=>n.SiglipPreTrainedModel,SiglipTextModel:()=>n.SiglipTextModel,SiglipTokenizer:()=>r.SiglipTokenizer,SiglipVisionModel:()=>n.SiglipVisionModel,SmolVLMForConditionalGeneration:()=>n.SmolVLMForConditionalGeneration,SmolVLMImageProcessor:()=>m.SmolVLMImageProcessor,SmolVLMProcessor:()=>_.SmolVLMProcessor,SnacDecoderModel:()=>n.SnacDecoderModel,SnacEncoderModel:()=>n.SnacEncoderModel,SnacFeatureExtractor:()=>c.SnacFeatureExtractor,SnacModel:()=>n.SnacModel,SnacPreTrainedModel:()=>n.SnacPreTrainedModel,SpeechT5FeatureExtractor:()=>c.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>n.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>n.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>n.SpeechT5HifiGan,SpeechT5Model:()=>n.SpeechT5Model,SpeechT5PreTrainedModel:()=>n.SpeechT5PreTrainedModel,SpeechT5Processor:()=>_.SpeechT5Processor,SpeechT5Tokenizer:()=>r.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>n.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>n.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>n.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>n.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>n.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>r.SqueezeBertTokenizer,StableLmForCausalLM:()=>n.StableLmForCausalLM,StableLmModel:()=>n.StableLmModel,StableLmPreTrainedModel:()=>n.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>n.Starcoder2ForCausalLM,Starcoder2Model:()=>n.Starcoder2Model,Starcoder2PreTrainedModel:()=>n.Starcoder2PreTrainedModel,StoppingCriteria:()=>M.StoppingCriteria,StoppingCriteriaList:()=>M.StoppingCriteriaList,StyleTextToSpeech2Model:()=>n.StyleTextToSpeech2Model,StyleTextToSpeech2PreTrainedModel:()=>n.StyleTextToSpeech2PreTrainedModel,SummarizationPipeline:()=>t.SummarizationPipeline,SuppressTokensAtBeginLogitsProcessor:()=>x.SuppressTokensAtBeginLogitsProcessor,Swin2SRForImageSuperResolution:()=>n.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>m.Swin2SRImageProcessor,Swin2SRModel:()=>n.Swin2SRModel,Swin2SRPreTrainedModel:()=>n.Swin2SRPreTrainedModel,SwinForImageClassification:()=>n.SwinForImageClassification,SwinForSemanticSegmentation:()=>n.SwinForSemanticSegmentation,SwinModel:()=>n.SwinModel,SwinPreTrainedModel:()=>n.SwinPreTrainedModel,T5ForConditionalGeneration:()=>n.T5ForConditionalGeneration,T5Model:()=>n.T5Model,T5PreTrainedModel:()=>n.T5PreTrainedModel,T5Tokenizer:()=>r.T5Tokenizer,TableTransformerForObjectDetection:()=>n.TableTransformerForObjectDetection,TableTransformerModel:()=>n.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>n.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>n.TableTransformerPreTrainedModel,TemperatureLogitsWarper:()=>x.TemperatureLogitsWarper,Tensor:()=>l.Tensor,Text2TextGenerationPipeline:()=>t.Text2TextGenerationPipeline,TextClassificationPipeline:()=>t.TextClassificationPipeline,TextGenerationPipeline:()=>t.TextGenerationPipeline,TextStreamer:()=>w.TextStreamer,TextToAudioPipeline:()=>t.TextToAudioPipeline,TokenClassificationPipeline:()=>t.TokenClassificationPipeline,TokenClassifierOutput:()=>n.TokenClassifierOutput,TokenizerModel:()=>r.TokenizerModel,TopKLogitsWarper:()=>x.TopKLogitsWarper,TopPLogitsWarper:()=>x.TopPLogitsWarper,TrOCRForCausalLM:()=>n.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>n.TrOCRPreTrainedModel,TranslationPipeline:()=>t.TranslationPipeline,UltravoxModel:()=>n.UltravoxModel,UltravoxPreTrainedModel:()=>n.UltravoxPreTrainedModel,UltravoxProcessor:()=>_.UltravoxProcessor,UniSpeechForCTC:()=>n.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>n.UniSpeechForSequenceClassification,UniSpeechModel:()=>n.UniSpeechModel,UniSpeechPreTrainedModel:()=>n.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>n.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>n.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>n.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>n.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>n.UniSpeechSatPreTrainedModel,VLChatProcessor:()=>_.VLChatProcessor,VLMImageProcessor:()=>m.VLMImageProcessor,ViTFeatureExtractor:()=>m.ViTFeatureExtractor,ViTForImageClassification:()=>n.ViTForImageClassification,ViTImageProcessor:()=>m.ViTImageProcessor,ViTMAEModel:()=>n.ViTMAEModel,ViTMAEPreTrainedModel:()=>n.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>n.ViTMSNForImageClassification,ViTMSNModel:()=>n.ViTMSNModel,ViTMSNPreTrainedModel:()=>n.ViTMSNPreTrainedModel,ViTModel:()=>n.ViTModel,ViTPreTrainedModel:()=>n.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>n.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>n.VitMatteForImageMatting,VitMatteImageProcessor:()=>m.VitMatteImageProcessor,VitMattePreTrainedModel:()=>n.VitMattePreTrainedModel,VitPoseForPoseEstimation:()=>n.VitPoseForPoseEstimation,VitPoseImageProcessor:()=>m.VitPoseImageProcessor,VitPosePreTrainedModel:()=>n.VitPosePreTrainedModel,VitsModel:()=>n.VitsModel,VitsModelOutput:()=>n.VitsModelOutput,VitsPreTrainedModel:()=>n.VitsPreTrainedModel,VitsTokenizer:()=>r.VitsTokenizer,Wav2Vec2BertForCTC:()=>n.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>n.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>n.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>n.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>r.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>c.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>n.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>n.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>n.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>n.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>n.Wav2Vec2PreTrainedModel,Wav2Vec2Processor:()=>_.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>_.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>n.WavLMForAudioFrameClassification,WavLMForCTC:()=>n.WavLMForCTC,WavLMForSequenceClassification:()=>n.WavLMForSequenceClassification,WavLMForXVector:()=>n.WavLMForXVector,WavLMModel:()=>n.WavLMModel,WavLMPreTrainedModel:()=>n.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>c.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>n.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>n.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>c.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>n.WhisperForConditionalGeneration,WhisperModel:()=>n.WhisperModel,WhisperPreTrainedModel:()=>n.WhisperPreTrainedModel,WhisperProcessor:()=>_.WhisperProcessor,WhisperTextStreamer:()=>w.WhisperTextStreamer,WhisperTimeStampLogitsProcessor:()=>x.WhisperTimeStampLogitsProcessor,WhisperTokenizer:()=>r.WhisperTokenizer,XLMForQuestionAnswering:()=>n.XLMForQuestionAnswering,XLMForSequenceClassification:()=>n.XLMForSequenceClassification,XLMForTokenClassification:()=>n.XLMForTokenClassification,XLMModel:()=>n.XLMModel,XLMPreTrainedModel:()=>n.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>n.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>n.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>n.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>n.XLMRobertaForTokenClassification,XLMRobertaModel:()=>n.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>n.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>r.XLMRobertaTokenizer,XLMTokenizer:()=>r.XLMTokenizer,XLMWithLMHeadModel:()=>n.XLMWithLMHeadModel,XVectorOutput:()=>n.XVectorOutput,YolosFeatureExtractor:()=>m.YolosFeatureExtractor,YolosForObjectDetection:()=>n.YolosForObjectDetection,YolosImageProcessor:()=>m.YolosImageProcessor,YolosModel:()=>n.YolosModel,YolosObjectDetectionOutput:()=>n.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>n.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>t.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>t.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>t.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>t.ZeroShotObjectDetectionPipeline,bankers_round:()=>u.bankers_round,cat:()=>l.cat,cos_sim:()=>u.cos_sim,dot:()=>u.dot,dynamic_time_warping:()=>u.dynamic_time_warping,env:()=>e.env,full:()=>l.full,full_like:()=>l.full_like,getKeyValueShapes:()=>s.getKeyValueShapes,hamming:()=>i.hamming,hanning:()=>i.hanning,interpolate:()=>l.interpolate,interpolate_4d:()=>l.interpolate_4d,interpolate_data:()=>u.interpolate_data,is_chinese_char:()=>r.is_chinese_char,layer_norm:()=>l.layer_norm,load_image:()=>o.load_image,load_video:()=>a.load_video,log_softmax:()=>u.log_softmax,magnitude:()=>u.magnitude,matmul:()=>l.matmul,max:()=>u.max,mean:()=>l.mean,mean_pooling:()=>l.mean_pooling,medianFilter:()=>u.medianFilter,mel_filter_bank:()=>i.mel_filter_bank,min:()=>u.min,ones:()=>l.ones,ones_like:()=>l.ones_like,permute:()=>l.permute,permute_data:()=>u.permute_data,pipeline:()=>t.pipeline,quantize_embeddings:()=>l.quantize_embeddings,rand:()=>l.rand,read_audio:()=>i.read_audio,rfft:()=>l.rfft,round:()=>u.round,slice:()=>l.slice,softmax:()=>u.softmax,spectrogram:()=>i.spectrogram,stack:()=>l.stack,std_mean:()=>l.std_mean,topk:()=>l.topk,window_function:()=>i.window_function,zeros:()=>l.zeros,zeros_like:()=>l.zeros_like});var e=Bt("./src/env.js"),t=Bt("./src/pipelines.js"),n=Bt("./src/models.js"),r=Bt("./src/tokenizers.js"),s=Bt("./src/configs.js"),i=Bt("./src/utils/audio.js"),o=Bt("./src/utils/image.js"),a=Bt("./src/utils/video.js"),l=Bt("./src/utils/tensor.js"),u=Bt("./src/utils/maths.js"),p=Bt("./src/base/feature_extraction_utils.js"),c=Bt("./src/models/feature_extractors.js"),d=Bt("./src/models/auto/feature_extraction_auto.js"),f=Bt("./src/base/image_processors_utils.js"),m=Bt("./src/models/image_processors.js"),y=Bt("./src/models/auto/image_processing_auto.js"),C=Bt("./src/base/processing_utils.js"),_=Bt("./src/models/processors.js"),h=Bt("./src/models/auto/processing_auto.js"),w=Bt("./src/generation/streamers.js"),M=Bt("./src/generation/stopping_criteria.js"),x=Bt("./src/generation/logits_process.js")})();v.ASTFeatureExtractor;v.ASTForAudioClassification;v.ASTModel;v.ASTPreTrainedModel;v.AlbertForMaskedLM;v.AlbertForQuestionAnswering;v.AlbertForSequenceClassification;v.AlbertModel;v.AlbertPreTrainedModel;v.AlbertTokenizer;v.AudioClassificationPipeline;v.AutoConfig;v.AutoFeatureExtractor;v.AutoImageProcessor;v.AutoModel;v.AutoModelForAudioClassification;v.AutoModelForAudioFrameClassification;v.AutoModelForAudioTextToText;v.AutoModelForCTC;v.AutoModelForCausalLM;v.AutoModelForDepthEstimation;v.AutoModelForDocumentQuestionAnswering;v.AutoModelForImageClassification;v.AutoModelForImageFeatureExtraction;v.AutoModelForImageMatting;v.AutoModelForImageSegmentation;v.AutoModelForImageTextToText;v.AutoModelForImageToImage;v.AutoModelForMaskGeneration;v.AutoModelForMaskedLM;v.AutoModelForNormalEstimation;v.AutoModelForObjectDetection;v.AutoModelForPoseEstimation;v.AutoModelForQuestionAnswering;v.AutoModelForSemanticSegmentation;v.AutoModelForSeq2SeqLM;v.AutoModelForSequenceClassification;v.AutoModelForSpeechSeq2Seq;v.AutoModelForTextToSpectrogram;v.AutoModelForTextToWaveform;v.AutoModelForTokenClassification;v.AutoModelForUniversalSegmentation;v.AutoModelForVision2Seq;v.AutoModelForXVector;v.AutoModelForZeroShotObjectDetection;v.AutoProcessor;v.AutoTokenizer;v.AutomaticSpeechRecognitionPipeline;v.BackgroundRemovalPipeline;v.BartForConditionalGeneration;v.BartForSequenceClassification;v.BartModel;v.BartPretrainedModel;v.BartTokenizer;v.BaseModelOutput;v.BaseStreamer;v.BeitFeatureExtractor;v.BeitForImageClassification;v.BeitModel;v.BeitPreTrainedModel;v.BertForMaskedLM;v.BertForQuestionAnswering;v.BertForSequenceClassification;v.BertForTokenClassification;v.BertModel;v.BertPreTrainedModel;v.BertTokenizer;v.BitImageProcessor;v.BlenderbotForConditionalGeneration;v.BlenderbotModel;v.BlenderbotPreTrainedModel;v.BlenderbotSmallForConditionalGeneration;v.BlenderbotSmallModel;v.BlenderbotSmallPreTrainedModel;v.BlenderbotSmallTokenizer;v.BlenderbotTokenizer;v.BloomForCausalLM;v.BloomModel;v.BloomPreTrainedModel;v.BloomTokenizer;v.CLIPFeatureExtractor;v.CLIPImageProcessor;v.CLIPModel;v.CLIPPreTrainedModel;v.CLIPSegForImageSegmentation;v.CLIPSegModel;v.CLIPSegPreTrainedModel;v.CLIPTextModel;v.CLIPTextModelWithProjection;v.CLIPTokenizer;v.CLIPVisionModel;v.CLIPVisionModelWithProjection;v.CamembertForMaskedLM;v.CamembertForQuestionAnswering;v.CamembertForSequenceClassification;v.CamembertForTokenClassification;v.CamembertModel;v.CamembertPreTrainedModel;v.CamembertTokenizer;v.CausalLMOutput;v.CausalLMOutputWithPast;v.ChineseCLIPFeatureExtractor;v.ChineseCLIPModel;v.ChineseCLIPPreTrainedModel;v.ClapAudioModelWithProjection;v.ClapFeatureExtractor;v.ClapModel;v.ClapPreTrainedModel;v.ClapTextModelWithProjection;v.ClassifierFreeGuidanceLogitsProcessor;v.CodeGenForCausalLM;v.CodeGenModel;v.CodeGenPreTrainedModel;v.CodeGenTokenizer;v.CodeLlamaTokenizer;v.CohereForCausalLM;v.CohereModel;v.CoherePreTrainedModel;v.CohereTokenizer;v.ConvBertForMaskedLM;v.ConvBertForQuestionAnswering;v.ConvBertForSequenceClassification;v.ConvBertForTokenClassification;v.ConvBertModel;v.ConvBertPreTrainedModel;v.ConvBertTokenizer;v.ConvNextFeatureExtractor;v.ConvNextForImageClassification;v.ConvNextImageProcessor;v.ConvNextModel;v.ConvNextPreTrainedModel;v.ConvNextV2ForImageClassification;v.ConvNextV2Model;v.ConvNextV2PreTrainedModel;v.DPTFeatureExtractor;v.DPTForDepthEstimation;v.DPTImageProcessor;v.DPTModel;v.DPTPreTrainedModel;v.DacDecoderModel;v.DacDecoderOutput;v.DacEncoderModel;v.DacEncoderOutput;v.DacFeatureExtractor;v.DacModel;v.DacPreTrainedModel;v.DataTypeMap;v.DebertaForMaskedLM;v.DebertaForQuestionAnswering;v.DebertaForSequenceClassification;v.DebertaForTokenClassification;v.DebertaModel;v.DebertaPreTrainedModel;v.DebertaTokenizer;v.DebertaV2ForMaskedLM;v.DebertaV2ForQuestionAnswering;v.DebertaV2ForSequenceClassification;v.DebertaV2ForTokenClassification;v.DebertaV2Model;v.DebertaV2PreTrainedModel;v.DebertaV2Tokenizer;v.DecisionTransformerModel;v.DecisionTransformerPreTrainedModel;v.DeiTFeatureExtractor;v.DeiTForImageClassification;v.DeiTImageProcessor;v.DeiTModel;v.DeiTPreTrainedModel;v.DepthAnythingForDepthEstimation;v.DepthAnythingPreTrainedModel;v.DepthEstimationPipeline;v.DepthProForDepthEstimation;v.DepthProPreTrainedModel;v.DetrFeatureExtractor;v.DetrForObjectDetection;v.DetrForSegmentation;v.DetrImageProcessor;v.DetrModel;v.DetrObjectDetectionOutput;v.DetrPreTrainedModel;v.DetrSegmentationOutput;v.Dinov2ForImageClassification;v.Dinov2Model;v.Dinov2PreTrainedModel;v.Dinov2WithRegistersForImageClassification;v.Dinov2WithRegistersModel;v.Dinov2WithRegistersPreTrainedModel;v.DistilBertForMaskedLM;v.DistilBertForQuestionAnswering;v.DistilBertForSequenceClassification;v.DistilBertForTokenClassification;v.DistilBertModel;v.DistilBertPreTrainedModel;v.DistilBertTokenizer;v.DocumentQuestionAnsweringPipeline;v.DonutFeatureExtractor;v.DonutImageProcessor;v.DonutSwinModel;v.DonutSwinPreTrainedModel;v.EfficientNetForImageClassification;v.EfficientNetImageProcessor;v.EfficientNetModel;v.EfficientNetPreTrainedModel;v.ElectraForMaskedLM;v.ElectraForQuestionAnswering;v.ElectraForSequenceClassification;v.ElectraForTokenClassification;v.ElectraModel;v.ElectraPreTrainedModel;v.ElectraTokenizer;v.EncodecFeatureExtractor;v.EosTokenCriteria;v.EsmForMaskedLM;v.EsmForSequenceClassification;v.EsmForTokenClassification;v.EsmModel;v.EsmPreTrainedModel;v.EsmTokenizer;v.ExaoneForCausalLM;v.ExaoneModel;v.ExaonePreTrainedModel;v.FFT;v.FalconForCausalLM;v.FalconModel;v.FalconPreTrainedModel;v.FalconTokenizer;v.FastViTForImageClassification;v.FastViTModel;v.FastViTPreTrainedModel;v.FeatureExtractionPipeline;v.FeatureExtractor;v.FillMaskPipeline;v.Florence2ForConditionalGeneration;v.Florence2PreTrainedModel;v.Florence2Processor;v.ForcedBOSTokenLogitsProcessor;v.ForcedEOSTokenLogitsProcessor;v.GLPNFeatureExtractor;v.GLPNForDepthEstimation;v.GLPNModel;v.GLPNPreTrainedModel;v.GPT2LMHeadModel;v.GPT2Model;v.GPT2PreTrainedModel;v.GPT2Tokenizer;v.GPTBigCodeForCausalLM;v.GPTBigCodeModel;v.GPTBigCodePreTrainedModel;v.GPTJForCausalLM;v.GPTJModel;v.GPTJPreTrainedModel;v.GPTNeoForCausalLM;v.GPTNeoModel;v.GPTNeoPreTrainedModel;v.GPTNeoXForCausalLM;v.GPTNeoXModel;v.GPTNeoXPreTrainedModel;v.GPTNeoXTokenizer;v.Gemma2ForCausalLM;v.Gemma2Model;v.Gemma2PreTrainedModel;v.Gemma3ForCausalLM;v.Gemma3Model;v.Gemma3PreTrainedModel;v.GemmaForCausalLM;v.GemmaModel;v.GemmaPreTrainedModel;v.GemmaTokenizer;v.GlmForCausalLM;v.GlmModel;v.GlmPreTrainedModel;v.GraniteForCausalLM;v.GraniteModel;v.GranitePreTrainedModel;v.Grok1Tokenizer;v.GroundingDinoForObjectDetection;v.GroundingDinoImageProcessor;v.GroundingDinoPreTrainedModel;v.GroundingDinoProcessor;v.GroupViTModel;v.GroupViTPreTrainedModel;v.HeliumForCausalLM;v.HeliumModel;v.HeliumPreTrainedModel;v.HerbertTokenizer;v.HieraForImageClassification;v.HieraModel;v.HieraPreTrainedModel;v.HubertForCTC;v.HubertForSequenceClassification;v.HubertModel;v.HubertPreTrainedModel;v.IJepaForImageClassification;v.IJepaModel;v.IJepaPreTrainedModel;v.Idefics3ForConditionalGeneration;v.Idefics3ImageProcessor;v.Idefics3PreTrainedModel;v.Idefics3Processor;v.ImageClassificationPipeline;v.ImageFeatureExtractionPipeline;v.ImageFeatureExtractor;v.ImageMattingOutput;v.ImageProcessor;v.ImageSegmentationPipeline;v.ImageToImagePipeline;v.ImageToTextPipeline;v.InterruptableStoppingCriteria;v.JAISLMHeadModel;v.JAISModel;v.JAISPreTrainedModel;v.JinaCLIPImageProcessor;v.JinaCLIPModel;v.JinaCLIPPreTrainedModel;v.JinaCLIPProcessor;v.JinaCLIPTextModel;v.JinaCLIPVisionModel;v.LiteWhisperForConditionalGeneration;v.LlamaForCausalLM;v.LlamaModel;v.LlamaPreTrainedModel;v.LlamaTokenizer;v.LlavaForConditionalGeneration;v.LlavaOnevisionForConditionalGeneration;v.LlavaOnevisionImageProcessor;v.LlavaPreTrainedModel;v.LogitsProcessor;v.LogitsProcessorList;v.LogitsWarper;v.LongT5ForConditionalGeneration;v.LongT5Model;v.LongT5PreTrainedModel;v.M2M100ForConditionalGeneration;v.M2M100Model;v.M2M100PreTrainedModel;v.M2M100Tokenizer;v.MBart50Tokenizer;v.MBartForCausalLM;v.MBartForConditionalGeneration;v.MBartForSequenceClassification;v.MBartModel;v.MBartPreTrainedModel;v.MBartTokenizer;v.MPNetForMaskedLM;v.MPNetForQuestionAnswering;v.MPNetForSequenceClassification;v.MPNetForTokenClassification;v.MPNetModel;v.MPNetPreTrainedModel;v.MPNetTokenizer;v.MT5ForConditionalGeneration;v.MT5Model;v.MT5PreTrainedModel;v.MarianMTModel;v.MarianModel;v.MarianPreTrainedModel;v.MarianTokenizer;v.Mask2FormerImageProcessor;v.MaskFormerFeatureExtractor;v.MaskFormerForInstanceSegmentation;v.MaskFormerImageProcessor;v.MaskFormerModel;v.MaskFormerPreTrainedModel;v.MaskedLMOutput;v.MaxLengthCriteria;v.Metric3DForDepthEstimation;v.Metric3DPreTrainedModel;v.Metric3Dv2ForDepthEstimation;v.Metric3Dv2PreTrainedModel;v.MgpstrForSceneTextRecognition;v.MgpstrModelOutput;v.MgpstrPreTrainedModel;v.MgpstrProcessor;v.MgpstrTokenizer;v.MimiDecoderModel;v.MimiDecoderOutput;v.MimiEncoderModel;v.MimiEncoderOutput;v.MimiModel;v.MimiPreTrainedModel;v.MinLengthLogitsProcessor;v.MinNewTokensLengthLogitsProcessor;v.MistralForCausalLM;v.MistralModel;v.MistralPreTrainedModel;v.MobileBertForMaskedLM;v.MobileBertForQuestionAnswering;v.MobileBertForSequenceClassification;v.MobileBertModel;v.MobileBertPreTrainedModel;v.MobileBertTokenizer;v.MobileLLMForCausalLM;v.MobileLLMModel;v.MobileLLMPreTrainedModel;v.MobileNetV1FeatureExtractor;v.MobileNetV1ForImageClassification;v.MobileNetV1ForSemanticSegmentation;v.MobileNetV1ImageProcessor;v.MobileNetV1Model;v.MobileNetV1PreTrainedModel;v.MobileNetV2FeatureExtractor;v.MobileNetV2ForImageClassification;v.MobileNetV2ForSemanticSegmentation;v.MobileNetV2ImageProcessor;v.MobileNetV2Model;v.MobileNetV2PreTrainedModel;v.MobileNetV3FeatureExtractor;v.MobileNetV3ForImageClassification;v.MobileNetV3ForSemanticSegmentation;v.MobileNetV3ImageProcessor;v.MobileNetV3Model;v.MobileNetV3PreTrainedModel;v.MobileNetV4FeatureExtractor;v.MobileNetV4ForImageClassification;v.MobileNetV4ForSemanticSegmentation;v.MobileNetV4ImageProcessor;v.MobileNetV4Model;v.MobileNetV4PreTrainedModel;v.MobileViTFeatureExtractor;v.MobileViTForImageClassification;v.MobileViTImageProcessor;v.MobileViTModel;v.MobileViTPreTrainedModel;v.MobileViTV2ForImageClassification;v.MobileViTV2Model;v.MobileViTV2PreTrainedModel;v.ModelOutput;v.ModernBertForMaskedLM;v.ModernBertForSequenceClassification;v.ModernBertForTokenClassification;v.ModernBertModel;v.ModernBertPreTrainedModel;v.Moondream1ForConditionalGeneration;v.MoonshineFeatureExtractor;v.MoonshineForConditionalGeneration;v.MoonshineModel;v.MoonshinePreTrainedModel;v.MoonshineProcessor;v.MptForCausalLM;v.MptModel;v.MptPreTrainedModel;v.MultiModalityCausalLM;v.MultiModalityPreTrainedModel;v.MusicgenForCausalLM;v.MusicgenForConditionalGeneration;v.MusicgenModel;v.MusicgenPreTrainedModel;v.NllbTokenizer;v.NoBadWordsLogitsProcessor;v.NoRepeatNGramLogitsProcessor;v.NomicBertModel;v.NomicBertPreTrainedModel;v.NougatImageProcessor;v.NougatTokenizer;v.OPTForCausalLM;v.OPTModel;v.OPTPreTrainedModel;v.ObjectDetectionPipeline;v.Olmo2ForCausalLM;v.Olmo2Model;v.Olmo2PreTrainedModel;v.OlmoForCausalLM;v.OlmoModel;v.OlmoPreTrainedModel;v.OpenELMForCausalLM;v.OpenELMModel;v.OpenELMPreTrainedModel;v.OwlViTFeatureExtractor;v.OwlViTForObjectDetection;v.OwlViTImageProcessor;v.OwlViTModel;v.OwlViTPreTrainedModel;v.OwlViTProcessor;v.Owlv2ForObjectDetection;v.Owlv2ImageProcessor;v.Owlv2Model;v.Owlv2PreTrainedModel;v.PaliGemmaForConditionalGeneration;v.PaliGemmaPreTrainedModel;v.PaliGemmaProcessor;v.PatchTSMixerForPrediction;v.PatchTSMixerModel;v.PatchTSMixerPreTrainedModel;v.PatchTSTForPrediction;v.PatchTSTModel;v.PatchTSTPreTrainedModel;v.Phi3ForCausalLM;v.Phi3Model;v.Phi3PreTrainedModel;v.Phi3VForCausalLM;v.Phi3VImageProcessor;v.Phi3VPreTrainedModel;v.Phi3VProcessor;v.PhiForCausalLM;v.PhiModel;v.PhiPreTrainedModel;v.Pipeline;v.PreTrainedModel;v.PreTrainedTokenizer;v.PretrainedConfig;v.PretrainedMixin;v.Processor;v.PvtForImageClassification;v.PvtImageProcessor;v.PvtModel;v.PvtPreTrainedModel;v.PyAnnoteFeatureExtractor;v.PyAnnoteForAudioFrameClassification;v.PyAnnoteModel;v.PyAnnotePreTrainedModel;v.PyAnnoteProcessor;v.QuestionAnsweringModelOutput;v.QuestionAnsweringPipeline;v.Qwen2ForCausalLM;v.Qwen2Model;v.Qwen2PreTrainedModel;v.Qwen2Tokenizer;v.Qwen2VLForConditionalGeneration;v.Qwen2VLImageProcessor;v.Qwen2VLPreTrainedModel;v.Qwen2VLProcessor;v.RFDetrForObjectDetection;v.RFDetrModel;v.RFDetrObjectDetectionOutput;v.RFDetrPreTrainedModel;v.RTDetrForObjectDetection;v.RTDetrImageProcessor;v.RTDetrModel;v.RTDetrObjectDetectionOutput;v.RTDetrPreTrainedModel;v.RTDetrV2ForObjectDetection;v.RTDetrV2Model;v.RTDetrV2ObjectDetectionOutput;v.RTDetrV2PreTrainedModel;v.RawAudio;v.RawImage;v.RawVideo;v.RawVideoFrame;v.RepetitionPenaltyLogitsProcessor;v.ResNetForImageClassification;v.ResNetModel;v.ResNetPreTrainedModel;v.RoFormerForMaskedLM;v.RoFormerForQuestionAnswering;v.RoFormerForSequenceClassification;v.RoFormerForTokenClassification;v.RoFormerModel;v.RoFormerPreTrainedModel;v.RoFormerTokenizer;v.RobertaForMaskedLM;v.RobertaForQuestionAnswering;v.RobertaForSequenceClassification;v.RobertaForTokenClassification;v.RobertaModel;v.RobertaPreTrainedModel;v.RobertaTokenizer;v.SamImageProcessor;v.SamImageSegmentationOutput;v.SamModel;v.SamPreTrainedModel;v.SamProcessor;v.SapiensForDepthEstimation;v.SapiensForNormalEstimation;v.SapiensForSemanticSegmentation;v.SapiensPreTrainedModel;v.SeamlessM4TFeatureExtractor;v.SegformerFeatureExtractor;v.SegformerForImageClassification;v.SegformerForSemanticSegmentation;v.SegformerImageProcessor;v.SegformerModel;v.SegformerPreTrainedModel;v.Seq2SeqLMOutput;v.SequenceClassifierOutput;v.SiglipImageProcessor;v.SiglipModel;v.SiglipPreTrainedModel;v.SiglipTextModel;v.SiglipTokenizer;v.SiglipVisionModel;v.SmolVLMForConditionalGeneration;v.SmolVLMImageProcessor;v.SmolVLMProcessor;v.SnacDecoderModel;v.SnacEncoderModel;v.SnacFeatureExtractor;v.SnacModel;v.SnacPreTrainedModel;v.SpeechT5FeatureExtractor;v.SpeechT5ForSpeechToText;v.SpeechT5ForTextToSpeech;v.SpeechT5HifiGan;v.SpeechT5Model;v.SpeechT5PreTrainedModel;v.SpeechT5Processor;v.SpeechT5Tokenizer;v.SqueezeBertForMaskedLM;v.SqueezeBertForQuestionAnswering;v.SqueezeBertForSequenceClassification;v.SqueezeBertModel;v.SqueezeBertPreTrainedModel;v.SqueezeBertTokenizer;v.StableLmForCausalLM;v.StableLmModel;v.StableLmPreTrainedModel;v.Starcoder2ForCausalLM;v.Starcoder2Model;v.Starcoder2PreTrainedModel;v.StoppingCriteria;v.StoppingCriteriaList;v.StyleTextToSpeech2Model;v.StyleTextToSpeech2PreTrainedModel;v.SummarizationPipeline;v.SuppressTokensAtBeginLogitsProcessor;v.Swin2SRForImageSuperResolution;v.Swin2SRImageProcessor;v.Swin2SRModel;v.Swin2SRPreTrainedModel;v.SwinForImageClassification;v.SwinForSemanticSegmentation;v.SwinModel;v.SwinPreTrainedModel;v.T5ForConditionalGeneration;v.T5Model;v.T5PreTrainedModel;v.T5Tokenizer;v.TableTransformerForObjectDetection;v.TableTransformerModel;v.TableTransformerObjectDetectionOutput;v.TableTransformerPreTrainedModel;v.TemperatureLogitsWarper;v.Tensor;v.Text2TextGenerationPipeline;v.TextClassificationPipeline;v.TextGenerationPipeline;v.TextStreamer;v.TextToAudioPipeline;v.TokenClassificationPipeline;v.TokenClassifierOutput;v.TokenizerModel;v.TopKLogitsWarper;v.TopPLogitsWarper;v.TrOCRForCausalLM;v.TrOCRPreTrainedModel;v.TranslationPipeline;v.UltravoxModel;v.UltravoxPreTrainedModel;v.UltravoxProcessor;v.UniSpeechForCTC;v.UniSpeechForSequenceClassification;v.UniSpeechModel;v.UniSpeechPreTrainedModel;v.UniSpeechSatForAudioFrameClassification;v.UniSpeechSatForCTC;v.UniSpeechSatForSequenceClassification;v.UniSpeechSatModel;v.UniSpeechSatPreTrainedModel;v.VLChatProcessor;v.VLMImageProcessor;v.ViTFeatureExtractor;v.ViTForImageClassification;v.ViTImageProcessor;v.ViTMAEModel;v.ViTMAEPreTrainedModel;v.ViTMSNForImageClassification;v.ViTMSNModel;v.ViTMSNPreTrainedModel;v.ViTModel;v.ViTPreTrainedModel;v.VisionEncoderDecoderModel;v.VitMatteForImageMatting;v.VitMatteImageProcessor;v.VitMattePreTrainedModel;v.VitPoseForPoseEstimation;v.VitPoseImageProcessor;v.VitPosePreTrainedModel;v.VitsModel;v.VitsModelOutput;v.VitsPreTrainedModel;v.VitsTokenizer;v.Wav2Vec2BertForCTC;v.Wav2Vec2BertForSequenceClassification;v.Wav2Vec2BertModel;v.Wav2Vec2BertPreTrainedModel;v.Wav2Vec2CTCTokenizer;v.Wav2Vec2FeatureExtractor;v.Wav2Vec2ForAudioFrameClassification;v.Wav2Vec2ForCTC;v.Wav2Vec2ForSequenceClassification;v.Wav2Vec2Model;v.Wav2Vec2PreTrainedModel;v.Wav2Vec2Processor;v.Wav2Vec2ProcessorWithLM;v.WavLMForAudioFrameClassification;v.WavLMForCTC;v.WavLMForSequenceClassification;v.WavLMForXVector;v.WavLMModel;v.WavLMPreTrainedModel;v.WeSpeakerFeatureExtractor;v.WeSpeakerResNetModel;v.WeSpeakerResNetPreTrainedModel;v.WhisperFeatureExtractor;v.WhisperForConditionalGeneration;v.WhisperModel;v.WhisperPreTrainedModel;v.WhisperProcessor;v.WhisperTextStreamer;v.WhisperTimeStampLogitsProcessor;v.WhisperTokenizer;v.XLMForQuestionAnswering;v.XLMForSequenceClassification;v.XLMForTokenClassification;v.XLMModel;v.XLMPreTrainedModel;v.XLMRobertaForMaskedLM;v.XLMRobertaForQuestionAnswering;v.XLMRobertaForSequenceClassification;v.XLMRobertaForTokenClassification;v.XLMRobertaModel;v.XLMRobertaPreTrainedModel;v.XLMRobertaTokenizer;v.XLMTokenizer;v.XLMWithLMHeadModel;v.XVectorOutput;v.YolosFeatureExtractor;v.YolosForObjectDetection;v.YolosImageProcessor;v.YolosModel;v.YolosObjectDetectionOutput;v.YolosPreTrainedModel;v.ZeroShotAudioClassificationPipeline;v.ZeroShotClassificationPipeline;v.ZeroShotImageClassificationPipeline;v.ZeroShotObjectDetectionPipeline;v.bankers_round;v.cat;v.cos_sim;v.dot;v.dynamic_time_warping;var CF=v.env;v.full;v.full_like;v.getKeyValueShapes;v.hamming;v.hanning;v.interpolate;v.interpolate_4d;v.interpolate_data;v.is_chinese_char;v.layer_norm;v.load_image;v.load_video;v.log_softmax;v.magnitude;v.matmul;v.max;v.mean;v.mean_pooling;v.medianFilter;v.mel_filter_bank;v.min;v.ones;v.ones_like;v.permute;v.permute_data;v.pipeline;v.quantize_embeddings;v.rand;v.read_audio;v.rfft;v.round;v.slice;v.softmax;v.spectrogram;v.stack;v.std_mean;v.topk;v.window_function;v.zeros;v.zeros_like;CF.allowLocalModels=!1;CF.useBrowserCache=!1;const La=1024;function tW(e,t,n){let r=n.naturalWidth,s=n.naturalHeight;return r>La||s>La?(r>s?(s=Math.round(s*La/r),r=La):(r=Math.round(r*La/s),s=La),e.width=r,e.height=s,t.drawImage(n,0,0,r,s),!0):(e.width=r,e.height=s,t.drawImage(n,0,0),!1)}const nW=async e=>{const t=new Image;t.src=e,await new Promise(s=>t.onload=s);const n=document.createElement("canvas"),r=n.getContext("2d");if(!r)throw new Error("Could not get canvas context");tW(n,r,t),r.fillStyle="rgba(0, 210, 255, 0.2)",r.fillRect(0,0,n.width,n.height);for(let s=0;s<n.height;s+=2)r.fillStyle="rgba(0, 0, 0, 0.1)",r.fillRect(0,s,n.width,1);return n.toDataURL("image/jpeg",.9)},ep="/lovable-uploads/82a769aa-62e5-4347-8fda-2e9cdf657c01.png",rW=()=>{const[e,t]=Fe.useState(ep);return Fe.useEffect(()=>{(async()=>{try{const r=await nW(ep);t(r)}catch(r){console.error("Error processing image:",r),t(ep)}})()},[]),xe.jsx("section",{className:"relative h-screen",children:xe.jsx("div",{className:"absolute inset-0 bg-cover bg-center transition-all duration-1000",style:{backgroundImage:`url(${e})`,backgroundSize:"cover",backgroundPosition:"center"},children:xe.jsx("div",{className:"absolute inset-0 bg-black/60 flex items-center justify-center",children:xe.jsxs(an.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{duration:.8},className:"text-center z-10 flex flex-col items-center",children:[xe.jsx("img",{src:ep,alt:"Portrait of Maxencio",className:"w-40 h-40 object-cover rounded-full mx-auto mb-6 border-4 border-[#00d2ff] shadow-lg",loading:"eager",style:{background:"#232336"}}),xe.jsx("h1",{className:"text-5xl font-bold mb-6 text-[#00d2ff]",children:"Hello, I'm Maxencio"}),xe.jsx("p",{className:"text-xl text-gray-300 mb-10",children:"Web & App Designer | CLSBB | Aspiring DevSecOps + Ai"}),xe.jsx("a",{href:"https://github.com/Maxencio7/",className:"inline-block px-8 py-4 bg-gradient-to-r from-[#00d2ff] to-[#3a7bd5] text-white font-bold rounded-lg shadow-lg hover:translate-y-[-4px] transition-all duration-300 hover:shadow-[0_8px_16px_rgba(0,0,0,0.4)] hover:bg-gradient-to-r hover:from-[#9b59b6] hover:to-[#3498db]",children:"See My Work"})]})})})})};/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const sW=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),kF=(...e)=>e.filter((t,n,r)=>!!t&&t.trim()!==""&&r.indexOf(t)===n).join(" ").trim();/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var iW={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const oW=Fe.forwardRef(({color:e="currentColor",size:t=24,strokeWidth:n=2,absoluteStrokeWidth:r,className:s="",children:i,iconNode:o,...a},l)=>Fe.createElement("svg",{ref:l,...iW,width:t,height:t,stroke:e,strokeWidth:r?Number(n)*24/Number(t):n,className:kF("lucide",s),...a},[...o.map(([u,p])=>Fe.createElement(u,p)),...Array.isArray(i)?i:[i]]));/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ar=(e,t)=>{const n=Fe.forwardRef(({className:r,...s},i)=>Fe.createElement(oW,{ref:i,iconNode:t,className:kF(`lucide-${sW(e)}`,r),...s}));return n.displayName=`${e}`,n};/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const aW=Ar("Activity",[["path",{d:"M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",key:"169zse"}]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const lW=Ar("Calendar",[["path",{d:"M8 2v4",key:"1cmpym"}],["path",{d:"M16 2v4",key:"4m81vk"}],["rect",{width:"18",height:"18",x:"3",y:"4",rx:"2",key:"1hopcy"}],["path",{d:"M3 10h18",key:"8toen8"}]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const uW=Ar("Cloud",[["path",{d:"M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z",key:"p7xjir"}]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const cW=Ar("FileLock",[["path",{d:"M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",key:"1rqfz7"}],["rect",{width:"8",height:"6",x:"8",y:"12",rx:"1",key:"3yr8at"}],["path",{d:"M10 12v-2a2 2 0 1 1 4 0v2",key:"j4i8d"}]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const dW=Ar("HardDrive",[["line",{x1:"22",x2:"2",y1:"12",y2:"12",key:"1y58io"}],["path",{d:"M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z",key:"oot6mr"}],["line",{x1:"6",x2:"6.01",y1:"16",y2:"16",key:"sgf278"}],["line",{x1:"10",x2:"10.01",y1:"16",y2:"16",key:"1l4acy"}]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const pW=Ar("MapPin",[["path",{d:"M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",key:"1r0f0z"}],["circle",{cx:"12",cy:"10",r:"3",key:"ilqhr7"}]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const fW=Ar("Network",[["rect",{x:"16",y:"16",width:"6",height:"6",rx:"1",key:"4q2zg0"}],["rect",{x:"2",y:"16",width:"6",height:"6",rx:"1",key:"8cvhb9"}],["rect",{x:"9",y:"2",width:"6",height:"6",rx:"1",key:"1egb70"}],["path",{d:"M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3",key:"1jsf9p"}],["path",{d:"M12 12V8",key:"2874zd"}]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const hW=Ar("Rocket",[["path",{d:"M4.5 16.5c-1.5 1.26-2 5-2 5s3.74-.5 5-2c.71-.84.7-2.13-.09-2.91a2.18 2.18 0 0 0-2.91-.09z",key:"m3kijz"}],["path",{d:"m12 15-3-3a22 22 0 0 1 2-3.95A12.88 12.88 0 0 1 22 2c0 2.72-.78 7.5-6 11a22.35 22.35 0 0 1-4 2z",key:"1fmvmk"}],["path",{d:"M9 12H4s.55-3.03 2-4c1.62-1.08 5 0 5 0",key:"1f8sc4"}],["path",{d:"M12 15v5s3.03-.55 4-2c1.08-1.62 0-5 0-5",key:"qeys4"}]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const mW=Ar("Search",[["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}],["path",{d:"m21 21-4.3-4.3",key:"1qie3q"}]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _W=Ar("ShieldCheck",[["path",{d:"M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",key:"oel41y"}],["path",{d:"m9 12 2 2 4-4",key:"dzmm74"}]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const gW=Ar("ShoppingCart",[["circle",{cx:"8",cy:"21",r:"1",key:"jimo8o"}],["circle",{cx:"19",cy:"21",r:"1",key:"13723u"}],["path",{d:"M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",key:"9zh506"}]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const yW=Ar("Star",[["path",{d:"M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z",key:"r04s7s"}]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const vW=Ar("Users",[["path",{d:"M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",key:"1yyitq"}],["circle",{cx:"9",cy:"7",r:"4",key:"nufk8"}],["path",{d:"M22 21v-2a4 4 0 0 0-3-3.87",key:"kshegd"}],["path",{d:"M16 3.13a4 4 0 0 1 0 7.75",key:"1da9ce"}]]);/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const wW=Ar("Wrench",[["path",{d:"M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z",key:"cbrjhi"}]]),MW=[{title:"Cybersecurity Audits",icon:_W,description:"Comprehensive security assessments to identify vulnerabilities in your systems. Recommendations for improving security protocols and protecting sensitive data.",image:"https://images.unsplash.com/photo-1487058792275-0ad4aaf24ca7?auto=format&fit=crop&w=600&q=80",alt:"Cybersecurity audit concept - digital code on a screen"},{title:"Penetration Testing (Ethical Hacking)",icon:mW,description:"Simulated attacks to identify weaknesses in your network, systems, and applications. Detailed reports on findings and mitigation strategies.",image:"https://images.unsplash.com/photo-1485827404703-89b55fcc595e?auto=format&fit=crop&w=600&q=80",alt:"Robot and coding interface symbolizing hacking"},{title:"IT Troubleshooting",icon:wW,description:"Assistance diagnosing and resolving common IT issues: hardware, software, and network connectivity. Solutions for performance issues, crashes, or malware problems.",image:"https://images.unsplash.com/photo-1581091226825-a6a2a5aee158?auto=format&fit=crop&w=600&q=80",alt:"Woman troubleshooting laptop computer"},{title:"Network Security Configuration",icon:fW,description:"Secure setup of firewalls, routers, and VPNs. Network hardening and data protection recommendations.",image:"https://images.unsplash.com/photo-1605810230434-7631ac76ec81?auto=format&fit=crop&w=600&q=80",alt:"Group examining secure network setup"},{title:"Data Encryption Services",icon:cW,description:"Secure encryption methods for sensitive data at rest and in transit. Best practices for storage and sharing.",image:"https://images.unsplash.com/photo-1531297484001-80022131f5a1?auto=format&fit=crop&w=600&q=80",alt:"Encrypted data on laptop"},{title:"Windows OS Support",icon:dW,description:"Troubleshooting for Windows: system crashes, updates, performance problems. Regular updates and patch management guidance.",image:"https://images.unsplash.com/photo-1461749280684-dccba630e2f6?auto=format&fit=crop&w=600&q=80",alt:"Monitor displaying system diagnostics"},{title:"Cloud Security Solutions",icon:uW,description:"Protect cloud infrastructure and data. Secure cloud backups and disaster recovery plans.",image:"https://images.unsplash.com/photo-1515378791036-0648a3ef77b2?auto=format&fit=crop&w=600&q=80",alt:"Cloud security illustration"},{title:"Incident Response Planning",icon:aW,description:"Development of incident response strategies. Staff training for breaches and emergencies.",image:"https://images.unsplash.com/photo-1488590528505-98d2b5aba04b?auto=format&fit=crop&w=600&q=80",alt:"Incident response training session"},{title:"Employee Cybersecurity Awareness Training",icon:vW,description:"Training for staff to prevent phishing, social engineering, and poor security practices. Security culture improvements.",image:"https://images.unsplash.com/photo-1573167243872-43c6433b9d40?auto=format&fit=crop&w=600&q=80",alt:"Team learning cybersecurity skills"}],xW=()=>xe.jsxs("section",{className:"relative py-20 bg-gradient-to-br from-[#121212] via-[#1A1F2C] to-[#2e085f] min-h-[80vh]",id:"services",children:[xe.jsx("div",{className:"absolute inset-0 pointer-events-none select-none",style:{background:"linear-gradient(135deg, #0EA5E9 0%, #8B5CF6 75%, #1A1F2C 100%)",opacity:.12,zIndex:1}}),xe.jsxs("div",{className:"relative z-10 max-w-7xl mx-auto px-6",children:[xe.jsx("h2",{className:"text-4xl md:text-5xl font-bold text-white mb-4 text-center drop-shadow-lg animate-fade-in",children:"Services Offered"}),xe.jsx("p",{className:"max-w-2xl mx-auto mb-12 text-center text-lg text-gray-300 animate-fade-in",children:xe.jsx("span",{className:"font-semibold text-[#00d2ff]",children:"Cybersecurity and IT Services for Small Businesses and Individuals"})}),xe.jsx("div",{className:"grid gap-10 md:gap-12 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3",children:MW.map(({title:e,description:t,icon:n,image:r,alt:s},i)=>xe.jsxs("div",{className:"bg-[#181C25]/90 rounded-3xl shadow-2xl border border-[#232336]/60 flex flex-col hover:scale-105 transition-transform duration-300 animate-fade-in group relative overflow-hidden",style:{minHeight:420,maxWidth:430,margin:"0 auto"},children:[xe.jsx("img",{src:r,alt:s,loading:"lazy",className:"h-48 w-full object-cover rounded-t-3xl group-hover:scale-105 transition-transform duration-500 border-b-4 border-[#00d2ff]/40",onError:o=>{o.currentTarget.src="https://images.unsplash.com/photo-1581091226825-a6a2a5aee158?auto=format&fit=crop&w=600&q=80"}}),xe.jsxs("div",{className:"flex-1 flex flex-col items-center px-7 py-7",children:[xe.jsx("div",{className:"bg-gradient-to-br from-[#00d2ff] to-[#8B5CF6] text-white rounded-xl p-4 shadow-md z-10 -mt-16 mb-4 border-2 border-white/10",children:xe.jsx(n,{size:38})}),xe.jsx("h3",{className:"text-2xl font-semibold mb-2 text-white drop-shadow text-center",children:e}),xe.jsx("p",{className:"text-gray-300 text-base text-center",children:t})]})]},e))})]})]}),bW=()=>{const e=[{id:1,image:"/lovable-uploads/a7a1969b-efec-482e-a623-11819f346ede.png",title:"Startup Project",description:"Modern landing page with space theme",link:"/demo/startup"},{id:2,image:"/lovable-uploads/9aff5fd5-7b6c-43a7-9951-42fada893526.png",title:"Influencer Conference",description:"Creative conference website design",link:"/demo/portfolio"},{id:3,image:"/lovable-uploads/fd7d4513-b4bb-4d22-8bc0-bd1033cf0e5a.png",title:"E-commerce Project",description:"Modern furniture shopping experience",link:"/demo/ecommerce"}];return xe.jsx("section",{className:"py-20 bg-[#121212]",children:xe.jsxs(an.div,{initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},transition:{duration:.6},className:"container mx-auto px-6",children:[xe.jsx("h2",{className:"text-4xl font-bold mb-16 text-[#00d2ff] text-center",children:"My Projects"}),xe.jsx("div",{className:"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-10 max-w-6xl mx-auto",children:e.map(t=>xe.jsx(T$,{to:t.link,children:xe.jsxs(an.div,{whileHover:{scale:1.05,rotateX:2,rotateY:2},className:"bg-[#1f1f1f] rounded-2xl overflow-hidden shadow-[0_10px_25px_rgba(0,210,255,0.15)] transform perspective-800 transition-all duration-500",children:[xe.jsx("div",{className:"h-48 w-full overflow-hidden",children:xe.jsx("img",{src:t.image,alt:t.title,className:"w-full h-full object-cover transition-transform duration-500 hover:scale-110"})}),xe.jsxs("div",{className:"p-6",children:[xe.jsx("h3",{className:"text-xl font-bold text-[#00d2ff] mb-2",children:t.title}),xe.jsx("p",{className:"text-gray-400",children:t.description})]})]})},t.id))})]})})},TW=()=>xe.jsx("section",{className:"py-20 bg-[#121212]",children:xe.jsxs(an.div,{initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},transition:{duration:.6},className:"container mx-auto px-6",children:[xe.jsx("h2",{className:"text-4xl font-bold mb-16 text-[#00d2ff] text-center",children:"About Me"}),xe.jsx(an.div,{whileHover:{rotateX:2,rotateY:2},className:"max-w-3xl mx-auto bg-[#1f1f1f] p-10 rounded-2xl shadow-[0_10px_25px_rgba(0,210,255,0.2)] transform perspective-800 transition-all duration-500",children:xe.jsxs("div",{className:"space-y-6 text-gray-300",children:[xe.jsx("p",{children:"I'm a self-driven web/app designer and aspiring DevSecOps engineer, constantly exploring new creative angles and smarter solutions. With a strong background in Lean Six Sigma, cybersecurity and a deep love for clean, efficient design, I bring structure to style."}),xe.jsx("p",{children:"Through my journey's just beginning, I'm passionate about building modern, responsive websites/apps that look amazing and feel intuitive. I'm hands-on with HTML, CSS, Javascript, React, Flutter etc. Every project is a chance to create something that feels alive."}),xe.jsx("p",{children:"I'm here to work, grow, and make something dope. Let's create something that stands out."})]})})]})}),EW=()=>{Fe.useState(!1);const e=async t=>{t.preventDefault();try{await window.emailjs.sendForm("service_2s5qe8m","template_nxbjdln",t.currentTarget),eT.success("Message sent successfully!"),t.target.reset()}catch(n){console.error("FAILED...",n),eT.error("Failed to send message.")}};return xe.jsx("section",{className:"py-20 bg-[#1a1a1a]",children:xe.jsxs(an.div,{initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},transition:{duration:.6},className:"container mx-auto px-6",children:[xe.jsx("h2",{className:"text-4xl font-bold mb-16 text-[#00d2ff] text-center",children:"Contact Me"}),xe.jsxs(an.div,{whileHover:{rotateX:2,rotateY:2},className:"max-w-2xl mx-auto bg-[#2a2a2a] p-10 rounded-2xl shadow-[0_10px_25px_rgba(0,210,255,0.2)] transform perspective-800 transition-all duration-500",children:[xe.jsx("p",{className:"text-gray-300 text-center mb-8",children:"Got a Project or just wanna say hey? I'm all ears."}),xe.jsxs("form",{onSubmit:e,className:"space-y-6",children:[xe.jsx("input",{type:"text",name:"name",placeholder:"Your Name",required:!0,className:"w-full p-4 bg-[#1f1f1f] rounded-lg border border-gray-700 text-white focus:outline-none focus:border-[#00d2ff]"}),xe.jsx("input",{type:"email",name:"email",placeholder:"Your Email",required:!0,className:"w-full p-4 bg-[#1f1f1f] rounded-lg border border-gray-700 text-white focus:outline-none focus:border-[#00d2ff]"}),xe.jsx("textarea",{name:"message",placeholder:"Your Message",rows:5,required:!0,className:"w-full p-4 bg-[#1f1f1f] rounded-lg border border-gray-700 text-white focus:outline-none focus:border-[#00d2ff]"}),xe.jsx("button",{type:"submit",className:"w-full py-4 bg-gradient-to-r from-[#00d2ff] to-[#3a7bd5] text-white rounded-lg hover:from-[#3a7bd5] hover:to-[#00d2ff] transition-all duration-300",children:"Send Message"})]})]})]})})},PW=()=>(Fe.useEffect(()=>{const e=document.createElement("script");return e.src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js",e.async=!0,document.body.appendChild(e),e.onload=()=>{window.emailjs.init("PaEC-06vRKzg3a8_3")},()=>{document.body.removeChild(e)}},[]),xe.jsxs("main",{className:"bg-black min-h-screen",children:[xe.jsx(rW,{}),xe.jsx(xW,{}),xe.jsx(bW,{}),xe.jsx(TW,{}),xe.jsx(EW,{})]})),SW=()=>{const e=vc();return xe.jsxs("div",{className:"min-h-screen bg-[#121212] text-white p-8",children:[xe.jsx(an.button,{initial:{opacity:0},animate:{opacity:1},onClick:()=>e("/"),className:"mb-8 px-6 py-3 bg-gradient-to-r from-[#00d2ff] to-[#3a7bd5] rounded-lg hover:from-[#3a7bd5] hover:to-[#00d2ff] transition-all duration-300",children:" Back to Portfolio"}),xe.jsxs(an.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{duration:.6},className:"max-w-4xl mx-auto bg-[#1f1f1f] p-8 rounded-2xl shadow-[0_10px_25px_rgba(0,210,255,0.2)]",children:[xe.jsx("h1",{className:"text-4xl font-bold mb-6 text-[#00d2ff]",children:"Project Demo"}),xe.jsx("p",{className:"text-gray-300 mb-6",children:"This is a demonstration page for the project. In a real application, this would contain the actual project content and functionality."}),xe.jsx("div",{className:"aspect-video bg-[#2a2a2a] rounded-lg flex items-center justify-center",children:xe.jsx("p",{className:"text-gray-400",children:"Project Demo Content"})})]})]})},CW=()=>{const e=vc();return xe.jsxs("div",{className:"min-h-screen bg-[#0c0c0c] text-white overflow-hidden",children:[xe.jsx(an.button,{initial:{opacity:0},animate:{opacity:1},onClick:()=>e("/"),className:"fixed top-4 left-4 px-6 py-3 bg-gradient-to-r from-[#00d2ff] to-[#3a7bd5] rounded-lg hover:from-[#3a7bd5] hover:to-[#00d2ff] transition-all duration-300 z-50 flex items-center gap-2",children:" Back to Portfolio"}),xe.jsxs("div",{className:"relative min-h-screen",children:[xe.jsxs("div",{className:"absolute inset-0",children:[xe.jsx("div",{className:"absolute inset-0 bg-[url('/lovable-uploads/a7a1969b-efec-482e-a623-11819f346ede.png')] bg-cover bg-center"}),xe.jsx("div",{className:"absolute inset-0 bg-gradient-to-b from-black/70 to-transparent"}),xe.jsx(an.div,{initial:{opacity:0},animate:{opacity:1},transition:{duration:2,repeat:1/0,repeatType:"reverse"},className:"absolute inset-0 bg-gradient-to-r from-blue-500/10 to-purple-500/10"})]}),xe.jsx("div",{className:"relative z-10 container mx-auto px-4 pt-32",children:xe.jsxs(an.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{duration:.6},className:"max-w-4xl mx-auto text-center",children:[xe.jsx(an.div,{initial:{scale:.95},animate:{scale:1},transition:{duration:2,repeat:1/0,repeatType:"reverse"},className:"mb-8",children:xe.jsx(hW,{className:"w-16 h-16 mx-auto text-[#00d2ff]"})}),xe.jsx("h1",{className:"text-6xl font-bold mb-6 bg-gradient-to-r from-[#00d2ff] to-[#3a7bd5] bg-clip-text text-transparent",children:"Explore the Universe"}),xe.jsx("p",{className:"text-xl text-gray-300 mb-12",children:"Your gateway to the next frontier of space exploration and discovery"}),xe.jsxs("div",{className:"flex flex-col sm:flex-row gap-6 justify-center items-center",children:[xe.jsxs(an.button,{whileHover:{scale:1.05},whileTap:{scale:.95},className:"px-8 py-4 bg-gradient-to-r from-[#00d2ff] to-[#3a7bd5] rounded-lg text-lg font-semibold hover:from-[#3a7bd5] hover:to-[#00d2ff] transition-all duration-300 flex items-center gap-2 w-full sm:w-auto",children:[xe.jsx(yW,{className:"w-5 h-5"}),"Start Your Journey"]}),xe.jsx(an.button,{whileHover:{scale:1.05},whileTap:{scale:.95},className:"px-8 py-4 border-2 border-[#00d2ff] rounded-lg text-lg font-semibold hover:bg-[#00d2ff]/10 transition-all duration-300 w-full sm:w-auto",children:"Learn More"})]})]})})]})]})},kW=()=>{const e=vc();return xe.jsxs("div",{className:"min-h-screen bg-[#1a1a1a] text-white",children:[xe.jsx(an.button,{initial:{opacity:0},animate:{opacity:1},onClick:()=>e("/"),className:"fixed top-4 left-4 px-6 py-3 bg-gradient-to-r from-[#9b59b6] to-[#3498db] rounded-lg hover:from-[#3498db] hover:to-[#9b59b6] transition-all duration-300 z-50",children:" Back to Portfolio"}),xe.jsxs("div",{className:"relative min-h-screen",children:[xe.jsxs("div",{className:"absolute inset-0",children:[xe.jsx("div",{className:"absolute inset-0 bg-[url('/lovable-uploads/9aff5fd5-7b6c-43a7-9951-42fada893526.png')] bg-cover bg-center"}),xe.jsx("div",{className:"absolute inset-0 bg-black/60"}),xe.jsx(an.div,{initial:{opacity:0},animate:{opacity:1},transition:{duration:2,repeat:1/0,repeatType:"reverse"},className:"absolute inset-0 bg-gradient-to-r from-purple-500/10 to-blue-500/10"})]}),xe.jsx("div",{className:"relative z-10 container mx-auto px-4 pt-32",children:xe.jsxs(an.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{duration:.6},className:"max-w-4xl mx-auto text-center",children:[xe.jsx("h1",{className:"text-6xl font-bold mb-6 bg-gradient-to-r from-[#9b59b6] to-[#3498db] bg-clip-text text-transparent",children:"Creative Conference"}),xe.jsxs("div",{className:"flex justify-center gap-6 mb-8",children:[xe.jsxs(an.div,{whileHover:{scale:1.05},className:"flex items-center gap-2 text-gray-300",children:[xe.jsx(lW,{className:"w-5 h-5 text-[#9b59b6]"}),xe.jsx("span",{children:"April 20-22, 2025"})]}),xe.jsxs(an.div,{whileHover:{scale:1.05},className:"flex items-center gap-2 text-gray-300",children:[xe.jsx(pW,{className:"w-5 h-5 text-[#3498db]"}),xe.jsx("span",{children:"San Francisco, CA"})]})]}),xe.jsx("p",{className:"text-xl text-gray-300 mb-12",children:"Join us for an inspiring gathering of creative minds from around the world"}),xe.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-6 max-w-2xl mx-auto",children:[xe.jsx(an.button,{whileHover:{scale:1.05},whileTap:{scale:.95},className:"px-8 py-4 bg-gradient-to-r from-[#9b59b6] to-[#3498db] rounded-lg text-lg font-semibold hover:from-[#3498db] hover:to-[#9b59b6] transition-all duration-300",children:"Register Now"}),xe.jsx(an.button,{whileHover:{scale:1.05},whileTap:{scale:.95},className:"px-8 py-4 border-2 border-[#9b59b6] rounded-lg text-lg font-semibold hover:bg-[#9b59b6]/10 transition-all duration-300",children:"Learn More"})]})]})})]})]})},$W=()=>{const e=vc();return xe.jsxs("div",{className:"min-h-screen bg-[#f8f8f8]",children:[xe.jsx("nav",{className:"bg-white shadow-md fixed w-full z-50",children:xe.jsxs("div",{className:"container mx-auto px-4 py-4 flex justify-between items-center",children:[xe.jsx(an.button,{initial:{opacity:0},animate:{opacity:1},onClick:()=>e("/"),className:"px-6 py-2 text-gray-800 hover:text-gray-600 transition-colors duration-300",children:" Back"}),xe.jsx("h1",{className:"text-2xl font-bold text-gray-800",children:"ModernHome"}),xe.jsx("button",{className:"p-2 hover:bg-gray-100 rounded-full transition-colors duration-300",children:xe.jsx(gW,{className:"w-6 h-6 text-gray-800"})})]})}),xe.jsx("div",{className:"pt-20",children:xe.jsxs("div",{className:"relative h-[70vh]",children:[xe.jsx("div",{className:"absolute inset-0 bg-[url('/lovable-uploads/fd7d4513-b4bb-4d22-8bc0-bd1033cf0e5a.png')] bg-cover bg-center"}),xe.jsx("div",{className:"absolute inset-0 bg-black/30"}),xe.jsx(an.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{duration:.6},className:"relative z-10 container mx-auto px-4 h-full flex items-center",children:xe.jsxs("div",{className:"max-w-2xl",children:[xe.jsx("h2",{className:"text-5xl font-bold text-white mb-6",children:"Modern Furniture for Modern Living"}),xe.jsx("p",{className:"text-xl text-gray-100 mb-8",children:"Discover our curated collection of contemporary furniture"}),xe.jsx(an.button,{whileHover:{scale:1.05},whileTap:{scale:.95},className:"px-8 py-4 bg-white text-gray-900 rounded-lg text-lg font-semibold hover:bg-gray-100 transition-all duration-300",children:"Shop Now"})]})})]})})]})},IW=()=>{const e=yc();return Fe.useEffect(()=>{console.error("404 Error: User attempted to access non-existent route:",e.pathname)},[e.pathname]),xe.jsx("div",{className:"min-h-screen flex items-center justify-center bg-gray-100",children:xe.jsxs("div",{className:"text-center",children:[xe.jsx("h1",{className:"text-4xl font-bold mb-4",children:"404"}),xe.jsx("p",{className:"text-xl text-gray-600 mb-4",children:"Oops! Page not found"}),xe.jsx(T$,{to:"/",className:"text-blue-500 hover:text-blue-700 underline",children:"Return to Home"})]})})},AW=()=>xe.jsxs(xe.Fragment,{children:[xe.jsx(Zz,{}),xe.jsx(qR,{children:xe.jsxs(jR,{children:[xe.jsx(Vo,{path:"/",element:xe.jsx(PW,{})}),xe.jsx(Vo,{path:"/demo",element:xe.jsx(SW,{})}),xe.jsx(Vo,{path:"/demo/startup",element:xe.jsx(CW,{})}),xe.jsx(Vo,{path:"/demo/portfolio",element:xe.jsx(kW,{})}),xe.jsx(Vo,{path:"/demo/ecommerce",element:xe.jsx($W,{})}),xe.jsx(Vo,{path:"*",element:xe.jsx(IW,{})})]})})]}),JS=document.getElementById("root");JS?f$(JS).render(xe.jsx(AW,{})):console.error("Root element not found! Check if the DOM is properly loaded.");
//# sourceMappingURL=index-CiwC4rAx.js.map
